"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

scalar BigDecimal

scalar BigInt

type BitcoinTransfer {
  amountBTC: BigDecimal!
  bitcoinTxHash: String
  btcAddress: String
  createdAtBlockNumber: Int!
  createdAtTimestamp: Int!
  createdAtTx: Transaction!
  direction: BitcoinTransferDirection!
  feeBTC: BigDecimal!
  id: ID!
  nonce: Int
  status: BitcoinTransferStatus!
  totalAmountBTC: BigDecimal!
  updatedAtBlockNumber: Int!
  updatedAtTimestamp: Int!
  updatedAtTx: Transaction!
  user: User!
}

type BitcoinTransferBatchSending {
  bitcoinTxHash: Bytes!
  emittedBy: Bytes!
  id: ID!
  timestamp: Int!
  transaction: Transaction!
  transferBatchSize: Int!
}

input BitcoinTransferBatchSending_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  bitcoinTxHash: Bytes
  bitcoinTxHash_contains: Bytes
  bitcoinTxHash_in: [Bytes!]
  bitcoinTxHash_not: Bytes
  bitcoinTxHash_not_contains: Bytes
  bitcoinTxHash_not_in: [Bytes!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transferBatchSize: Int
  transferBatchSize_gt: Int
  transferBatchSize_gte: Int
  transferBatchSize_in: [Int!]
  transferBatchSize_lt: Int
  transferBatchSize_lte: Int
  transferBatchSize_not: Int
  transferBatchSize_not_in: [Int!]
}

enum BitcoinTransferBatchSending_orderBy {
  bitcoinTxHash
  emittedBy
  id
  timestamp
  transaction
  transferBatchSize
}

enum BitcoinTransferDirection {
  INCOMING
  OUTGOING
}

enum BitcoinTransferStatus {
  """
  the transfer was confirmedly mined in Bitcoin blockchain
  """
  MINED

  """
  the transfer was initiated
  """
  NEW

  """
  the transfer slot has not been initialized
  """
  NOT_APPLICABLE

  """
  the transfer was reclaimed by the user
  """
  RECLAIMED

  """
  the transfer was refunded
  """
  REFUNDED

  """
  the federators have approved this transfer as part of a transfer batch
  """
  SENDING
}

input BitcoinTransfer_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amountBTC: BigDecimal
  amountBTC_gt: BigDecimal
  amountBTC_gte: BigDecimal
  amountBTC_in: [BigDecimal!]
  amountBTC_lt: BigDecimal
  amountBTC_lte: BigDecimal
  amountBTC_not: BigDecimal
  amountBTC_not_in: [BigDecimal!]
  bitcoinTxHash: String
  bitcoinTxHash_contains: String
  bitcoinTxHash_contains_nocase: String
  bitcoinTxHash_ends_with: String
  bitcoinTxHash_ends_with_nocase: String
  bitcoinTxHash_gt: String
  bitcoinTxHash_gte: String
  bitcoinTxHash_in: [String!]
  bitcoinTxHash_lt: String
  bitcoinTxHash_lte: String
  bitcoinTxHash_not: String
  bitcoinTxHash_not_contains: String
  bitcoinTxHash_not_contains_nocase: String
  bitcoinTxHash_not_ends_with: String
  bitcoinTxHash_not_ends_with_nocase: String
  bitcoinTxHash_not_in: [String!]
  bitcoinTxHash_not_starts_with: String
  bitcoinTxHash_not_starts_with_nocase: String
  bitcoinTxHash_starts_with: String
  bitcoinTxHash_starts_with_nocase: String
  btcAddress: String
  btcAddress_contains: String
  btcAddress_contains_nocase: String
  btcAddress_ends_with: String
  btcAddress_ends_with_nocase: String
  btcAddress_gt: String
  btcAddress_gte: String
  btcAddress_in: [String!]
  btcAddress_lt: String
  btcAddress_lte: String
  btcAddress_not: String
  btcAddress_not_contains: String
  btcAddress_not_contains_nocase: String
  btcAddress_not_ends_with: String
  btcAddress_not_ends_with_nocase: String
  btcAddress_not_in: [String!]
  btcAddress_not_starts_with: String
  btcAddress_not_starts_with_nocase: String
  btcAddress_starts_with: String
  btcAddress_starts_with_nocase: String
  createdAtBlockNumber: Int
  createdAtBlockNumber_gt: Int
  createdAtBlockNumber_gte: Int
  createdAtBlockNumber_in: [Int!]
  createdAtBlockNumber_lt: Int
  createdAtBlockNumber_lte: Int
  createdAtBlockNumber_not: Int
  createdAtBlockNumber_not_in: [Int!]
  createdAtTimestamp: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_lt: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_not_in: [Int!]
  createdAtTx: String
  createdAtTx_: Transaction_filter
  createdAtTx_contains: String
  createdAtTx_contains_nocase: String
  createdAtTx_ends_with: String
  createdAtTx_ends_with_nocase: String
  createdAtTx_gt: String
  createdAtTx_gte: String
  createdAtTx_in: [String!]
  createdAtTx_lt: String
  createdAtTx_lte: String
  createdAtTx_not: String
  createdAtTx_not_contains: String
  createdAtTx_not_contains_nocase: String
  createdAtTx_not_ends_with: String
  createdAtTx_not_ends_with_nocase: String
  createdAtTx_not_in: [String!]
  createdAtTx_not_starts_with: String
  createdAtTx_not_starts_with_nocase: String
  createdAtTx_starts_with: String
  createdAtTx_starts_with_nocase: String
  direction: BitcoinTransferDirection
  direction_in: [BitcoinTransferDirection!]
  direction_not: BitcoinTransferDirection
  direction_not_in: [BitcoinTransferDirection!]
  feeBTC: BigDecimal
  feeBTC_gt: BigDecimal
  feeBTC_gte: BigDecimal
  feeBTC_in: [BigDecimal!]
  feeBTC_lt: BigDecimal
  feeBTC_lte: BigDecimal
  feeBTC_not: BigDecimal
  feeBTC_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  nonce: Int
  nonce_gt: Int
  nonce_gte: Int
  nonce_in: [Int!]
  nonce_lt: Int
  nonce_lte: Int
  nonce_not: Int
  nonce_not_in: [Int!]
  status: BitcoinTransferStatus
  status_in: [BitcoinTransferStatus!]
  status_not: BitcoinTransferStatus
  status_not_in: [BitcoinTransferStatus!]
  totalAmountBTC: BigDecimal
  totalAmountBTC_gt: BigDecimal
  totalAmountBTC_gte: BigDecimal
  totalAmountBTC_in: [BigDecimal!]
  totalAmountBTC_lt: BigDecimal
  totalAmountBTC_lte: BigDecimal
  totalAmountBTC_not: BigDecimal
  totalAmountBTC_not_in: [BigDecimal!]
  updatedAtBlockNumber: Int
  updatedAtBlockNumber_gt: Int
  updatedAtBlockNumber_gte: Int
  updatedAtBlockNumber_in: [Int!]
  updatedAtBlockNumber_lt: Int
  updatedAtBlockNumber_lte: Int
  updatedAtBlockNumber_not: Int
  updatedAtBlockNumber_not_in: [Int!]
  updatedAtTimestamp: Int
  updatedAtTimestamp_gt: Int
  updatedAtTimestamp_gte: Int
  updatedAtTimestamp_in: [Int!]
  updatedAtTimestamp_lt: Int
  updatedAtTimestamp_lte: Int
  updatedAtTimestamp_not: Int
  updatedAtTimestamp_not_in: [Int!]
  updatedAtTx: String
  updatedAtTx_: Transaction_filter
  updatedAtTx_contains: String
  updatedAtTx_contains_nocase: String
  updatedAtTx_ends_with: String
  updatedAtTx_ends_with_nocase: String
  updatedAtTx_gt: String
  updatedAtTx_gte: String
  updatedAtTx_in: [String!]
  updatedAtTx_lt: String
  updatedAtTx_lte: String
  updatedAtTx_not: String
  updatedAtTx_not_contains: String
  updatedAtTx_not_contains_nocase: String
  updatedAtTx_not_ends_with: String
  updatedAtTx_not_ends_with_nocase: String
  updatedAtTx_not_in: [String!]
  updatedAtTx_not_starts_with: String
  updatedAtTx_not_starts_with_nocase: String
  updatedAtTx_starts_with: String
  updatedAtTx_starts_with_nocase: String
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum BitcoinTransfer_orderBy {
  amountBTC
  bitcoinTxHash
  btcAddress
  createdAtBlockNumber
  createdAtTimestamp
  createdAtTx
  direction
  feeBTC
  id
  nonce
  status
  totalAmountBTC
  updatedAtBlockNumber
  updatedAtTimestamp
  updatedAtTx
  user
}

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows (takes out a loan)
"""
type Borrow {
  collateralToLoanRate: BigDecimal!
  collateralToken: Bytes!
  currentMargin: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  interestDuration: BigDecimal!
  interestRate: BigDecimal!
  lender: Bytes!
  loanId: Loan!
  loanToken: Bytes!
  newCollateral: BigDecimal!
  newPrincipal: BigDecimal!
  timestamp: Int!
  transaction: Transaction!
  user: User!
}

input Borrow_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  collateralToLoanRate: BigDecimal
  collateralToLoanRate_gt: BigDecimal
  collateralToLoanRate_gte: BigDecimal
  collateralToLoanRate_in: [BigDecimal!]
  collateralToLoanRate_lt: BigDecimal
  collateralToLoanRate_lte: BigDecimal
  collateralToLoanRate_not: BigDecimal
  collateralToLoanRate_not_in: [BigDecimal!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  currentMargin: BigDecimal
  currentMargin_gt: BigDecimal
  currentMargin_gte: BigDecimal
  currentMargin_in: [BigDecimal!]
  currentMargin_lt: BigDecimal
  currentMargin_lte: BigDecimal
  currentMargin_not: BigDecimal
  currentMargin_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  interestDuration: BigDecimal
  interestDuration_gt: BigDecimal
  interestDuration_gte: BigDecimal
  interestDuration_in: [BigDecimal!]
  interestDuration_lt: BigDecimal
  interestDuration_lte: BigDecimal
  interestDuration_not: BigDecimal
  interestDuration_not_in: [BigDecimal!]
  interestRate: BigDecimal
  interestRate_gt: BigDecimal
  interestRate_gte: BigDecimal
  interestRate_in: [BigDecimal!]
  interestRate_lt: BigDecimal
  interestRate_lte: BigDecimal
  interestRate_not: BigDecimal
  interestRate_not_in: [BigDecimal!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanId: String
  loanId_: Loan_filter
  loanId_contains: String
  loanId_contains_nocase: String
  loanId_ends_with: String
  loanId_ends_with_nocase: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_contains_nocase: String
  loanId_not_ends_with: String
  loanId_not_ends_with_nocase: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_not_starts_with_nocase: String
  loanId_starts_with: String
  loanId_starts_with_nocase: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  newCollateral: BigDecimal
  newCollateral_gt: BigDecimal
  newCollateral_gte: BigDecimal
  newCollateral_in: [BigDecimal!]
  newCollateral_lt: BigDecimal
  newCollateral_lte: BigDecimal
  newCollateral_not: BigDecimal
  newCollateral_not_in: [BigDecimal!]
  newPrincipal: BigDecimal
  newPrincipal_gt: BigDecimal
  newPrincipal_gte: BigDecimal
  newPrincipal_in: [BigDecimal!]
  newPrincipal_lt: BigDecimal
  newPrincipal_lte: BigDecimal
  newPrincipal_not: BigDecimal
  newPrincipal_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum Borrow_orderBy {
  collateralToLoanRate
  collateralToken
  currentMargin
  emittedBy
  id
  interestDuration
  interestRate
  lender
  loanId
  loanToken
  newCollateral
  newPrincipal
  timestamp
  transaction
  user
}

"""
Cross Chain Bridge
"""
type Bridge {
  """
  CreatedAtTx - The bridge creation transaction
  """
  createdAtTx: Transaction!

  """
  Federation - the Federation entity associated with this bridge
  """
  federation: Federation!

  """
  Bridge ID - Bridge Contract Address
  """
  id: ID!

  """
  isPaused - Indicates if the bridge is currently paused
  """
  isPaused: Boolean!

  """
  isSuffix - is suffix or prefix
  """
  isSuffix: Boolean

  """
  isUpgrading - Indicates if the bridge is currently upgrading
  """
  isUpgrading: Boolean!

  """
  Pausers - an array of addresses authorized to pause the bridge
  """
  pausers: [Bytes!]!

  """
  Prefix - prefix added to sideTokens symbol when created
  """
  prefix: String

  """
  BridgeType - there are currently only two bridges - RSK_BSC and RSK_ETH
  """
  type: BridgeType!

  """
  UpdatedAtTx - The bridge last updated at this transaction
  """
  updatedAtTx: Transaction!
}

enum BridgeChain {
  BSC
  ETH
  RSK
}

"""
BridgeType - only 2 bridges at the moment - RSK <-> BSC and RSK <-> ETH
"""
enum BridgeType {
  RSK_BSC
  RSK_ETH
}

input Bridge_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  createdAtTx: String
  createdAtTx_: Transaction_filter
  createdAtTx_contains: String
  createdAtTx_contains_nocase: String
  createdAtTx_ends_with: String
  createdAtTx_ends_with_nocase: String
  createdAtTx_gt: String
  createdAtTx_gte: String
  createdAtTx_in: [String!]
  createdAtTx_lt: String
  createdAtTx_lte: String
  createdAtTx_not: String
  createdAtTx_not_contains: String
  createdAtTx_not_contains_nocase: String
  createdAtTx_not_ends_with: String
  createdAtTx_not_ends_with_nocase: String
  createdAtTx_not_in: [String!]
  createdAtTx_not_starts_with: String
  createdAtTx_not_starts_with_nocase: String
  createdAtTx_starts_with: String
  createdAtTx_starts_with_nocase: String
  federation: String
  federation_: Federation_filter
  federation_contains: String
  federation_contains_nocase: String
  federation_ends_with: String
  federation_ends_with_nocase: String
  federation_gt: String
  federation_gte: String
  federation_in: [String!]
  federation_lt: String
  federation_lte: String
  federation_not: String
  federation_not_contains: String
  federation_not_contains_nocase: String
  federation_not_ends_with: String
  federation_not_ends_with_nocase: String
  federation_not_in: [String!]
  federation_not_starts_with: String
  federation_not_starts_with_nocase: String
  federation_starts_with: String
  federation_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isPaused: Boolean
  isPaused_in: [Boolean!]
  isPaused_not: Boolean
  isPaused_not_in: [Boolean!]
  isSuffix: Boolean
  isSuffix_in: [Boolean!]
  isSuffix_not: Boolean
  isSuffix_not_in: [Boolean!]
  isUpgrading: Boolean
  isUpgrading_in: [Boolean!]
  isUpgrading_not: Boolean
  isUpgrading_not_in: [Boolean!]
  pausers: [Bytes!]
  pausers_contains: [Bytes!]
  pausers_contains_nocase: [Bytes!]
  pausers_not: [Bytes!]
  pausers_not_contains: [Bytes!]
  pausers_not_contains_nocase: [Bytes!]
  prefix: String
  prefix_contains: String
  prefix_contains_nocase: String
  prefix_ends_with: String
  prefix_ends_with_nocase: String
  prefix_gt: String
  prefix_gte: String
  prefix_in: [String!]
  prefix_lt: String
  prefix_lte: String
  prefix_not: String
  prefix_not_contains: String
  prefix_not_contains_nocase: String
  prefix_not_ends_with: String
  prefix_not_ends_with_nocase: String
  prefix_not_in: [String!]
  prefix_not_starts_with: String
  prefix_not_starts_with_nocase: String
  prefix_starts_with: String
  prefix_starts_with_nocase: String
  type: BridgeType
  type_in: [BridgeType!]
  type_not: BridgeType
  type_not_in: [BridgeType!]
  updatedAtTx: String
  updatedAtTx_: Transaction_filter
  updatedAtTx_contains: String
  updatedAtTx_contains_nocase: String
  updatedAtTx_ends_with: String
  updatedAtTx_ends_with_nocase: String
  updatedAtTx_gt: String
  updatedAtTx_gte: String
  updatedAtTx_in: [String!]
  updatedAtTx_lt: String
  updatedAtTx_lte: String
  updatedAtTx_not: String
  updatedAtTx_not_contains: String
  updatedAtTx_not_contains_nocase: String
  updatedAtTx_not_ends_with: String
  updatedAtTx_not_ends_with_nocase: String
  updatedAtTx_not_in: [String!]
  updatedAtTx_not_starts_with: String
  updatedAtTx_not_starts_with_nocase: String
  updatedAtTx_starts_with: String
  updatedAtTx_starts_with_nocase: String
}

enum Bridge_orderBy {
  createdAtTx
  federation
  id
  isPaused
  isSuffix
  isUpgrading
  pausers
  prefix
  type
  updatedAtTx
}

scalar Bytes

type CandleStickDay implements ICandleStick {
  baseToken: Token
  close: BigDecimal!
  high: BigDecimal!
  id: ID!
  low: BigDecimal!
  open: BigDecimal
  periodStartUnix: Int!
  quoteToken: Token
  totalVolume: BigDecimal!
  txCount: Int!
}

input CandleStickDay_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  baseToken: String
  baseToken_: Token_filter
  baseToken_contains: String
  baseToken_contains_nocase: String
  baseToken_ends_with: String
  baseToken_ends_with_nocase: String
  baseToken_gt: String
  baseToken_gte: String
  baseToken_in: [String!]
  baseToken_lt: String
  baseToken_lte: String
  baseToken_not: String
  baseToken_not_contains: String
  baseToken_not_contains_nocase: String
  baseToken_not_ends_with: String
  baseToken_not_ends_with_nocase: String
  baseToken_not_in: [String!]
  baseToken_not_starts_with: String
  baseToken_not_starts_with_nocase: String
  baseToken_starts_with: String
  baseToken_starts_with_nocase: String
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  periodStartUnix: Int
  periodStartUnix_gt: Int
  periodStartUnix_gte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_lt: Int
  periodStartUnix_lte: Int
  periodStartUnix_not: Int
  periodStartUnix_not_in: [Int!]
  quoteToken: String
  quoteToken_: Token_filter
  quoteToken_contains: String
  quoteToken_contains_nocase: String
  quoteToken_ends_with: String
  quoteToken_ends_with_nocase: String
  quoteToken_gt: String
  quoteToken_gte: String
  quoteToken_in: [String!]
  quoteToken_lt: String
  quoteToken_lte: String
  quoteToken_not: String
  quoteToken_not_contains: String
  quoteToken_not_contains_nocase: String
  quoteToken_not_ends_with: String
  quoteToken_not_ends_with_nocase: String
  quoteToken_not_in: [String!]
  quoteToken_not_starts_with: String
  quoteToken_not_starts_with_nocase: String
  quoteToken_starts_with: String
  quoteToken_starts_with_nocase: String
  totalVolume: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_lt: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_not_in: [BigDecimal!]
  txCount: Int
  txCount_gt: Int
  txCount_gte: Int
  txCount_in: [Int!]
  txCount_lt: Int
  txCount_lte: Int
  txCount_not: Int
  txCount_not_in: [Int!]
}

enum CandleStickDay_orderBy {
  baseToken
  close
  high
  id
  low
  open
  periodStartUnix
  quoteToken
  totalVolume
  txCount
}

type CandleStickFifteenMinute implements ICandleStick {
  baseToken: Token
  close: BigDecimal!
  high: BigDecimal!
  id: ID!
  low: BigDecimal!
  open: BigDecimal
  periodStartUnix: Int!
  quoteToken: Token
  totalVolume: BigDecimal!
  txCount: Int!
}

input CandleStickFifteenMinute_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  baseToken: String
  baseToken_: Token_filter
  baseToken_contains: String
  baseToken_contains_nocase: String
  baseToken_ends_with: String
  baseToken_ends_with_nocase: String
  baseToken_gt: String
  baseToken_gte: String
  baseToken_in: [String!]
  baseToken_lt: String
  baseToken_lte: String
  baseToken_not: String
  baseToken_not_contains: String
  baseToken_not_contains_nocase: String
  baseToken_not_ends_with: String
  baseToken_not_ends_with_nocase: String
  baseToken_not_in: [String!]
  baseToken_not_starts_with: String
  baseToken_not_starts_with_nocase: String
  baseToken_starts_with: String
  baseToken_starts_with_nocase: String
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  periodStartUnix: Int
  periodStartUnix_gt: Int
  periodStartUnix_gte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_lt: Int
  periodStartUnix_lte: Int
  periodStartUnix_not: Int
  periodStartUnix_not_in: [Int!]
  quoteToken: String
  quoteToken_: Token_filter
  quoteToken_contains: String
  quoteToken_contains_nocase: String
  quoteToken_ends_with: String
  quoteToken_ends_with_nocase: String
  quoteToken_gt: String
  quoteToken_gte: String
  quoteToken_in: [String!]
  quoteToken_lt: String
  quoteToken_lte: String
  quoteToken_not: String
  quoteToken_not_contains: String
  quoteToken_not_contains_nocase: String
  quoteToken_not_ends_with: String
  quoteToken_not_ends_with_nocase: String
  quoteToken_not_in: [String!]
  quoteToken_not_starts_with: String
  quoteToken_not_starts_with_nocase: String
  quoteToken_starts_with: String
  quoteToken_starts_with_nocase: String
  totalVolume: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_lt: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_not_in: [BigDecimal!]
  txCount: Int
  txCount_gt: Int
  txCount_gte: Int
  txCount_in: [Int!]
  txCount_lt: Int
  txCount_lte: Int
  txCount_not: Int
  txCount_not_in: [Int!]
}

enum CandleStickFifteenMinute_orderBy {
  baseToken
  close
  high
  id
  low
  open
  periodStartUnix
  quoteToken
  totalVolume
  txCount
}

type CandleStickFourHour implements ICandleStick {
  baseToken: Token
  close: BigDecimal!
  high: BigDecimal!
  id: ID!
  low: BigDecimal!
  open: BigDecimal
  periodStartUnix: Int!
  quoteToken: Token
  totalVolume: BigDecimal!
  txCount: Int!
}

input CandleStickFourHour_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  baseToken: String
  baseToken_: Token_filter
  baseToken_contains: String
  baseToken_contains_nocase: String
  baseToken_ends_with: String
  baseToken_ends_with_nocase: String
  baseToken_gt: String
  baseToken_gte: String
  baseToken_in: [String!]
  baseToken_lt: String
  baseToken_lte: String
  baseToken_not: String
  baseToken_not_contains: String
  baseToken_not_contains_nocase: String
  baseToken_not_ends_with: String
  baseToken_not_ends_with_nocase: String
  baseToken_not_in: [String!]
  baseToken_not_starts_with: String
  baseToken_not_starts_with_nocase: String
  baseToken_starts_with: String
  baseToken_starts_with_nocase: String
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  periodStartUnix: Int
  periodStartUnix_gt: Int
  periodStartUnix_gte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_lt: Int
  periodStartUnix_lte: Int
  periodStartUnix_not: Int
  periodStartUnix_not_in: [Int!]
  quoteToken: String
  quoteToken_: Token_filter
  quoteToken_contains: String
  quoteToken_contains_nocase: String
  quoteToken_ends_with: String
  quoteToken_ends_with_nocase: String
  quoteToken_gt: String
  quoteToken_gte: String
  quoteToken_in: [String!]
  quoteToken_lt: String
  quoteToken_lte: String
  quoteToken_not: String
  quoteToken_not_contains: String
  quoteToken_not_contains_nocase: String
  quoteToken_not_ends_with: String
  quoteToken_not_ends_with_nocase: String
  quoteToken_not_in: [String!]
  quoteToken_not_starts_with: String
  quoteToken_not_starts_with_nocase: String
  quoteToken_starts_with: String
  quoteToken_starts_with_nocase: String
  totalVolume: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_lt: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_not_in: [BigDecimal!]
  txCount: Int
  txCount_gt: Int
  txCount_gte: Int
  txCount_in: [Int!]
  txCount_lt: Int
  txCount_lte: Int
  txCount_not: Int
  txCount_not_in: [Int!]
}

enum CandleStickFourHour_orderBy {
  baseToken
  close
  high
  id
  low
  open
  periodStartUnix
  quoteToken
  totalVolume
  txCount
}

type CandleStickHour implements ICandleStick {
  baseToken: Token
  close: BigDecimal!
  high: BigDecimal!
  id: ID!
  low: BigDecimal!
  open: BigDecimal
  periodStartUnix: Int!
  quoteToken: Token
  totalVolume: BigDecimal!
  txCount: Int!
}

input CandleStickHour_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  baseToken: String
  baseToken_: Token_filter
  baseToken_contains: String
  baseToken_contains_nocase: String
  baseToken_ends_with: String
  baseToken_ends_with_nocase: String
  baseToken_gt: String
  baseToken_gte: String
  baseToken_in: [String!]
  baseToken_lt: String
  baseToken_lte: String
  baseToken_not: String
  baseToken_not_contains: String
  baseToken_not_contains_nocase: String
  baseToken_not_ends_with: String
  baseToken_not_ends_with_nocase: String
  baseToken_not_in: [String!]
  baseToken_not_starts_with: String
  baseToken_not_starts_with_nocase: String
  baseToken_starts_with: String
  baseToken_starts_with_nocase: String
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  periodStartUnix: Int
  periodStartUnix_gt: Int
  periodStartUnix_gte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_lt: Int
  periodStartUnix_lte: Int
  periodStartUnix_not: Int
  periodStartUnix_not_in: [Int!]
  quoteToken: String
  quoteToken_: Token_filter
  quoteToken_contains: String
  quoteToken_contains_nocase: String
  quoteToken_ends_with: String
  quoteToken_ends_with_nocase: String
  quoteToken_gt: String
  quoteToken_gte: String
  quoteToken_in: [String!]
  quoteToken_lt: String
  quoteToken_lte: String
  quoteToken_not: String
  quoteToken_not_contains: String
  quoteToken_not_contains_nocase: String
  quoteToken_not_ends_with: String
  quoteToken_not_ends_with_nocase: String
  quoteToken_not_in: [String!]
  quoteToken_not_starts_with: String
  quoteToken_not_starts_with_nocase: String
  quoteToken_starts_with: String
  quoteToken_starts_with_nocase: String
  totalVolume: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_lt: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_not_in: [BigDecimal!]
  txCount: Int
  txCount_gt: Int
  txCount_gte: Int
  txCount_in: [Int!]
  txCount_lt: Int
  txCount_lte: Int
  txCount_not: Int
  txCount_not_in: [Int!]
}

enum CandleStickHour_orderBy {
  baseToken
  close
  high
  id
  low
  open
  periodStartUnix
  quoteToken
  totalVolume
  txCount
}

type CandleStickMinute implements ICandleStick {
  baseToken: Token
  close: BigDecimal!
  high: BigDecimal!
  id: ID!
  low: BigDecimal!
  open: BigDecimal
  periodStartUnix: Int!
  quoteToken: Token
  totalVolume: BigDecimal!
  txCount: Int!
}

input CandleStickMinute_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  baseToken: String
  baseToken_: Token_filter
  baseToken_contains: String
  baseToken_contains_nocase: String
  baseToken_ends_with: String
  baseToken_ends_with_nocase: String
  baseToken_gt: String
  baseToken_gte: String
  baseToken_in: [String!]
  baseToken_lt: String
  baseToken_lte: String
  baseToken_not: String
  baseToken_not_contains: String
  baseToken_not_contains_nocase: String
  baseToken_not_ends_with: String
  baseToken_not_ends_with_nocase: String
  baseToken_not_in: [String!]
  baseToken_not_starts_with: String
  baseToken_not_starts_with_nocase: String
  baseToken_starts_with: String
  baseToken_starts_with_nocase: String
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  periodStartUnix: Int
  periodStartUnix_gt: Int
  periodStartUnix_gte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_lt: Int
  periodStartUnix_lte: Int
  periodStartUnix_not: Int
  periodStartUnix_not_in: [Int!]
  quoteToken: String
  quoteToken_: Token_filter
  quoteToken_contains: String
  quoteToken_contains_nocase: String
  quoteToken_ends_with: String
  quoteToken_ends_with_nocase: String
  quoteToken_gt: String
  quoteToken_gte: String
  quoteToken_in: [String!]
  quoteToken_lt: String
  quoteToken_lte: String
  quoteToken_not: String
  quoteToken_not_contains: String
  quoteToken_not_contains_nocase: String
  quoteToken_not_ends_with: String
  quoteToken_not_ends_with_nocase: String
  quoteToken_not_in: [String!]
  quoteToken_not_starts_with: String
  quoteToken_not_starts_with_nocase: String
  quoteToken_starts_with: String
  quoteToken_starts_with_nocase: String
  totalVolume: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_lt: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_not_in: [BigDecimal!]
  txCount: Int
  txCount_gt: Int
  txCount_gte: Int
  txCount_in: [Int!]
  txCount_lt: Int
  txCount_lte: Int
  txCount_not: Int
  txCount_not_in: [Int!]
}

enum CandleStickMinute_orderBy {
  baseToken
  close
  high
  id
  low
  open
  periodStartUnix
  quoteToken
  totalVolume
  txCount
}

enum CandleSticksInterval {
  DayInterval
  FifteenMinutesInterval
  FourHourInterval
  HourInterval
  MinuteInterval
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Borrow event
"""
type CloseWithDeposit {
  closer: Bytes!
  collateralToLoanRate: BigDecimal!
  collateralToken: Bytes!
  collateralWithdrawAmount: BigDecimal!
  currentMargin: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  lender: Bytes!
  loanId: Loan!
  loanToken: Bytes!
  repayAmount: BigDecimal!
  timestamp: Int!
  transaction: Transaction!
  user: Bytes!
}

input CloseWithDeposit_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  closer: Bytes
  closer_contains: Bytes
  closer_in: [Bytes!]
  closer_not: Bytes
  closer_not_contains: Bytes
  closer_not_in: [Bytes!]
  collateralToLoanRate: BigDecimal
  collateralToLoanRate_gt: BigDecimal
  collateralToLoanRate_gte: BigDecimal
  collateralToLoanRate_in: [BigDecimal!]
  collateralToLoanRate_lt: BigDecimal
  collateralToLoanRate_lte: BigDecimal
  collateralToLoanRate_not: BigDecimal
  collateralToLoanRate_not_in: [BigDecimal!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  collateralWithdrawAmount: BigDecimal
  collateralWithdrawAmount_gt: BigDecimal
  collateralWithdrawAmount_gte: BigDecimal
  collateralWithdrawAmount_in: [BigDecimal!]
  collateralWithdrawAmount_lt: BigDecimal
  collateralWithdrawAmount_lte: BigDecimal
  collateralWithdrawAmount_not: BigDecimal
  collateralWithdrawAmount_not_in: [BigDecimal!]
  currentMargin: BigDecimal
  currentMargin_gt: BigDecimal
  currentMargin_gte: BigDecimal
  currentMargin_in: [BigDecimal!]
  currentMargin_lt: BigDecimal
  currentMargin_lte: BigDecimal
  currentMargin_not: BigDecimal
  currentMargin_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanId: String
  loanId_: Loan_filter
  loanId_contains: String
  loanId_contains_nocase: String
  loanId_ends_with: String
  loanId_ends_with_nocase: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_contains_nocase: String
  loanId_not_ends_with: String
  loanId_not_ends_with_nocase: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_not_starts_with_nocase: String
  loanId_starts_with: String
  loanId_starts_with_nocase: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  repayAmount: BigDecimal
  repayAmount_gt: BigDecimal
  repayAmount_gte: BigDecimal
  repayAmount_in: [BigDecimal!]
  repayAmount_lt: BigDecimal
  repayAmount_lte: BigDecimal
  repayAmount_not: BigDecimal
  repayAmount_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  user: Bytes
  user_contains: Bytes
  user_in: [Bytes!]
  user_not: Bytes
  user_not_contains: Bytes
  user_not_in: [Bytes!]
}

enum CloseWithDeposit_orderBy {
  closer
  collateralToLoanRate
  collateralToken
  collateralWithdrawAmount
  currentMargin
  emittedBy
  id
  lender
  loanId
  loanToken
  repayAmount
  timestamp
  transaction
  user
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Margin Trade
"""
type CloseWithSwap {
  closer: Bytes!
  collateralToken: Bytes!

  """
  Leverage on the smart contract does not count user-provided collateral.
  So, what would on the dapp be a 2x leverage trade would be a 1 here
  """
  currentLeverage: BigDecimal!
  emittedBy: Bytes!
  exitPrice: BigDecimal!
  id: ID!
  lender: Bytes!
  loanCloseAmount: BigDecimal!
  loanId: Loan!
  loanToken: Bytes!
  positionCloseSize: BigDecimal!
  timestamp: Int!
  transaction: Transaction!
  user: Bytes!
}

input CloseWithSwap_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  closer: Bytes
  closer_contains: Bytes
  closer_in: [Bytes!]
  closer_not: Bytes
  closer_not_contains: Bytes
  closer_not_in: [Bytes!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  currentLeverage: BigDecimal
  currentLeverage_gt: BigDecimal
  currentLeverage_gte: BigDecimal
  currentLeverage_in: [BigDecimal!]
  currentLeverage_lt: BigDecimal
  currentLeverage_lte: BigDecimal
  currentLeverage_not: BigDecimal
  currentLeverage_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  exitPrice: BigDecimal
  exitPrice_gt: BigDecimal
  exitPrice_gte: BigDecimal
  exitPrice_in: [BigDecimal!]
  exitPrice_lt: BigDecimal
  exitPrice_lte: BigDecimal
  exitPrice_not: BigDecimal
  exitPrice_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanCloseAmount: BigDecimal
  loanCloseAmount_gt: BigDecimal
  loanCloseAmount_gte: BigDecimal
  loanCloseAmount_in: [BigDecimal!]
  loanCloseAmount_lt: BigDecimal
  loanCloseAmount_lte: BigDecimal
  loanCloseAmount_not: BigDecimal
  loanCloseAmount_not_in: [BigDecimal!]
  loanId: String
  loanId_: Loan_filter
  loanId_contains: String
  loanId_contains_nocase: String
  loanId_ends_with: String
  loanId_ends_with_nocase: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_contains_nocase: String
  loanId_not_ends_with: String
  loanId_not_ends_with_nocase: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_not_starts_with_nocase: String
  loanId_starts_with: String
  loanId_starts_with_nocase: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  positionCloseSize: BigDecimal
  positionCloseSize_gt: BigDecimal
  positionCloseSize_gte: BigDecimal
  positionCloseSize_in: [BigDecimal!]
  positionCloseSize_lt: BigDecimal
  positionCloseSize_lte: BigDecimal
  positionCloseSize_not: BigDecimal
  positionCloseSize_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  user: Bytes
  user_contains: Bytes
  user_in: [Bytes!]
  user_not: Bytes
  user_not_contains: Bytes
  user_not_in: [Bytes!]
}

enum CloseWithSwap_orderBy {
  closer
  collateralToken
  currentLeverage
  emittedBy
  exitPrice
  id
  lender
  loanCloseAmount
  loanId
  loanToken
  positionCloseSize
  timestamp
  transaction
  user
}

"""
Granular Conversion events, exactly as they appear on the contracts.
These events are the raw data that the Swap entity and candlestick entities are built from.
"""
type Conversion {
  _amount: BigDecimal!
  _conversionFee: BigDecimal!
  _fromToken: Token!
  _protocolFee: BigDecimal!
  _return: BigDecimal!
  _toToken: Token!
  _trader: Bytes!
  blockNumber: Int!
  emittedBy: LiquidityPool!
  id: ID!
  timestamp: Int!
  transaction: Transaction!
}

input Conversion_filter {
  _amount: BigDecimal
  _amount_gt: BigDecimal
  _amount_gte: BigDecimal
  _amount_in: [BigDecimal!]
  _amount_lt: BigDecimal
  _amount_lte: BigDecimal
  _amount_not: BigDecimal
  _amount_not_in: [BigDecimal!]

  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  _conversionFee: BigDecimal
  _conversionFee_gt: BigDecimal
  _conversionFee_gte: BigDecimal
  _conversionFee_in: [BigDecimal!]
  _conversionFee_lt: BigDecimal
  _conversionFee_lte: BigDecimal
  _conversionFee_not: BigDecimal
  _conversionFee_not_in: [BigDecimal!]
  _fromToken: String
  _fromToken_: Token_filter
  _fromToken_contains: String
  _fromToken_contains_nocase: String
  _fromToken_ends_with: String
  _fromToken_ends_with_nocase: String
  _fromToken_gt: String
  _fromToken_gte: String
  _fromToken_in: [String!]
  _fromToken_lt: String
  _fromToken_lte: String
  _fromToken_not: String
  _fromToken_not_contains: String
  _fromToken_not_contains_nocase: String
  _fromToken_not_ends_with: String
  _fromToken_not_ends_with_nocase: String
  _fromToken_not_in: [String!]
  _fromToken_not_starts_with: String
  _fromToken_not_starts_with_nocase: String
  _fromToken_starts_with: String
  _fromToken_starts_with_nocase: String
  _protocolFee: BigDecimal
  _protocolFee_gt: BigDecimal
  _protocolFee_gte: BigDecimal
  _protocolFee_in: [BigDecimal!]
  _protocolFee_lt: BigDecimal
  _protocolFee_lte: BigDecimal
  _protocolFee_not: BigDecimal
  _protocolFee_not_in: [BigDecimal!]
  _return: BigDecimal
  _return_gt: BigDecimal
  _return_gte: BigDecimal
  _return_in: [BigDecimal!]
  _return_lt: BigDecimal
  _return_lte: BigDecimal
  _return_not: BigDecimal
  _return_not_in: [BigDecimal!]
  _toToken: String
  _toToken_: Token_filter
  _toToken_contains: String
  _toToken_contains_nocase: String
  _toToken_ends_with: String
  _toToken_ends_with_nocase: String
  _toToken_gt: String
  _toToken_gte: String
  _toToken_in: [String!]
  _toToken_lt: String
  _toToken_lte: String
  _toToken_not: String
  _toToken_not_contains: String
  _toToken_not_contains_nocase: String
  _toToken_not_ends_with: String
  _toToken_not_ends_with_nocase: String
  _toToken_not_in: [String!]
  _toToken_not_starts_with: String
  _toToken_not_starts_with_nocase: String
  _toToken_starts_with: String
  _toToken_starts_with_nocase: String
  _trader: Bytes
  _trader_contains: Bytes
  _trader_in: [Bytes!]
  _trader_not: Bytes
  _trader_not_contains: Bytes
  _trader_not_in: [Bytes!]
  blockNumber: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_in: [Int!]
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_not: Int
  blockNumber_not_in: [Int!]
  emittedBy: String
  emittedBy_: LiquidityPool_filter
  emittedBy_contains: String
  emittedBy_contains_nocase: String
  emittedBy_ends_with: String
  emittedBy_ends_with_nocase: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_contains_nocase: String
  emittedBy_not_ends_with: String
  emittedBy_not_ends_with_nocase: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_not_starts_with_nocase: String
  emittedBy_starts_with: String
  emittedBy_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Conversion_orderBy {
  _amount
  _conversionFee
  _fromToken
  _protocolFee
  _return
  _toToken
  _trader
  blockNumber
  emittedBy
  id
  timestamp
  transaction
}

"""
The ConverterRegistry registers each new AMM pool added to the Sovryn Protocol
"""
type ConverterRegistry {
  """
  All ERC20 tokens in this registry
  """
  connectorTokens(
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Token_filter
  ): [Token!]

  """
  All the converters (AMM pools) associated with this registry
  """
  converters(
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityPool_filter
  ): [LiquidityPool!]

  """
  ID is the address of the converter registry contract
  """
  id: ID!

  """
  The number of active converters (AMM pools) in this registry
  """
  numConverters: Int!

  """
  All smart tokens in this registry
  """
  smartTokens(
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: SmartToken_filter
  ): [SmartToken!]
}

input ConverterRegistry_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  connectorTokens_: Token_filter
  converters_: LiquidityPool_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  numConverters: Int
  numConverters_gt: Int
  numConverters_gte: Int
  numConverters_in: [Int!]
  numConverters_lt: Int
  numConverters_lte: Int
  numConverters_not: Int
  numConverters_not_in: [Int!]
  smartTokens_: SmartToken_filter
}

enum ConverterRegistry_orderBy {
  connectorTokens
  converters
  id
  numConverters
  smartTokens
}

enum CrossDirection {
  Incoming
  Outgoing
}

enum CrossStatus {
  Executed
  Revoked
  Voting
}

type CrossTransfer {
  """
  Amount - the amount of originalToken transferred across the bridge
  """
  amount: BigDecimal!

  """
  CreatedAtTimestamp - the timestamp at which this transfer was created
  """
  createdAtTimestamp: Int!

  """
  CreatedAtTx - the transaction at which this transfer was created
  """
  createdAtTx: Transaction!

  """
  Direction - the direction of the cross transfer (Incoming or Outgoing)
  """
  direction: CrossDirection!

  """
  sourceChain - the source chain - for outgoing it is RSK and for incoming it is BSC/ETH
  """
  externalChain: BridgeChain!

  """
  Address of the user on the external chain (eg Ethereum, BSC etc.)
  """
  externalUser: Bytes

  """
  Id - the cross transfer Id - for outgoing it is generated from the cross event params for incoming it is coming from the federation events
  """
  id: ID!

  """
  IsSigned - is this transfer signed by the federation contract (only relevant for the new federation contracts)
  """
  isSigned: Boolean!

  """
  originalTokenAddress - the original token address for the transfer (for outgoing it is just the RSK token address)
  """
  originalTokenAddress: Bytes!

  """
  sideToken - the SideToken entity if exist of original token address
  """
  sideToken: SideToken

  """
  SourceChainBlockHash - the source chain block hash of the transfer, for outgoing transfers this is just the RSK block hash
  """
  sourceChainBlockHash: Bytes

  """
  SourceChainTransactionHash - the source chain transaction hash of the transfer, for outgoing transfers this is just the RSK transaction hash
  """
  sourceChainTransactionHash: Bytes

  """
  Status - transfer status - Voting, Executed, Revoked
  """
  status: CrossStatus!

  """
  Symbol - the token symbol
  """
  symbol: String

  """
  Token - the token entity if exist of original token address
  """
  token: Token

  """
  TokenAddress - the token address for the transfer (only relevant for incoming transfers)
  """
  tokenAddress: Bytes

  """
  updatedAtTimestamp - the timestamp at which this transfer was last updated
  """
  updatedAtTimestamp: Int!

  """
  updatedAtTx - the transaction at which this transfer was last updated
  """
  updatedAtTx: Transaction!

  """
  Address of the user on RSK chain
  """
  user: User!

  """
  Votes - Number of votes cast for this transfer
  """
  votes: Int
}

input CrossTransfer_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  createdAtTimestamp: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_lt: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_not_in: [Int!]
  createdAtTx: String
  createdAtTx_: Transaction_filter
  createdAtTx_contains: String
  createdAtTx_contains_nocase: String
  createdAtTx_ends_with: String
  createdAtTx_ends_with_nocase: String
  createdAtTx_gt: String
  createdAtTx_gte: String
  createdAtTx_in: [String!]
  createdAtTx_lt: String
  createdAtTx_lte: String
  createdAtTx_not: String
  createdAtTx_not_contains: String
  createdAtTx_not_contains_nocase: String
  createdAtTx_not_ends_with: String
  createdAtTx_not_ends_with_nocase: String
  createdAtTx_not_in: [String!]
  createdAtTx_not_starts_with: String
  createdAtTx_not_starts_with_nocase: String
  createdAtTx_starts_with: String
  createdAtTx_starts_with_nocase: String
  direction: CrossDirection
  direction_in: [CrossDirection!]
  direction_not: CrossDirection
  direction_not_in: [CrossDirection!]
  externalChain: BridgeChain
  externalChain_in: [BridgeChain!]
  externalChain_not: BridgeChain
  externalChain_not_in: [BridgeChain!]
  externalUser: Bytes
  externalUser_contains: Bytes
  externalUser_in: [Bytes!]
  externalUser_not: Bytes
  externalUser_not_contains: Bytes
  externalUser_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isSigned: Boolean
  isSigned_in: [Boolean!]
  isSigned_not: Boolean
  isSigned_not_in: [Boolean!]
  originalTokenAddress: Bytes
  originalTokenAddress_contains: Bytes
  originalTokenAddress_in: [Bytes!]
  originalTokenAddress_not: Bytes
  originalTokenAddress_not_contains: Bytes
  originalTokenAddress_not_in: [Bytes!]
  sideToken: String
  sideToken_: SideToken_filter
  sideToken_contains: String
  sideToken_contains_nocase: String
  sideToken_ends_with: String
  sideToken_ends_with_nocase: String
  sideToken_gt: String
  sideToken_gte: String
  sideToken_in: [String!]
  sideToken_lt: String
  sideToken_lte: String
  sideToken_not: String
  sideToken_not_contains: String
  sideToken_not_contains_nocase: String
  sideToken_not_ends_with: String
  sideToken_not_ends_with_nocase: String
  sideToken_not_in: [String!]
  sideToken_not_starts_with: String
  sideToken_not_starts_with_nocase: String
  sideToken_starts_with: String
  sideToken_starts_with_nocase: String
  sourceChainBlockHash: Bytes
  sourceChainBlockHash_contains: Bytes
  sourceChainBlockHash_in: [Bytes!]
  sourceChainBlockHash_not: Bytes
  sourceChainBlockHash_not_contains: Bytes
  sourceChainBlockHash_not_in: [Bytes!]
  sourceChainTransactionHash: Bytes
  sourceChainTransactionHash_contains: Bytes
  sourceChainTransactionHash_in: [Bytes!]
  sourceChainTransactionHash_not: Bytes
  sourceChainTransactionHash_not_contains: Bytes
  sourceChainTransactionHash_not_in: [Bytes!]
  status: CrossStatus
  status_in: [CrossStatus!]
  status_not: CrossStatus
  status_not_in: [CrossStatus!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  token: String
  tokenAddress: Bytes
  tokenAddress_contains: Bytes
  tokenAddress_in: [Bytes!]
  tokenAddress_not: Bytes
  tokenAddress_not_contains: Bytes
  tokenAddress_not_in: [Bytes!]
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  updatedAtTimestamp: Int
  updatedAtTimestamp_gt: Int
  updatedAtTimestamp_gte: Int
  updatedAtTimestamp_in: [Int!]
  updatedAtTimestamp_lt: Int
  updatedAtTimestamp_lte: Int
  updatedAtTimestamp_not: Int
  updatedAtTimestamp_not_in: [Int!]
  updatedAtTx: String
  updatedAtTx_: Transaction_filter
  updatedAtTx_contains: String
  updatedAtTx_contains_nocase: String
  updatedAtTx_ends_with: String
  updatedAtTx_ends_with_nocase: String
  updatedAtTx_gt: String
  updatedAtTx_gte: String
  updatedAtTx_in: [String!]
  updatedAtTx_lt: String
  updatedAtTx_lte: String
  updatedAtTx_not: String
  updatedAtTx_not_contains: String
  updatedAtTx_not_contains_nocase: String
  updatedAtTx_not_ends_with: String
  updatedAtTx_not_ends_with_nocase: String
  updatedAtTx_not_in: [String!]
  updatedAtTx_not_starts_with: String
  updatedAtTx_not_starts_with_nocase: String
  updatedAtTx_starts_with: String
  updatedAtTx_starts_with_nocase: String
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  votes: Int
  votes_gt: Int
  votes_gte: Int
  votes_in: [Int!]
  votes_lt: Int
  votes_lte: Int
  votes_not: Int
  votes_not_in: [Int!]
}

enum CrossTransfer_orderBy {
  amount
  createdAtTimestamp
  createdAtTx
  direction
  externalChain
  externalUser
  id
  isSigned
  originalTokenAddress
  sideToken
  sourceChainBlockHash
  sourceChainTransactionHash
  status
  symbol
  token
  tokenAddress
  updatedAtTimestamp
  updatedAtTx
  user
  votes
}

type Deposit {
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  timestamp: Int!
  to: Bytes!
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user closes adds collateral to a Margin Trade or Borrow
"""
type DepositCollateral {
  depositAmount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  loanId: Loan!

  """
  Rate is sometimes null because this property was not included in older versions of the contract
  """
  rate: BigDecimal
  timestamp: Int!
  transaction: Transaction!
}

input DepositCollateral_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  depositAmount: BigDecimal
  depositAmount_gt: BigDecimal
  depositAmount_gte: BigDecimal
  depositAmount_in: [BigDecimal!]
  depositAmount_lt: BigDecimal
  depositAmount_lte: BigDecimal
  depositAmount_not: BigDecimal
  depositAmount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: String
  loanId_: Loan_filter
  loanId_contains: String
  loanId_contains_nocase: String
  loanId_ends_with: String
  loanId_ends_with_nocase: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_contains_nocase: String
  loanId_not_ends_with: String
  loanId_not_ends_with_nocase: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_not_starts_with_nocase: String
  loanId_starts_with: String
  loanId_starts_with_nocase: String
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum DepositCollateral_orderBy {
  depositAmount
  emittedBy
  id
  loanId
  rate
  timestamp
  transaction
}

input Deposit_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  to: Bytes
  to_contains: Bytes
  to_in: [Bytes!]
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Deposit_orderBy {
  amount
  emittedBy
  id
  timestamp
  to
  transaction
}

type FastBTCBridgeStat {
  createdAtTx: Transaction!
  id: ID!
  totalAmountBTCInitialized: BigDecimal!
  totalAmountBTCMined: BigDecimal!
  totalAmountBTCRefunded: BigDecimal!
  totalAmountBTCSending: BigDecimal!
  totalFeesBTC: BigDecimal!
  updatedAtTx: Transaction!
  user: User
}

input FastBTCBridgeStat_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  createdAtTx: String
  createdAtTx_: Transaction_filter
  createdAtTx_contains: String
  createdAtTx_contains_nocase: String
  createdAtTx_ends_with: String
  createdAtTx_ends_with_nocase: String
  createdAtTx_gt: String
  createdAtTx_gte: String
  createdAtTx_in: [String!]
  createdAtTx_lt: String
  createdAtTx_lte: String
  createdAtTx_not: String
  createdAtTx_not_contains: String
  createdAtTx_not_contains_nocase: String
  createdAtTx_not_ends_with: String
  createdAtTx_not_ends_with_nocase: String
  createdAtTx_not_in: [String!]
  createdAtTx_not_starts_with: String
  createdAtTx_not_starts_with_nocase: String
  createdAtTx_starts_with: String
  createdAtTx_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  totalAmountBTCInitialized: BigDecimal
  totalAmountBTCInitialized_gt: BigDecimal
  totalAmountBTCInitialized_gte: BigDecimal
  totalAmountBTCInitialized_in: [BigDecimal!]
  totalAmountBTCInitialized_lt: BigDecimal
  totalAmountBTCInitialized_lte: BigDecimal
  totalAmountBTCInitialized_not: BigDecimal
  totalAmountBTCInitialized_not_in: [BigDecimal!]
  totalAmountBTCMined: BigDecimal
  totalAmountBTCMined_gt: BigDecimal
  totalAmountBTCMined_gte: BigDecimal
  totalAmountBTCMined_in: [BigDecimal!]
  totalAmountBTCMined_lt: BigDecimal
  totalAmountBTCMined_lte: BigDecimal
  totalAmountBTCMined_not: BigDecimal
  totalAmountBTCMined_not_in: [BigDecimal!]
  totalAmountBTCRefunded: BigDecimal
  totalAmountBTCRefunded_gt: BigDecimal
  totalAmountBTCRefunded_gte: BigDecimal
  totalAmountBTCRefunded_in: [BigDecimal!]
  totalAmountBTCRefunded_lt: BigDecimal
  totalAmountBTCRefunded_lte: BigDecimal
  totalAmountBTCRefunded_not: BigDecimal
  totalAmountBTCRefunded_not_in: [BigDecimal!]
  totalAmountBTCSending: BigDecimal
  totalAmountBTCSending_gt: BigDecimal
  totalAmountBTCSending_gte: BigDecimal
  totalAmountBTCSending_in: [BigDecimal!]
  totalAmountBTCSending_lt: BigDecimal
  totalAmountBTCSending_lte: BigDecimal
  totalAmountBTCSending_not: BigDecimal
  totalAmountBTCSending_not_in: [BigDecimal!]
  totalFeesBTC: BigDecimal
  totalFeesBTC_gt: BigDecimal
  totalFeesBTC_gte: BigDecimal
  totalFeesBTC_in: [BigDecimal!]
  totalFeesBTC_lt: BigDecimal
  totalFeesBTC_lte: BigDecimal
  totalFeesBTC_not: BigDecimal
  totalFeesBTC_not_in: [BigDecimal!]
  updatedAtTx: String
  updatedAtTx_: Transaction_filter
  updatedAtTx_contains: String
  updatedAtTx_contains_nocase: String
  updatedAtTx_ends_with: String
  updatedAtTx_ends_with_nocase: String
  updatedAtTx_gt: String
  updatedAtTx_gte: String
  updatedAtTx_in: [String!]
  updatedAtTx_lt: String
  updatedAtTx_lte: String
  updatedAtTx_not: String
  updatedAtTx_not_contains: String
  updatedAtTx_not_contains_nocase: String
  updatedAtTx_not_ends_with: String
  updatedAtTx_not_ends_with_nocase: String
  updatedAtTx_not_in: [String!]
  updatedAtTx_not_starts_with: String
  updatedAtTx_not_starts_with_nocase: String
  updatedAtTx_starts_with: String
  updatedAtTx_starts_with_nocase: String
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum FastBTCBridgeStat_orderBy {
  createdAtTx
  id
  totalAmountBTCInitialized
  totalAmountBTCMined
  totalAmountBTCRefunded
  totalAmountBTCSending
  totalFeesBTC
  updatedAtTx
  user
}

"""
Federation - the federation entity
"""
type Federation {
  """
  Bridge - the bridge that is associated with this federation contract
  """
  bridge: Bridge!

  """
  CreatedAtTx - the creation transaction of this federation
  """
  createdAtTx: Transaction!

  """
  Id - the id of the federation entity is the federation contract address
  """
  id: ID!

  """
  IsActive - is this federation contract active
  """
  isActive: Boolean!

  """
  Members - federators that are members of this federation
  """
  members: [Bytes!]!

  """
  TotalExecuted - total transfers executed by this federation
  """
  totalExecuted: Int!

  """
  TotalVotes - total votes cast on this federation
  """
  totalVotes: Int!

  """
  UpdatedAtTx - the transaction at which this entity was last updated
  """
  updatedAtTx: Transaction!
}

input Federation_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  bridge: String
  bridge_: Bridge_filter
  bridge_contains: String
  bridge_contains_nocase: String
  bridge_ends_with: String
  bridge_ends_with_nocase: String
  bridge_gt: String
  bridge_gte: String
  bridge_in: [String!]
  bridge_lt: String
  bridge_lte: String
  bridge_not: String
  bridge_not_contains: String
  bridge_not_contains_nocase: String
  bridge_not_ends_with: String
  bridge_not_ends_with_nocase: String
  bridge_not_in: [String!]
  bridge_not_starts_with: String
  bridge_not_starts_with_nocase: String
  bridge_starts_with: String
  bridge_starts_with_nocase: String
  createdAtTx: String
  createdAtTx_: Transaction_filter
  createdAtTx_contains: String
  createdAtTx_contains_nocase: String
  createdAtTx_ends_with: String
  createdAtTx_ends_with_nocase: String
  createdAtTx_gt: String
  createdAtTx_gte: String
  createdAtTx_in: [String!]
  createdAtTx_lt: String
  createdAtTx_lte: String
  createdAtTx_not: String
  createdAtTx_not_contains: String
  createdAtTx_not_contains_nocase: String
  createdAtTx_not_ends_with: String
  createdAtTx_not_ends_with_nocase: String
  createdAtTx_not_in: [String!]
  createdAtTx_not_starts_with: String
  createdAtTx_not_starts_with_nocase: String
  createdAtTx_starts_with: String
  createdAtTx_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isActive: Boolean
  isActive_in: [Boolean!]
  isActive_not: Boolean
  isActive_not_in: [Boolean!]
  members: [Bytes!]
  members_contains: [Bytes!]
  members_contains_nocase: [Bytes!]
  members_not: [Bytes!]
  members_not_contains: [Bytes!]
  members_not_contains_nocase: [Bytes!]
  totalExecuted: Int
  totalExecuted_gt: Int
  totalExecuted_gte: Int
  totalExecuted_in: [Int!]
  totalExecuted_lt: Int
  totalExecuted_lte: Int
  totalExecuted_not: Int
  totalExecuted_not_in: [Int!]
  totalVotes: Int
  totalVotes_gt: Int
  totalVotes_gte: Int
  totalVotes_in: [Int!]
  totalVotes_lt: Int
  totalVotes_lte: Int
  totalVotes_not: Int
  totalVotes_not_in: [Int!]
  updatedAtTx: String
  updatedAtTx_: Transaction_filter
  updatedAtTx_contains: String
  updatedAtTx_contains_nocase: String
  updatedAtTx_ends_with: String
  updatedAtTx_ends_with_nocase: String
  updatedAtTx_gt: String
  updatedAtTx_gte: String
  updatedAtTx_in: [String!]
  updatedAtTx_lt: String
  updatedAtTx_lte: String
  updatedAtTx_not: String
  updatedAtTx_not_contains: String
  updatedAtTx_not_contains_nocase: String
  updatedAtTx_not_ends_with: String
  updatedAtTx_not_ends_with_nocase: String
  updatedAtTx_not_in: [String!]
  updatedAtTx_not_starts_with: String
  updatedAtTx_not_starts_with_nocase: String
  updatedAtTx_starts_with: String
  updatedAtTx_starts_with_nocase: String
}

enum Federation_orderBy {
  bridge
  createdAtTx
  id
  isActive
  members
  totalExecuted
  totalVotes
  updatedAtTx
}

type FeeSharingTokensTransferred {
  amount: BigDecimal!
  id: ID!
  sender: Bytes!
  token: Bytes!
}

input FeeSharingTokensTransferred_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  sender: Bytes
  sender_contains: Bytes
  sender_in: [Bytes!]
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
}

enum FeeSharingTokensTransferred_orderBy {
  amount
  id
  sender
  token
}

enum FeeType {
  AMM
  Borrowing
  Lending
  Trading
}

"""
Candlesticks are for presentational purposes on the dapp. This entity supports the candlestick trading data on the trading view charts.
Trading data is available for the following pairs:
1. All tokens to RBTC
2. All tokens to current usdStablecoin (see ProtocolStats entity for more information)
There is not candlestick data for other trading pairs as this would cause the amount of data stored to increase exponentially
"""
interface ICandleStick {
  """
  Eg in the pair SOV-XUSD, the base token is SOV and the quote token is XUSD
  Prices shown are the price of the base token in the quote token (eg price of SOV in XUSD)
  """
  baseToken: Token
  close: BigDecimal!
  high: BigDecimal!

  """
  The ID is fromToken + toToken + timestamp
  toToken will be either RBTC or XUSD
  """
  id: ID!
  low: BigDecimal!
  open: BigDecimal

  """
  Unix timestamp for the candlestick start time
  """
  periodStartUnix: Int!
  quoteToken: Token

  """
  The volume of the base token that has been bought and sold in this time period
  """
  totalVolume: BigDecimal!
  txCount: Int!
}

input ICandleStick_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  baseToken: String
  baseToken_: Token_filter
  baseToken_contains: String
  baseToken_contains_nocase: String
  baseToken_ends_with: String
  baseToken_ends_with_nocase: String
  baseToken_gt: String
  baseToken_gte: String
  baseToken_in: [String!]
  baseToken_lt: String
  baseToken_lte: String
  baseToken_not: String
  baseToken_not_contains: String
  baseToken_not_contains_nocase: String
  baseToken_not_ends_with: String
  baseToken_not_ends_with_nocase: String
  baseToken_not_in: [String!]
  baseToken_not_starts_with: String
  baseToken_not_starts_with_nocase: String
  baseToken_starts_with: String
  baseToken_starts_with_nocase: String
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  periodStartUnix: Int
  periodStartUnix_gt: Int
  periodStartUnix_gte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_lt: Int
  periodStartUnix_lte: Int
  periodStartUnix_not: Int
  periodStartUnix_not_in: [Int!]
  quoteToken: String
  quoteToken_: Token_filter
  quoteToken_contains: String
  quoteToken_contains_nocase: String
  quoteToken_ends_with: String
  quoteToken_ends_with_nocase: String
  quoteToken_gt: String
  quoteToken_gte: String
  quoteToken_in: [String!]
  quoteToken_lt: String
  quoteToken_lte: String
  quoteToken_not: String
  quoteToken_not_contains: String
  quoteToken_not_contains_nocase: String
  quoteToken_not_ends_with: String
  quoteToken_not_ends_with_nocase: String
  quoteToken_not_in: [String!]
  quoteToken_not_starts_with: String
  quoteToken_not_starts_with_nocase: String
  quoteToken_starts_with: String
  quoteToken_starts_with_nocase: String
  totalVolume: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_lt: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_not_in: [BigDecimal!]
  txCount: Int
  txCount_gt: Int
  txCount_gte: Int
  txCount_in: [Int!]
  txCount_lt: Int
  txCount_lte: Int
  txCount_not: Int
  txCount_not_in: [Int!]
}

enum ICandleStick_orderBy {
  baseToken
  close
  high
  id
  low
  open
  periodStartUnix
  quoteToken
  totalVolume
  txCount
}

"""
LendingHistoryItem is one user's history of Lend/UnLend events across all the lending pools
"""
type LendingHistoryItem {
  """
  The amount of ERC20 token that was lent/unlent
  """
  amount: BigDecimal!

  """
  The underlying asset for this pool (eg USDT for the iUSDT pool)
  """
  asset: Token
  emittedBy: String!
  id: ID!
  lender: User!

  """
  The lending pool the user interacted with
  """
  lendingPool: LendingPool!

  """
  The amount of pool token that was minted or burned
  """
  loanTokenAmount: BigDecimal!
  timestamp: Int!
  transaction: Transaction!

  """
  Type is Lend/UnLend
  """
  type: LendingHistoryType!

  """
  Foreign key to the UserLendingHistory entity (see the docs on this entity for more information)
  """
  userLendingHistory: UserLendingHistory!
}

input LendingHistoryItem_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  asset: String
  asset_: Token_filter
  asset_contains: String
  asset_contains_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_gt: String
  asset_gte: String
  asset_in: [String!]
  asset_lt: String
  asset_lte: String
  asset_not: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_not_in: [String!]
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  emittedBy: String
  emittedBy_contains: String
  emittedBy_contains_nocase: String
  emittedBy_ends_with: String
  emittedBy_ends_with_nocase: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_contains_nocase: String
  emittedBy_not_ends_with: String
  emittedBy_not_ends_with_nocase: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_not_starts_with_nocase: String
  emittedBy_starts_with: String
  emittedBy_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: String
  lender_: User_filter
  lender_contains: String
  lender_contains_nocase: String
  lender_ends_with: String
  lender_ends_with_nocase: String
  lender_gt: String
  lender_gte: String
  lender_in: [String!]
  lender_lt: String
  lender_lte: String
  lender_not: String
  lender_not_contains: String
  lender_not_contains_nocase: String
  lender_not_ends_with: String
  lender_not_ends_with_nocase: String
  lender_not_in: [String!]
  lender_not_starts_with: String
  lender_not_starts_with_nocase: String
  lender_starts_with: String
  lender_starts_with_nocase: String
  lendingPool: String
  lendingPool_: LendingPool_filter
  lendingPool_contains: String
  lendingPool_contains_nocase: String
  lendingPool_ends_with: String
  lendingPool_ends_with_nocase: String
  lendingPool_gt: String
  lendingPool_gte: String
  lendingPool_in: [String!]
  lendingPool_lt: String
  lendingPool_lte: String
  lendingPool_not: String
  lendingPool_not_contains: String
  lendingPool_not_contains_nocase: String
  lendingPool_not_ends_with: String
  lendingPool_not_ends_with_nocase: String
  lendingPool_not_in: [String!]
  lendingPool_not_starts_with: String
  lendingPool_not_starts_with_nocase: String
  lendingPool_starts_with: String
  lendingPool_starts_with_nocase: String
  loanTokenAmount: BigDecimal
  loanTokenAmount_gt: BigDecimal
  loanTokenAmount_gte: BigDecimal
  loanTokenAmount_in: [BigDecimal!]
  loanTokenAmount_lt: BigDecimal
  loanTokenAmount_lte: BigDecimal
  loanTokenAmount_not: BigDecimal
  loanTokenAmount_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  type: LendingHistoryType
  type_in: [LendingHistoryType!]
  type_not: LendingHistoryType
  type_not_in: [LendingHistoryType!]
  userLendingHistory: String
  userLendingHistory_: UserLendingHistory_filter
  userLendingHistory_contains: String
  userLendingHistory_contains_nocase: String
  userLendingHistory_ends_with: String
  userLendingHistory_ends_with_nocase: String
  userLendingHistory_gt: String
  userLendingHistory_gte: String
  userLendingHistory_in: [String!]
  userLendingHistory_lt: String
  userLendingHistory_lte: String
  userLendingHistory_not: String
  userLendingHistory_not_contains: String
  userLendingHistory_not_contains_nocase: String
  userLendingHistory_not_ends_with: String
  userLendingHistory_not_ends_with_nocase: String
  userLendingHistory_not_in: [String!]
  userLendingHistory_not_starts_with: String
  userLendingHistory_not_starts_with_nocase: String
  userLendingHistory_starts_with: String
  userLendingHistory_starts_with_nocase: String
}

enum LendingHistoryItem_orderBy {
  amount
  asset
  emittedBy
  id
  lender
  lendingPool
  loanTokenAmount
  timestamp
  transaction
  type
  userLendingHistory
}

enum LendingHistoryType {
  """
  Lend is equivalent to a Mint event
  """
  Lend

  """
  UnLend is equivalent to a Burn event
  """
  UnLend
}

"""
A Lending Pool (iToken), where Users can lend assets to earn interest, and Users can borrow assets to Margin Trade or just as a regular loan.
"""
type LendingPool {
  """
  Balance of the underlying asset (ERC20 token) represented by the total supply of pool tokens
  It is incremented on Mint events and decremented on Burn events.
  WORK-IN-PROGRESS: This is a work-in-progress as it does not properly account for interest payments currently
  """
  assetBalance: BigDecimal!

  """
  ID is the contract address of the iToken
  """
  id: ID!

  """
  The total supply of this pool token (not the underlying asset).
  It is incremented on Mint events and decremented on Burn events
  """
  poolTokenBalance: BigDecimal!

  """
  Total asset volume lent over all time
  """
  totalAssetLent: BigDecimal!

  """
  The actual asset being lent and borrowed in this pool
  """
  underlyingAsset: Token!
}

input LendingPool_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  assetBalance: BigDecimal
  assetBalance_gt: BigDecimal
  assetBalance_gte: BigDecimal
  assetBalance_in: [BigDecimal!]
  assetBalance_lt: BigDecimal
  assetBalance_lte: BigDecimal
  assetBalance_not: BigDecimal
  assetBalance_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolTokenBalance: BigDecimal
  poolTokenBalance_gt: BigDecimal
  poolTokenBalance_gte: BigDecimal
  poolTokenBalance_in: [BigDecimal!]
  poolTokenBalance_lt: BigDecimal
  poolTokenBalance_lte: BigDecimal
  poolTokenBalance_not: BigDecimal
  poolTokenBalance_not_in: [BigDecimal!]
  totalAssetLent: BigDecimal
  totalAssetLent_gt: BigDecimal
  totalAssetLent_gte: BigDecimal
  totalAssetLent_in: [BigDecimal!]
  totalAssetLent_lt: BigDecimal
  totalAssetLent_lte: BigDecimal
  totalAssetLent_not: BigDecimal
  totalAssetLent_not_in: [BigDecimal!]
  underlyingAsset: String
  underlyingAsset_: Token_filter
  underlyingAsset_contains: String
  underlyingAsset_contains_nocase: String
  underlyingAsset_ends_with: String
  underlyingAsset_ends_with_nocase: String
  underlyingAsset_gt: String
  underlyingAsset_gte: String
  underlyingAsset_in: [String!]
  underlyingAsset_lt: String
  underlyingAsset_lte: String
  underlyingAsset_not: String
  underlyingAsset_not_contains: String
  underlyingAsset_not_contains_nocase: String
  underlyingAsset_not_ends_with: String
  underlyingAsset_not_ends_with_nocase: String
  underlyingAsset_not_in: [String!]
  underlyingAsset_not_starts_with: String
  underlyingAsset_not_starts_with_nocase: String
  underlyingAsset_starts_with: String
  underlyingAsset_starts_with_nocase: String
}

enum LendingPool_orderBy {
  assetBalance
  id
  poolTokenBalance
  totalAssetLent
  underlyingAsset
}

"""
Granular event data for the Loan entity. Emitted when a loan is fully or partially liquidated
"""
type Liquidate {
  collateralToLoanRate: BigDecimal!
  collateralToken: Bytes!
  collateralWithdrawAmount: BigDecimal!
  currentMargin: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  lender: Bytes!
  liquidator: Bytes!
  loanId: Loan!
  loanToken: Bytes!
  repayAmount: BigDecimal!
  timestamp: Int!
  transaction: Transaction!
  user: User!
}

input Liquidate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  collateralToLoanRate: BigDecimal
  collateralToLoanRate_gt: BigDecimal
  collateralToLoanRate_gte: BigDecimal
  collateralToLoanRate_in: [BigDecimal!]
  collateralToLoanRate_lt: BigDecimal
  collateralToLoanRate_lte: BigDecimal
  collateralToLoanRate_not: BigDecimal
  collateralToLoanRate_not_in: [BigDecimal!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  collateralWithdrawAmount: BigDecimal
  collateralWithdrawAmount_gt: BigDecimal
  collateralWithdrawAmount_gte: BigDecimal
  collateralWithdrawAmount_in: [BigDecimal!]
  collateralWithdrawAmount_lt: BigDecimal
  collateralWithdrawAmount_lte: BigDecimal
  collateralWithdrawAmount_not: BigDecimal
  collateralWithdrawAmount_not_in: [BigDecimal!]
  currentMargin: BigDecimal
  currentMargin_gt: BigDecimal
  currentMargin_gte: BigDecimal
  currentMargin_in: [BigDecimal!]
  currentMargin_lt: BigDecimal
  currentMargin_lte: BigDecimal
  currentMargin_not: BigDecimal
  currentMargin_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  liquidator: Bytes
  liquidator_contains: Bytes
  liquidator_in: [Bytes!]
  liquidator_not: Bytes
  liquidator_not_contains: Bytes
  liquidator_not_in: [Bytes!]
  loanId: String
  loanId_: Loan_filter
  loanId_contains: String
  loanId_contains_nocase: String
  loanId_ends_with: String
  loanId_ends_with_nocase: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_contains_nocase: String
  loanId_not_ends_with: String
  loanId_not_ends_with_nocase: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_not_starts_with_nocase: String
  loanId_starts_with: String
  loanId_starts_with_nocase: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  repayAmount: BigDecimal
  repayAmount_gt: BigDecimal
  repayAmount_gte: BigDecimal
  repayAmount_in: [BigDecimal!]
  repayAmount_lt: BigDecimal
  repayAmount_lte: BigDecimal
  repayAmount_not: BigDecimal
  repayAmount_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum Liquidate_orderBy {
  collateralToLoanRate
  collateralToken
  collateralWithdrawAmount
  currentMargin
  emittedBy
  id
  lender
  liquidator
  loanId
  loanToken
  repayAmount
  timestamp
  transaction
  user
}

type LiquidityHistoryItem {
  """
  The amount that was added/removed
  """
  amount: BigDecimal!

  """
  The contract that emitted this event (primarily used for debugging)
  """
  emittedBy: String!

  """
  ID is transaction hash + log index
  """
  id: ID!

  """
  AMM pool that liquidity was provided to
  """
  liquidityPool: LiquidityPool!

  """
  New balance of the reserveToken (ERC20 token) on the AMM pool
  """
  newBalance: BigDecimal!

  """
  New total supply of pool tokens
  """
  newSupply: BigDecimal!

  """
  Provider is either the user, or a contract if the user interacted with a proxy contract
  """
  provider: String!

  """
  The underlying asset (ERC20 token) that was added/removed
  """
  reserveToken: Token!
  timestamp: Int!
  transaction: Transaction!

  """
  Type is either Added or Removed (if a user added or removed liquidity from the pool)
  """
  type: LiquidityHistoryType!
  user: User!

  """
  Foreign key to join this transaction to the parent UserLiquidityHistory entity
  """
  userLiquidityHistory: UserLiquidityHistory!
}

input LiquidityHistoryItem_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: String
  emittedBy_contains: String
  emittedBy_contains_nocase: String
  emittedBy_ends_with: String
  emittedBy_ends_with_nocase: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_contains_nocase: String
  emittedBy_not_ends_with: String
  emittedBy_not_ends_with_nocase: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_not_starts_with_nocase: String
  emittedBy_starts_with: String
  emittedBy_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPool: String
  liquidityPool_: LiquidityPool_filter
  liquidityPool_contains: String
  liquidityPool_contains_nocase: String
  liquidityPool_ends_with: String
  liquidityPool_ends_with_nocase: String
  liquidityPool_gt: String
  liquidityPool_gte: String
  liquidityPool_in: [String!]
  liquidityPool_lt: String
  liquidityPool_lte: String
  liquidityPool_not: String
  liquidityPool_not_contains: String
  liquidityPool_not_contains_nocase: String
  liquidityPool_not_ends_with: String
  liquidityPool_not_ends_with_nocase: String
  liquidityPool_not_in: [String!]
  liquidityPool_not_starts_with: String
  liquidityPool_not_starts_with_nocase: String
  liquidityPool_starts_with: String
  liquidityPool_starts_with_nocase: String
  newBalance: BigDecimal
  newBalance_gt: BigDecimal
  newBalance_gte: BigDecimal
  newBalance_in: [BigDecimal!]
  newBalance_lt: BigDecimal
  newBalance_lte: BigDecimal
  newBalance_not: BigDecimal
  newBalance_not_in: [BigDecimal!]
  newSupply: BigDecimal
  newSupply_gt: BigDecimal
  newSupply_gte: BigDecimal
  newSupply_in: [BigDecimal!]
  newSupply_lt: BigDecimal
  newSupply_lte: BigDecimal
  newSupply_not: BigDecimal
  newSupply_not_in: [BigDecimal!]
  provider: String
  provider_contains: String
  provider_contains_nocase: String
  provider_ends_with: String
  provider_ends_with_nocase: String
  provider_gt: String
  provider_gte: String
  provider_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_not: String
  provider_not_contains: String
  provider_not_contains_nocase: String
  provider_not_ends_with: String
  provider_not_ends_with_nocase: String
  provider_not_in: [String!]
  provider_not_starts_with: String
  provider_not_starts_with_nocase: String
  provider_starts_with: String
  provider_starts_with_nocase: String
  reserveToken: String
  reserveToken_: Token_filter
  reserveToken_contains: String
  reserveToken_contains_nocase: String
  reserveToken_ends_with: String
  reserveToken_ends_with_nocase: String
  reserveToken_gt: String
  reserveToken_gte: String
  reserveToken_in: [String!]
  reserveToken_lt: String
  reserveToken_lte: String
  reserveToken_not: String
  reserveToken_not_contains: String
  reserveToken_not_contains_nocase: String
  reserveToken_not_ends_with: String
  reserveToken_not_ends_with_nocase: String
  reserveToken_not_in: [String!]
  reserveToken_not_starts_with: String
  reserveToken_not_starts_with_nocase: String
  reserveToken_starts_with: String
  reserveToken_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  type: LiquidityHistoryType
  type_in: [LiquidityHistoryType!]
  type_not: LiquidityHistoryType
  type_not_in: [LiquidityHistoryType!]
  user: String
  userLiquidityHistory: String
  userLiquidityHistory_: UserLiquidityHistory_filter
  userLiquidityHistory_contains: String
  userLiquidityHistory_contains_nocase: String
  userLiquidityHistory_ends_with: String
  userLiquidityHistory_ends_with_nocase: String
  userLiquidityHistory_gt: String
  userLiquidityHistory_gte: String
  userLiquidityHistory_in: [String!]
  userLiquidityHistory_lt: String
  userLiquidityHistory_lte: String
  userLiquidityHistory_not: String
  userLiquidityHistory_not_contains: String
  userLiquidityHistory_not_contains_nocase: String
  userLiquidityHistory_not_ends_with: String
  userLiquidityHistory_not_ends_with_nocase: String
  userLiquidityHistory_not_in: [String!]
  userLiquidityHistory_not_starts_with: String
  userLiquidityHistory_not_starts_with_nocase: String
  userLiquidityHistory_starts_with: String
  userLiquidityHistory_starts_with_nocase: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum LiquidityHistoryItem_orderBy {
  amount
  emittedBy
  id
  liquidityPool
  newBalance
  newSupply
  provider
  reserveToken
  timestamp
  transaction
  type
  user
  userLiquidityHistory
}

enum LiquidityHistoryType {
  Added
  Removed
}

type LiquidityMiningAllocationPoint {
  allocationPoint: BigInt!

  """
  If this pool token is for an AMM liquidity pool, this is a foreign key to the SmartToken.
  If not, this property is null
  """
  ammPoolToken: SmartToken
  id: ID!

  """
  If this pool token is for a lending pool, this is a foreign key to the LendingPool.
  If not, this property is null
  """
  lendingPoolToken: LendingPool
  poolTokenAddedBlock: Int!

  """
  Unix timestamp for when this pool token was added to the liquidity mining program
  """
  poolTokenAddedTimestamp: Int!
  poolTokenUpdatedBlock: Int!

  """
  Unix timestamp for when the allocation point for this pool token last changed
  """
  poolTokenUpdatedTimestamp: Int!

  """
  The amount of SOV earned per block by all LPs in one pool
  Calculated as (totalRewardPerBlock * allocationPoint) / totalAllocationPoint
  """
  rewardPerBlock: BigDecimal!
}

input LiquidityMiningAllocationPoint_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  allocationPoint: BigInt
  allocationPoint_gt: BigInt
  allocationPoint_gte: BigInt
  allocationPoint_in: [BigInt!]
  allocationPoint_lt: BigInt
  allocationPoint_lte: BigInt
  allocationPoint_not: BigInt
  allocationPoint_not_in: [BigInt!]
  ammPoolToken: String
  ammPoolToken_: SmartToken_filter
  ammPoolToken_contains: String
  ammPoolToken_contains_nocase: String
  ammPoolToken_ends_with: String
  ammPoolToken_ends_with_nocase: String
  ammPoolToken_gt: String
  ammPoolToken_gte: String
  ammPoolToken_in: [String!]
  ammPoolToken_lt: String
  ammPoolToken_lte: String
  ammPoolToken_not: String
  ammPoolToken_not_contains: String
  ammPoolToken_not_contains_nocase: String
  ammPoolToken_not_ends_with: String
  ammPoolToken_not_ends_with_nocase: String
  ammPoolToken_not_in: [String!]
  ammPoolToken_not_starts_with: String
  ammPoolToken_not_starts_with_nocase: String
  ammPoolToken_starts_with: String
  ammPoolToken_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lendingPoolToken: String
  lendingPoolToken_: LendingPool_filter
  lendingPoolToken_contains: String
  lendingPoolToken_contains_nocase: String
  lendingPoolToken_ends_with: String
  lendingPoolToken_ends_with_nocase: String
  lendingPoolToken_gt: String
  lendingPoolToken_gte: String
  lendingPoolToken_in: [String!]
  lendingPoolToken_lt: String
  lendingPoolToken_lte: String
  lendingPoolToken_not: String
  lendingPoolToken_not_contains: String
  lendingPoolToken_not_contains_nocase: String
  lendingPoolToken_not_ends_with: String
  lendingPoolToken_not_ends_with_nocase: String
  lendingPoolToken_not_in: [String!]
  lendingPoolToken_not_starts_with: String
  lendingPoolToken_not_starts_with_nocase: String
  lendingPoolToken_starts_with: String
  lendingPoolToken_starts_with_nocase: String
  poolTokenAddedBlock: Int
  poolTokenAddedBlock_gt: Int
  poolTokenAddedBlock_gte: Int
  poolTokenAddedBlock_in: [Int!]
  poolTokenAddedBlock_lt: Int
  poolTokenAddedBlock_lte: Int
  poolTokenAddedBlock_not: Int
  poolTokenAddedBlock_not_in: [Int!]
  poolTokenAddedTimestamp: Int
  poolTokenAddedTimestamp_gt: Int
  poolTokenAddedTimestamp_gte: Int
  poolTokenAddedTimestamp_in: [Int!]
  poolTokenAddedTimestamp_lt: Int
  poolTokenAddedTimestamp_lte: Int
  poolTokenAddedTimestamp_not: Int
  poolTokenAddedTimestamp_not_in: [Int!]
  poolTokenUpdatedBlock: Int
  poolTokenUpdatedBlock_gt: Int
  poolTokenUpdatedBlock_gte: Int
  poolTokenUpdatedBlock_in: [Int!]
  poolTokenUpdatedBlock_lt: Int
  poolTokenUpdatedBlock_lte: Int
  poolTokenUpdatedBlock_not: Int
  poolTokenUpdatedBlock_not_in: [Int!]
  poolTokenUpdatedTimestamp: Int
  poolTokenUpdatedTimestamp_gt: Int
  poolTokenUpdatedTimestamp_gte: Int
  poolTokenUpdatedTimestamp_in: [Int!]
  poolTokenUpdatedTimestamp_lt: Int
  poolTokenUpdatedTimestamp_lte: Int
  poolTokenUpdatedTimestamp_not: Int
  poolTokenUpdatedTimestamp_not_in: [Int!]
  rewardPerBlock: BigDecimal
  rewardPerBlock_gt: BigDecimal
  rewardPerBlock_gte: BigDecimal
  rewardPerBlock_in: [BigDecimal!]
  rewardPerBlock_lt: BigDecimal
  rewardPerBlock_lte: BigDecimal
  rewardPerBlock_not: BigDecimal
  rewardPerBlock_not_in: [BigDecimal!]
}

enum LiquidityMiningAllocationPoint_orderBy {
  allocationPoint
  ammPoolToken
  id
  lendingPoolToken
  poolTokenAddedBlock
  poolTokenAddedTimestamp
  poolTokenUpdatedBlock
  poolTokenUpdatedTimestamp
  rewardPerBlock
}

"""
This entity has only one instance (id: 0), and holds global variables required for liquidity mining rewards calculations
"""
type LiquidityMiningGlobal {
  id: ID!

  """
  Total available allocation points. This is used to calculated the reward per block for each pool token.
  See the LiquidityMiningAllocationPoint entity for more details.
  """
  totalAllocationPoint: BigInt!

  """
  Total possible SOV per block in the liquidity mining program. Not all of this has to be allocation (eg if totalRewardPerBlock = 1000, that does not mean 1000 SOV are being given to LPs per block)
  This is used to calculated the reward per block for each pool token.
  See the LiquidityMiningAllocationPoint entity for more details.
  """
  totalRewardPerBlock: BigInt!
}

input LiquidityMiningGlobal_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  totalAllocationPoint: BigInt
  totalAllocationPoint_gt: BigInt
  totalAllocationPoint_gte: BigInt
  totalAllocationPoint_in: [BigInt!]
  totalAllocationPoint_lt: BigInt
  totalAllocationPoint_lte: BigInt
  totalAllocationPoint_not: BigInt
  totalAllocationPoint_not_in: [BigInt!]
  totalRewardPerBlock: BigInt
  totalRewardPerBlock_gt: BigInt
  totalRewardPerBlock_gte: BigInt
  totalRewardPerBlock_in: [BigInt!]
  totalRewardPerBlock_lt: BigInt
  totalRewardPerBlock_lte: BigInt
  totalRewardPerBlock_not: BigInt
  totalRewardPerBlock_not_in: [BigInt!]
}

enum LiquidityMiningGlobal_orderBy {
  id
  totalAllocationPoint
  totalRewardPerBlock
}

"""
AMM Pool (sometimes referred to as a Converter)
"""
type LiquidityPool {
  """
  Activated with be true when this pool is activated, and will change to false is the pool is deactivated
  """
  activated: Boolean
  connectorTokens(
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]!

  """
  Divide by maxConversionFee to get percentage
  """
  conversionFee: BigInt
  createdAtBlockNumber: Int
  createdAtTimestamp: Int
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry

  """
  ID is the contract address of the Converter
  """
  id: ID!
  maxConversionFee: BigInt
  owner: String
  poolTokens(
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolToken_filter
  ): [PoolToken!]
  smartToken: SmartToken

  """
  The reserve assets of this AMM Pool. The are stored here like this so that they can be accessed inside mappings when the LiquidityPool is loaded.
  """
  token0: Token

  """
  The balance for each token on this liquidity pool
  NB: For the V2 pools (USDT, DOC, BPRO), this balance is the staked balance, not the contract balance
  """
  token0Balance: BigDecimal!
  token1: Token
  token1Balance: BigDecimal!

  """
  Sovryn uses Bancor V1 and Bancor V2 pools
  """
  type: Int
  version: Int
}

"""
This entity stores the relationship between liquidity pools and underlying tokens
It also currently stores the total volumes bought and sold, but this should be moved to the LiquidityPool
"""
type LiquidityPoolToken {
  """
  ID is liquidityPool address + tokenAddress
  """
  id: ID!
  liquidityPool: LiquidityPool!

  """
  The pool token that represents this token-liquidityPool relationship
  """
  poolToken: PoolToken!
  token: Token!

  """
  Total volume of this token that has been bought or sold through this liquidity pool
  """
  totalVolume: BigDecimal!

  """
  Total volume of this token bought through this liquidity pool
  """
  volumeBought: BigDecimal!

  """
  Total volume of this token sold through this liquidity pool
  """
  volumeSold: BigDecimal!
}

input LiquidityPoolToken_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPool: String
  liquidityPool_: LiquidityPool_filter
  liquidityPool_contains: String
  liquidityPool_contains_nocase: String
  liquidityPool_ends_with: String
  liquidityPool_ends_with_nocase: String
  liquidityPool_gt: String
  liquidityPool_gte: String
  liquidityPool_in: [String!]
  liquidityPool_lt: String
  liquidityPool_lte: String
  liquidityPool_not: String
  liquidityPool_not_contains: String
  liquidityPool_not_contains_nocase: String
  liquidityPool_not_ends_with: String
  liquidityPool_not_ends_with_nocase: String
  liquidityPool_not_in: [String!]
  liquidityPool_not_starts_with: String
  liquidityPool_not_starts_with_nocase: String
  liquidityPool_starts_with: String
  liquidityPool_starts_with_nocase: String
  poolToken: String
  poolToken_: PoolToken_filter
  poolToken_contains: String
  poolToken_contains_nocase: String
  poolToken_ends_with: String
  poolToken_ends_with_nocase: String
  poolToken_gt: String
  poolToken_gte: String
  poolToken_in: [String!]
  poolToken_lt: String
  poolToken_lte: String
  poolToken_not: String
  poolToken_not_contains: String
  poolToken_not_contains_nocase: String
  poolToken_not_ends_with: String
  poolToken_not_ends_with_nocase: String
  poolToken_not_in: [String!]
  poolToken_not_starts_with: String
  poolToken_not_starts_with_nocase: String
  poolToken_starts_with: String
  poolToken_starts_with_nocase: String
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  totalVolume: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_lt: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_not_in: [BigDecimal!]
  volumeBought: BigDecimal
  volumeBought_gt: BigDecimal
  volumeBought_gte: BigDecimal
  volumeBought_in: [BigDecimal!]
  volumeBought_lt: BigDecimal
  volumeBought_lte: BigDecimal
  volumeBought_not: BigDecimal
  volumeBought_not_in: [BigDecimal!]
  volumeSold: BigDecimal
  volumeSold_gt: BigDecimal
  volumeSold_gte: BigDecimal
  volumeSold_in: [BigDecimal!]
  volumeSold_lt: BigDecimal
  volumeSold_lte: BigDecimal
  volumeSold_not: BigDecimal
  volumeSold_not_in: [BigDecimal!]
}

enum LiquidityPoolToken_orderBy {
  id
  liquidityPool
  poolToken
  token
  totalVolume
  volumeBought
  volumeSold
}

input LiquidityPool_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  activated: Boolean
  activated_in: [Boolean!]
  activated_not: Boolean
  activated_not_in: [Boolean!]
  connectorTokens_: LiquidityPoolToken_filter
  conversionFee: BigInt
  conversionFee_gt: BigInt
  conversionFee_gte: BigInt
  conversionFee_in: [BigInt!]
  conversionFee_lt: BigInt
  conversionFee_lte: BigInt
  conversionFee_not: BigInt
  conversionFee_not_in: [BigInt!]
  createdAtBlockNumber: Int
  createdAtBlockNumber_gt: Int
  createdAtBlockNumber_gte: Int
  createdAtBlockNumber_in: [Int!]
  createdAtBlockNumber_lt: Int
  createdAtBlockNumber_lte: Int
  createdAtBlockNumber_not: Int
  createdAtBlockNumber_not_in: [Int!]
  createdAtTimestamp: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_lt: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_not_in: [Int!]
  createdAtTransaction: String
  createdAtTransaction_: Transaction_filter
  createdAtTransaction_contains: String
  createdAtTransaction_contains_nocase: String
  createdAtTransaction_ends_with: String
  createdAtTransaction_ends_with_nocase: String
  createdAtTransaction_gt: String
  createdAtTransaction_gte: String
  createdAtTransaction_in: [String!]
  createdAtTransaction_lt: String
  createdAtTransaction_lte: String
  createdAtTransaction_not: String
  createdAtTransaction_not_contains: String
  createdAtTransaction_not_contains_nocase: String
  createdAtTransaction_not_ends_with: String
  createdAtTransaction_not_ends_with_nocase: String
  createdAtTransaction_not_in: [String!]
  createdAtTransaction_not_starts_with: String
  createdAtTransaction_not_starts_with_nocase: String
  createdAtTransaction_starts_with: String
  createdAtTransaction_starts_with_nocase: String
  currentConverterRegistry: String
  currentConverterRegistry_: ConverterRegistry_filter
  currentConverterRegistry_contains: String
  currentConverterRegistry_contains_nocase: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_ends_with_nocase: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_lt: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_not: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_not_contains_nocase: String
  currentConverterRegistry_not_ends_with: String
  currentConverterRegistry_not_ends_with_nocase: String
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_not_starts_with_nocase: String
  currentConverterRegistry_starts_with: String
  currentConverterRegistry_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  maxConversionFee: BigInt
  maxConversionFee_gt: BigInt
  maxConversionFee_gte: BigInt
  maxConversionFee_in: [BigInt!]
  maxConversionFee_lt: BigInt
  maxConversionFee_lte: BigInt
  maxConversionFee_not: BigInt
  maxConversionFee_not_in: [BigInt!]
  owner: String
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  poolTokens_: PoolToken_filter
  smartToken: String
  smartToken_: SmartToken_filter
  smartToken_contains: String
  smartToken_contains_nocase: String
  smartToken_ends_with: String
  smartToken_ends_with_nocase: String
  smartToken_gt: String
  smartToken_gte: String
  smartToken_in: [String!]
  smartToken_lt: String
  smartToken_lte: String
  smartToken_not: String
  smartToken_not_contains: String
  smartToken_not_contains_nocase: String
  smartToken_not_ends_with: String
  smartToken_not_ends_with_nocase: String
  smartToken_not_in: [String!]
  smartToken_not_starts_with: String
  smartToken_not_starts_with_nocase: String
  smartToken_starts_with: String
  smartToken_starts_with_nocase: String
  token0: String
  token0Balance: BigDecimal
  token0Balance_gt: BigDecimal
  token0Balance_gte: BigDecimal
  token0Balance_in: [BigDecimal!]
  token0Balance_lt: BigDecimal
  token0Balance_lte: BigDecimal
  token0Balance_not: BigDecimal
  token0Balance_not_in: [BigDecimal!]
  token0_: Token_filter
  token0_contains: String
  token0_contains_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token1: String
  token1Balance: BigDecimal
  token1Balance_gt: BigDecimal
  token1Balance_gte: BigDecimal
  token1Balance_in: [BigDecimal!]
  token1Balance_lt: BigDecimal
  token1Balance_lte: BigDecimal
  token1Balance_not: BigDecimal
  token1Balance_not_in: [BigDecimal!]
  token1_: Token_filter
  token1_contains: String
  token1_contains_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  type: Int
  type_gt: Int
  type_gte: Int
  type_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_not: Int
  type_not_in: [Int!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum LiquidityPool_orderBy {
  activated
  connectorTokens
  conversionFee
  createdAtBlockNumber
  createdAtTimestamp
  createdAtTransaction
  currentConverterRegistry
  id
  maxConversionFee
  owner
  poolTokens
  smartToken
  token0
  token0Balance
  token1
  token1Balance
  type
  version
}

"""
A Loan can be initialized by either a Margin Trade event or a Borrow event
"""
type Loan {
  """
  Average price per token from all loan open events
  Updated on Trade and Borrow events
  This is mainly used as internal storage to calculate PnL
  """
  averageBuyPrice: BigDecimal!

  """
  Average price per token from all loan close events
  Updated on CloseWithSwap, CloseWithDeposit and Liquidate events
  This is mainly used as internal storage to calculate PnL
  """
  averageSellPrice: BigDecimal!

  """
  Borrow transactions associated with this loan
  """
  borrow(
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Borrow_filter
  ): [Borrow!]

  """
  The amount borrowed in loan tokens
  """
  borrowedAmount: BigDecimal!

  """
  CloseWithDeposit events associated with this loan. Emitted when a user partially or fully closes a borrow loan.
  """
  closeWithDeposits(
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: CloseWithDeposit_filter
  ): [CloseWithDeposit!]

  """
  CloseWithSwap events associated with this loan. Emitted when a user partially or fully closes a margin trade.
  """
  closeWithSwaps(
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: CloseWithSwap_filter
  ): [CloseWithSwap!]

  """
  The token provided as collateral
  """
  collateralToken: Token!

  """
  DepositCollateral events associated with this loan, where a user has topped up collateral
  """
  depositCollateral(
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: DepositCollateral_filter
  ): [DepositCollateral!]

  """
  Unix timestamp at end of loan (null if loan is still open)
  """
  endTimestamp: Int
  id: ID!

  """
  If a Liquidate, CloseWithSwap, Rollover or CloseWithDeposit event occurs with 0 margin or 0 leverage, this property changes to false
  """
  isOpen: Boolean!

  """
  Any liquidations that have happened on this loan
  """
  liquidates(
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Liquidate_filter
  ): [Liquidate!]

  """
  The token the loan was taken out in
  """
  loanToken: Token!

  """
  The largest amount borrowed in the lifetime of this loan
  """
  maxBorrowedAmount: BigDecimal!

  """
  The maximum this position size was - mainly for debugging purposes
  """
  maximumPositionSize: BigDecimal!

  """
  Next date that the loan will be rolled over, interest and trading fee paid, and rollover reward paid
  It is possible for the next rollover to be in the past if the loan has not yet been rolled over by the Sovryn node
  """
  nextRollover: Int

  """
  Total of collateral (user collateral in a Borrow, and user collateral + borrowed amount in a Trade) in collateral tokens
  """
  positionSize: BigDecimal!

  """
  Realized profit and loss. This is updated on every loan closing event - partially or fully closing a loan, or a liquidation.
  Currently, this does not take into account fees paid
  The realized PnL is quoted in the collateral currency
  """
  realizedPnL: BigDecimal!

  """
  Percentage profit or loss relative to collateral
  """
  realizedPnLPercent: BigDecimal!

  """
  Rollover events associated with this loan.
  Rollovers are loan maintenance transactions where the next interest payment and fee is paid
  """
  rollovers(
    first: Int = 100
    orderBy: Rollover_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Rollover_filter
  ): [Rollover!]

  """
  The amount borrowed when the loan was opened
  """
  startBorrowedAmount: BigDecimal!

  """
  Initial size of the position
  """
  startPositionSize: BigDecimal!

  """
  The start rate of the loan in loan tokens (eg if it is a long USD/BTC margin trade, this is the BTC price in USD)
  """
  startRate: BigDecimal!

  """
  Unix timestamp at start of loan
  """
  startTimestamp: Int!

  """
  Sum of position volume from Trade, Borrow and DepositCollateral events in this loan, in collateral token
  """
  totalBought: BigDecimal!

  """
  Sum of position change volume from CloseWithSwap, CloseWithDeposit and Liquidate events in this loan, in collateral token
  """
  totalSold: BigDecimal!

  """
  Trade (margin trade) transactions associated with this loan
  """
  trade(
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Trade_filter
  ): [Trade!]

  """
  LoanType is either Trade (for Margin Trades) or Borrow (for Borrows)
  """
  type: LoanType!

  """
  The user who took out the loan
  """
  user: User!
}

enum LoanType {
  """
  Borrow is a loan originating from a user simply borrowing funds
  """
  Borrow

  """
  Trade is a loan originating from a margin trade
  """
  Trade
}

input Loan_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  averageBuyPrice: BigDecimal
  averageBuyPrice_gt: BigDecimal
  averageBuyPrice_gte: BigDecimal
  averageBuyPrice_in: [BigDecimal!]
  averageBuyPrice_lt: BigDecimal
  averageBuyPrice_lte: BigDecimal
  averageBuyPrice_not: BigDecimal
  averageBuyPrice_not_in: [BigDecimal!]
  averageSellPrice: BigDecimal
  averageSellPrice_gt: BigDecimal
  averageSellPrice_gte: BigDecimal
  averageSellPrice_in: [BigDecimal!]
  averageSellPrice_lt: BigDecimal
  averageSellPrice_lte: BigDecimal
  averageSellPrice_not: BigDecimal
  averageSellPrice_not_in: [BigDecimal!]
  borrow_: Borrow_filter
  borrowedAmount: BigDecimal
  borrowedAmount_gt: BigDecimal
  borrowedAmount_gte: BigDecimal
  borrowedAmount_in: [BigDecimal!]
  borrowedAmount_lt: BigDecimal
  borrowedAmount_lte: BigDecimal
  borrowedAmount_not: BigDecimal
  borrowedAmount_not_in: [BigDecimal!]
  closeWithDeposits_: CloseWithDeposit_filter
  closeWithSwaps_: CloseWithSwap_filter
  collateralToken: String
  collateralToken_: Token_filter
  collateralToken_contains: String
  collateralToken_contains_nocase: String
  collateralToken_ends_with: String
  collateralToken_ends_with_nocase: String
  collateralToken_gt: String
  collateralToken_gte: String
  collateralToken_in: [String!]
  collateralToken_lt: String
  collateralToken_lte: String
  collateralToken_not: String
  collateralToken_not_contains: String
  collateralToken_not_contains_nocase: String
  collateralToken_not_ends_with: String
  collateralToken_not_ends_with_nocase: String
  collateralToken_not_in: [String!]
  collateralToken_not_starts_with: String
  collateralToken_not_starts_with_nocase: String
  collateralToken_starts_with: String
  collateralToken_starts_with_nocase: String
  depositCollateral_: DepositCollateral_filter
  endTimestamp: Int
  endTimestamp_gt: Int
  endTimestamp_gte: Int
  endTimestamp_in: [Int!]
  endTimestamp_lt: Int
  endTimestamp_lte: Int
  endTimestamp_not: Int
  endTimestamp_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isOpen: Boolean
  isOpen_in: [Boolean!]
  isOpen_not: Boolean
  isOpen_not_in: [Boolean!]
  liquidates_: Liquidate_filter
  loanToken: String
  loanToken_: Token_filter
  loanToken_contains: String
  loanToken_contains_nocase: String
  loanToken_ends_with: String
  loanToken_ends_with_nocase: String
  loanToken_gt: String
  loanToken_gte: String
  loanToken_in: [String!]
  loanToken_lt: String
  loanToken_lte: String
  loanToken_not: String
  loanToken_not_contains: String
  loanToken_not_contains_nocase: String
  loanToken_not_ends_with: String
  loanToken_not_ends_with_nocase: String
  loanToken_not_in: [String!]
  loanToken_not_starts_with: String
  loanToken_not_starts_with_nocase: String
  loanToken_starts_with: String
  loanToken_starts_with_nocase: String
  maxBorrowedAmount: BigDecimal
  maxBorrowedAmount_gt: BigDecimal
  maxBorrowedAmount_gte: BigDecimal
  maxBorrowedAmount_in: [BigDecimal!]
  maxBorrowedAmount_lt: BigDecimal
  maxBorrowedAmount_lte: BigDecimal
  maxBorrowedAmount_not: BigDecimal
  maxBorrowedAmount_not_in: [BigDecimal!]
  maximumPositionSize: BigDecimal
  maximumPositionSize_gt: BigDecimal
  maximumPositionSize_gte: BigDecimal
  maximumPositionSize_in: [BigDecimal!]
  maximumPositionSize_lt: BigDecimal
  maximumPositionSize_lte: BigDecimal
  maximumPositionSize_not: BigDecimal
  maximumPositionSize_not_in: [BigDecimal!]
  nextRollover: Int
  nextRollover_gt: Int
  nextRollover_gte: Int
  nextRollover_in: [Int!]
  nextRollover_lt: Int
  nextRollover_lte: Int
  nextRollover_not: Int
  nextRollover_not_in: [Int!]
  positionSize: BigDecimal
  positionSize_gt: BigDecimal
  positionSize_gte: BigDecimal
  positionSize_in: [BigDecimal!]
  positionSize_lt: BigDecimal
  positionSize_lte: BigDecimal
  positionSize_not: BigDecimal
  positionSize_not_in: [BigDecimal!]
  realizedPnL: BigDecimal
  realizedPnLPercent: BigDecimal
  realizedPnLPercent_gt: BigDecimal
  realizedPnLPercent_gte: BigDecimal
  realizedPnLPercent_in: [BigDecimal!]
  realizedPnLPercent_lt: BigDecimal
  realizedPnLPercent_lte: BigDecimal
  realizedPnLPercent_not: BigDecimal
  realizedPnLPercent_not_in: [BigDecimal!]
  realizedPnL_gt: BigDecimal
  realizedPnL_gte: BigDecimal
  realizedPnL_in: [BigDecimal!]
  realizedPnL_lt: BigDecimal
  realizedPnL_lte: BigDecimal
  realizedPnL_not: BigDecimal
  realizedPnL_not_in: [BigDecimal!]
  rollovers_: Rollover_filter
  startBorrowedAmount: BigDecimal
  startBorrowedAmount_gt: BigDecimal
  startBorrowedAmount_gte: BigDecimal
  startBorrowedAmount_in: [BigDecimal!]
  startBorrowedAmount_lt: BigDecimal
  startBorrowedAmount_lte: BigDecimal
  startBorrowedAmount_not: BigDecimal
  startBorrowedAmount_not_in: [BigDecimal!]
  startPositionSize: BigDecimal
  startPositionSize_gt: BigDecimal
  startPositionSize_gte: BigDecimal
  startPositionSize_in: [BigDecimal!]
  startPositionSize_lt: BigDecimal
  startPositionSize_lte: BigDecimal
  startPositionSize_not: BigDecimal
  startPositionSize_not_in: [BigDecimal!]
  startRate: BigDecimal
  startRate_gt: BigDecimal
  startRate_gte: BigDecimal
  startRate_in: [BigDecimal!]
  startRate_lt: BigDecimal
  startRate_lte: BigDecimal
  startRate_not: BigDecimal
  startRate_not_in: [BigDecimal!]
  startTimestamp: Int
  startTimestamp_gt: Int
  startTimestamp_gte: Int
  startTimestamp_in: [Int!]
  startTimestamp_lt: Int
  startTimestamp_lte: Int
  startTimestamp_not: Int
  startTimestamp_not_in: [Int!]
  totalBought: BigDecimal
  totalBought_gt: BigDecimal
  totalBought_gte: BigDecimal
  totalBought_in: [BigDecimal!]
  totalBought_lt: BigDecimal
  totalBought_lte: BigDecimal
  totalBought_not: BigDecimal
  totalBought_not_in: [BigDecimal!]
  totalSold: BigDecimal
  totalSold_gt: BigDecimal
  totalSold_gte: BigDecimal
  totalSold_in: [BigDecimal!]
  totalSold_lt: BigDecimal
  totalSold_lte: BigDecimal
  totalSold_not: BigDecimal
  totalSold_not_in: [BigDecimal!]
  trade_: Trade_filter
  type: LoanType
  type_in: [LoanType!]
  type_not: LoanType
  type_not_in: [LoanType!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum Loan_orderBy {
  averageBuyPrice
  averageSellPrice
  borrow
  borrowedAmount
  closeWithDeposits
  closeWithSwaps
  collateralToken
  depositCollateral
  endTimestamp
  id
  isOpen
  liquidates
  loanToken
  maxBorrowedAmount
  maximumPositionSize
  nextRollover
  positionSize
  realizedPnL
  realizedPnLPercent
  rollovers
  startBorrowedAmount
  startPositionSize
  startRate
  startTimestamp
  totalBought
  totalSold
  trade
  type
  user
}

type MarginOrderCanceled {
  emittedBy: Bytes!
  hash: Bytes!
  id: ID!
  timestamp: Int!
  trader: Bytes!
  transaction: Transaction!
}

input MarginOrderCanceled_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  trader: Bytes
  trader_contains: Bytes
  trader_in: [Bytes!]
  trader_not: Bytes
  trader_not_contains: Bytes
  trader_not_in: [Bytes!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum MarginOrderCanceled_orderBy {
  emittedBy
  hash
  id
  timestamp
  trader
  transaction
}

type MarginOrderFilled {
  collateral: BigDecimal!
  collateralTokenAddress: Bytes!
  collateralTokenSent: BigDecimal!
  emittedBy: Bytes!
  filledPrice: BigDecimal!
  hash: Bytes!
  id: ID!
  leverageAmount: BigDecimal!
  loanTokenAddress: Bytes!
  loanTokenSent: BigDecimal!
  principal: BigDecimal!
  timestamp: Int!
  trader: User!
  transaction: Transaction!
}

input MarginOrderFilled_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  collateral: BigDecimal
  collateralTokenAddress: Bytes
  collateralTokenAddress_contains: Bytes
  collateralTokenAddress_in: [Bytes!]
  collateralTokenAddress_not: Bytes
  collateralTokenAddress_not_contains: Bytes
  collateralTokenAddress_not_in: [Bytes!]
  collateralTokenSent: BigDecimal
  collateralTokenSent_gt: BigDecimal
  collateralTokenSent_gte: BigDecimal
  collateralTokenSent_in: [BigDecimal!]
  collateralTokenSent_lt: BigDecimal
  collateralTokenSent_lte: BigDecimal
  collateralTokenSent_not: BigDecimal
  collateralTokenSent_not_in: [BigDecimal!]
  collateral_gt: BigDecimal
  collateral_gte: BigDecimal
  collateral_in: [BigDecimal!]
  collateral_lt: BigDecimal
  collateral_lte: BigDecimal
  collateral_not: BigDecimal
  collateral_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  filledPrice: BigDecimal
  filledPrice_gt: BigDecimal
  filledPrice_gte: BigDecimal
  filledPrice_in: [BigDecimal!]
  filledPrice_lt: BigDecimal
  filledPrice_lte: BigDecimal
  filledPrice_not: BigDecimal
  filledPrice_not_in: [BigDecimal!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  leverageAmount: BigDecimal
  leverageAmount_gt: BigDecimal
  leverageAmount_gte: BigDecimal
  leverageAmount_in: [BigDecimal!]
  leverageAmount_lt: BigDecimal
  leverageAmount_lte: BigDecimal
  leverageAmount_not: BigDecimal
  leverageAmount_not_in: [BigDecimal!]
  loanTokenAddress: Bytes
  loanTokenAddress_contains: Bytes
  loanTokenAddress_in: [Bytes!]
  loanTokenAddress_not: Bytes
  loanTokenAddress_not_contains: Bytes
  loanTokenAddress_not_in: [Bytes!]
  loanTokenSent: BigDecimal
  loanTokenSent_gt: BigDecimal
  loanTokenSent_gte: BigDecimal
  loanTokenSent_in: [BigDecimal!]
  loanTokenSent_lt: BigDecimal
  loanTokenSent_lte: BigDecimal
  loanTokenSent_not: BigDecimal
  loanTokenSent_not_in: [BigDecimal!]
  principal: BigDecimal
  principal_gt: BigDecimal
  principal_gte: BigDecimal
  principal_in: [BigDecimal!]
  principal_lt: BigDecimal
  principal_lte: BigDecimal
  principal_not: BigDecimal
  principal_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  trader: String
  trader_: User_filter
  trader_contains: String
  trader_contains_nocase: String
  trader_ends_with: String
  trader_ends_with_nocase: String
  trader_gt: String
  trader_gte: String
  trader_in: [String!]
  trader_lt: String
  trader_lte: String
  trader_not: String
  trader_not_contains: String
  trader_not_contains_nocase: String
  trader_not_ends_with: String
  trader_not_ends_with_nocase: String
  trader_not_in: [String!]
  trader_not_starts_with: String
  trader_not_starts_with_nocase: String
  trader_starts_with: String
  trader_starts_with_nocase: String
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum MarginOrderFilled_orderBy {
  collateral
  collateralTokenAddress
  collateralTokenSent
  emittedBy
  filledPrice
  hash
  id
  leverageAmount
  loanTokenAddress
  loanTokenSent
  principal
  timestamp
  trader
  transaction
}

enum Network {
  Mainnet
  Testnet
}

type NewBitcoinTransferIncoming {
  amountWei: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  btcTxHash: Bytes!
  btcTxVout: BigInt!
  emittedBy: Bytes!
  feeWei: BigInt!
  id: ID!
  rskAddress: Bytes!
  timestamp: BigInt!
  transaction: Transaction!
  transactionHash: Bytes!
}

input NewBitcoinTransferIncoming_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amountWei: BigInt
  amountWei_gt: BigInt
  amountWei_gte: BigInt
  amountWei_in: [BigInt!]
  amountWei_lt: BigInt
  amountWei_lte: BigInt
  amountWei_not: BigInt
  amountWei_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  btcTxHash: Bytes
  btcTxHash_contains: Bytes
  btcTxHash_in: [Bytes!]
  btcTxHash_not: Bytes
  btcTxHash_not_contains: Bytes
  btcTxHash_not_in: [Bytes!]
  btcTxVout: BigInt
  btcTxVout_gt: BigInt
  btcTxVout_gte: BigInt
  btcTxVout_in: [BigInt!]
  btcTxVout_lt: BigInt
  btcTxVout_lte: BigInt
  btcTxVout_not: BigInt
  btcTxVout_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  feeWei: BigInt
  feeWei_gt: BigInt
  feeWei_gte: BigInt
  feeWei_in: [BigInt!]
  feeWei_lt: BigInt
  feeWei_lte: BigInt
  feeWei_not: BigInt
  feeWei_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  rskAddress: Bytes
  rskAddress_contains: Bytes
  rskAddress_in: [Bytes!]
  rskAddress_not: Bytes
  rskAddress_not_contains: Bytes
  rskAddress_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum NewBitcoinTransferIncoming_orderBy {
  amountWei
  blockNumber
  blockTimestamp
  btcTxHash
  btcTxVout
  emittedBy
  feeWei
  id
  rskAddress
  timestamp
  transaction
  transactionHash
}

type OrderCanceled {
  emittedBy: Bytes!
  hash: Bytes!
  id: ID!
  maker: Bytes!
  timestamp: Int!
  transaction: Transaction!
}

input OrderCanceled_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  maker: Bytes
  maker_contains: Bytes
  maker_in: [Bytes!]
  maker_not: Bytes
  maker_not_contains: Bytes
  maker_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum OrderCanceled_orderBy {
  emittedBy
  hash
  id
  maker
  timestamp
  transaction
}

type OrderCreated {
  emittedBy: Bytes!
  hash: Bytes!
  id: ID!

  """
  The price at which the order should be executed.
  This is a BigInt (usually 1e18), not a human-readable decimal. (See above for explanation)
  """
  limitPrice: BigInt!
  network: Network!

  """
  The amountIn is a BigInt (usually 1e18), not a human-readable decimal.
  This is because both orderbooks are on testnet, and so this subgraph cannot access the correct number of token decimals for mainnet tokens
  """
  order_amountIn: BigInt!

  """
  The amountIn is a BigInt (usually 1e18), not a human-readable decimal. (See above for explanation)
  """
  order_amountOutMin: BigInt!

  """
  Timestamp when the order was created
  """
  order_created: BigInt!

  """
  Timestamp when the order must be filled by
  """
  order_deadline: BigInt!
  order_fromToken: Bytes!

  """
  This is the User address. This is not a User entity because of the testnet/mainnet issue (see above comment)
  """
  order_maker: Bytes!
  order_recipient: Bytes!
  order_toToken: Bytes!
  timestamp: Int!
  transaction: Transaction!
}

input OrderCreated_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  limitPrice: BigInt
  limitPrice_gt: BigInt
  limitPrice_gte: BigInt
  limitPrice_in: [BigInt!]
  limitPrice_lt: BigInt
  limitPrice_lte: BigInt
  limitPrice_not: BigInt
  limitPrice_not_in: [BigInt!]
  network: Network
  network_in: [Network!]
  network_not: Network
  network_not_in: [Network!]
  order_amountIn: BigInt
  order_amountIn_gt: BigInt
  order_amountIn_gte: BigInt
  order_amountIn_in: [BigInt!]
  order_amountIn_lt: BigInt
  order_amountIn_lte: BigInt
  order_amountIn_not: BigInt
  order_amountIn_not_in: [BigInt!]
  order_amountOutMin: BigInt
  order_amountOutMin_gt: BigInt
  order_amountOutMin_gte: BigInt
  order_amountOutMin_in: [BigInt!]
  order_amountOutMin_lt: BigInt
  order_amountOutMin_lte: BigInt
  order_amountOutMin_not: BigInt
  order_amountOutMin_not_in: [BigInt!]
  order_created: BigInt
  order_created_gt: BigInt
  order_created_gte: BigInt
  order_created_in: [BigInt!]
  order_created_lt: BigInt
  order_created_lte: BigInt
  order_created_not: BigInt
  order_created_not_in: [BigInt!]
  order_deadline: BigInt
  order_deadline_gt: BigInt
  order_deadline_gte: BigInt
  order_deadline_in: [BigInt!]
  order_deadline_lt: BigInt
  order_deadline_lte: BigInt
  order_deadline_not: BigInt
  order_deadline_not_in: [BigInt!]
  order_fromToken: Bytes
  order_fromToken_contains: Bytes
  order_fromToken_in: [Bytes!]
  order_fromToken_not: Bytes
  order_fromToken_not_contains: Bytes
  order_fromToken_not_in: [Bytes!]
  order_maker: Bytes
  order_maker_contains: Bytes
  order_maker_in: [Bytes!]
  order_maker_not: Bytes
  order_maker_not_contains: Bytes
  order_maker_not_in: [Bytes!]
  order_recipient: Bytes
  order_recipient_contains: Bytes
  order_recipient_in: [Bytes!]
  order_recipient_not: Bytes
  order_recipient_not_contains: Bytes
  order_recipient_not_in: [Bytes!]
  order_toToken: Bytes
  order_toToken_contains: Bytes
  order_toToken_in: [Bytes!]
  order_toToken_not: Bytes
  order_toToken_not_contains: Bytes
  order_toToken_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum OrderCreated_orderBy {
  emittedBy
  hash
  id
  limitPrice
  network
  order_amountIn
  order_amountOutMin
  order_created
  order_deadline
  order_fromToken
  order_maker
  order_recipient
  order_toToken
  timestamp
  transaction
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

type OrderFilled {
  amountIn: BigDecimal!
  amountOut: BigDecimal!
  emittedBy: Bytes!
  filledPrice: BigDecimal!
  hash: Bytes!
  id: ID!
  maker: User!
  path: [String!]!
  timestamp: Int!
  transaction: Transaction!
}

input OrderFilled_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amountIn: BigDecimal
  amountIn_gt: BigDecimal
  amountIn_gte: BigDecimal
  amountIn_in: [BigDecimal!]
  amountIn_lt: BigDecimal
  amountIn_lte: BigDecimal
  amountIn_not: BigDecimal
  amountIn_not_in: [BigDecimal!]
  amountOut: BigDecimal
  amountOut_gt: BigDecimal
  amountOut_gte: BigDecimal
  amountOut_in: [BigDecimal!]
  amountOut_lt: BigDecimal
  amountOut_lte: BigDecimal
  amountOut_not: BigDecimal
  amountOut_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  filledPrice: BigDecimal
  filledPrice_gt: BigDecimal
  filledPrice_gte: BigDecimal
  filledPrice_in: [BigDecimal!]
  filledPrice_lt: BigDecimal
  filledPrice_lte: BigDecimal
  filledPrice_not: BigDecimal
  filledPrice_not_in: [BigDecimal!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  maker: String
  maker_: User_filter
  maker_contains: String
  maker_contains_nocase: String
  maker_ends_with: String
  maker_ends_with_nocase: String
  maker_gt: String
  maker_gte: String
  maker_in: [String!]
  maker_lt: String
  maker_lte: String
  maker_not: String
  maker_not_contains: String
  maker_not_contains_nocase: String
  maker_not_ends_with: String
  maker_not_ends_with_nocase: String
  maker_not_in: [String!]
  maker_not_starts_with: String
  maker_not_starts_with_nocase: String
  maker_starts_with: String
  maker_starts_with_nocase: String
  path: [String!]
  path_contains: [String!]
  path_contains_nocase: [String!]
  path_not: [String!]
  path_not_contains: [String!]
  path_not_contains_nocase: [String!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum OrderFilled_orderBy {
  amountIn
  amountOut
  emittedBy
  filledPrice
  hash
  id
  maker
  path
  timestamp
  transaction
}

type OwnerUpdate {
  emittedBy: String!
  id: ID!
  newOwner: String!
  prevOwner: String!
  timestamp: BigInt!
}

input OwnerUpdate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  emittedBy: String
  emittedBy_contains: String
  emittedBy_contains_nocase: String
  emittedBy_ends_with: String
  emittedBy_ends_with_nocase: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_contains_nocase: String
  emittedBy_not_ends_with: String
  emittedBy_not_ends_with_nocase: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_not_starts_with_nocase: String
  emittedBy_starts_with: String
  emittedBy_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  newOwner: String
  newOwner_contains: String
  newOwner_contains_nocase: String
  newOwner_ends_with: String
  newOwner_ends_with_nocase: String
  newOwner_gt: String
  newOwner_gte: String
  newOwner_in: [String!]
  newOwner_lt: String
  newOwner_lte: String
  newOwner_not: String
  newOwner_not_contains: String
  newOwner_not_contains_nocase: String
  newOwner_not_ends_with: String
  newOwner_not_ends_with_nocase: String
  newOwner_not_in: [String!]
  newOwner_not_starts_with: String
  newOwner_not_starts_with_nocase: String
  newOwner_starts_with: String
  newOwner_starts_with_nocase: String
  prevOwner: String
  prevOwner_contains: String
  prevOwner_contains_nocase: String
  prevOwner_ends_with: String
  prevOwner_ends_with_nocase: String
  prevOwner_gt: String
  prevOwner_gte: String
  prevOwner_in: [String!]
  prevOwner_lt: String
  prevOwner_lte: String
  prevOwner_not: String
  prevOwner_not_contains: String
  prevOwner_not_contains_nocase: String
  prevOwner_not_ends_with: String
  prevOwner_not_ends_with_nocase: String
  prevOwner_not_in: [String!]
  prevOwner_not_starts_with: String
  prevOwner_not_starts_with_nocase: String
  prevOwner_starts_with: String
  prevOwner_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum OwnerUpdate_orderBy {
  emittedBy
  id
  newOwner
  prevOwner
  timestamp
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows and when a loan is rolled over
"""
type PayBorrowingFee {
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  loanId: Loan!
  payer: Bytes!
  timestamp: Int!
  token: Bytes!
  transaction: Transaction!
}

input PayBorrowingFee_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: String
  loanId_: Loan_filter
  loanId_contains: String
  loanId_contains_nocase: String
  loanId_ends_with: String
  loanId_ends_with_nocase: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_contains_nocase: String
  loanId_not_ends_with: String
  loanId_not_ends_with_nocase: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_not_starts_with_nocase: String
  loanId_starts_with: String
  loanId_starts_with_nocase: String
  payer: Bytes
  payer_contains: Bytes
  payer_in: [Bytes!]
  payer_not: Bytes
  payer_not_contains: Bytes
  payer_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum PayBorrowingFee_orderBy {
  amount
  emittedBy
  id
  loanId
  payer
  timestamp
  token
  transaction
}

type PayInterestTransfer {
  effectiveInterest: BigDecimal!
  emittedBy: String!
  id: ID!
  interestToken: Token!
  lender: LendingPool!
  timestamp: Int!
  transaction: Transaction!
}

input PayInterestTransfer_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  effectiveInterest: BigDecimal
  effectiveInterest_gt: BigDecimal
  effectiveInterest_gte: BigDecimal
  effectiveInterest_in: [BigDecimal!]
  effectiveInterest_lt: BigDecimal
  effectiveInterest_lte: BigDecimal
  effectiveInterest_not: BigDecimal
  effectiveInterest_not_in: [BigDecimal!]
  emittedBy: String
  emittedBy_contains: String
  emittedBy_contains_nocase: String
  emittedBy_ends_with: String
  emittedBy_ends_with_nocase: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_contains_nocase: String
  emittedBy_not_ends_with: String
  emittedBy_not_ends_with_nocase: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_not_starts_with_nocase: String
  emittedBy_starts_with: String
  emittedBy_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  interestToken: String
  interestToken_: Token_filter
  interestToken_contains: String
  interestToken_contains_nocase: String
  interestToken_ends_with: String
  interestToken_ends_with_nocase: String
  interestToken_gt: String
  interestToken_gte: String
  interestToken_in: [String!]
  interestToken_lt: String
  interestToken_lte: String
  interestToken_not: String
  interestToken_not_contains: String
  interestToken_not_contains_nocase: String
  interestToken_not_ends_with: String
  interestToken_not_ends_with_nocase: String
  interestToken_not_in: [String!]
  interestToken_not_starts_with: String
  interestToken_not_starts_with_nocase: String
  interestToken_starts_with: String
  interestToken_starts_with_nocase: String
  lender: String
  lender_: LendingPool_filter
  lender_contains: String
  lender_contains_nocase: String
  lender_ends_with: String
  lender_ends_with_nocase: String
  lender_gt: String
  lender_gte: String
  lender_in: [String!]
  lender_lt: String
  lender_lte: String
  lender_not: String
  lender_not_contains: String
  lender_not_contains_nocase: String
  lender_not_ends_with: String
  lender_not_ends_with_nocase: String
  lender_not_in: [String!]
  lender_not_starts_with: String
  lender_not_starts_with_nocase: String
  lender_starts_with: String
  lender_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum PayInterestTransfer_orderBy {
  effectiveInterest
  emittedBy
  id
  interestToken
  lender
  timestamp
  transaction
}

"""
Granular event data for the Loan entity. Emitted when a user Lends or Unlends and when a loan is rolled over
"""
type PayLendingFee {
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  payer: Bytes!
  timestamp: Int!
  token: Bytes!
  transaction: Transaction!
}

input PayLendingFee_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  payer: Bytes
  payer_contains: Bytes
  payer_in: [Bytes!]
  payer_not: Bytes
  payer_not_contains: Bytes
  payer_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum PayLendingFee_orderBy {
  amount
  emittedBy
  id
  payer
  timestamp
  token
  transaction
}

"""
Granular event data for the Loan entity. Emitted when a user Margin Trades and when a loan is rolled over
"""
type PayTradingFee {
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  loanId: String!
  payer: Bytes!
  timestamp: Int!
  token: Bytes!
  transaction: Transaction!
}

input PayTradingFee_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: String
  loanId_contains: String
  loanId_contains_nocase: String
  loanId_ends_with: String
  loanId_ends_with_nocase: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_contains_nocase: String
  loanId_not_ends_with: String
  loanId_not_ends_with_nocase: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_not_starts_with_nocase: String
  loanId_starts_with: String
  loanId_starts_with_nocase: String
  payer: Bytes
  payer_contains: Bytes
  payer_in: [Bytes!]
  payer_not: Bytes
  payer_not_contains: Bytes
  payer_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum PayTradingFee_orderBy {
  amount
  emittedBy
  id
  loanId
  payer
  timestamp
  token
  transaction
}

"""
For the V1 pools, the pool token and smart token are the same. However, for V2 pools, there is one pool token per asset and only one smart token for the pool.
"""
type PoolToken {
  decimals: Int
  id: ID!
  liquidityPool: LiquidityPool!
  name: String
  symbol: String

  """
  For V1 pools, there will be 2 underlying assets, however for V2 pools there will be just one
  """
  underlyingAssets(
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Token_filter
  ): [Token!]!
}

input PoolToken_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPool: String
  liquidityPool_: LiquidityPool_filter
  liquidityPool_contains: String
  liquidityPool_contains_nocase: String
  liquidityPool_ends_with: String
  liquidityPool_ends_with_nocase: String
  liquidityPool_gt: String
  liquidityPool_gte: String
  liquidityPool_in: [String!]
  liquidityPool_lt: String
  liquidityPool_lte: String
  liquidityPool_not: String
  liquidityPool_not_contains: String
  liquidityPool_not_contains_nocase: String
  liquidityPool_not_ends_with: String
  liquidityPool_not_ends_with_nocase: String
  liquidityPool_not_in: [String!]
  liquidityPool_not_starts_with: String
  liquidityPool_not_starts_with_nocase: String
  liquidityPool_starts_with: String
  liquidityPool_starts_with_nocase: String
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  underlyingAssets: [String!]
  underlyingAssets_: Token_filter
  underlyingAssets_contains: [String!]
  underlyingAssets_contains_nocase: [String!]
  underlyingAssets_not: [String!]
  underlyingAssets_not_contains: [String!]
  underlyingAssets_not_contains_nocase: [String!]
}

enum PoolToken_orderBy {
  decimals
  id
  liquidityPool
  name
  symbol
  underlyingAssets
}

"""
A Proposal is created each time a SIP (Sovryn Improvement Proposal) is proposed
The Proposal is created, voted on, and then executed if it passes
To see if a Proposal has been executed, see if the executed property is null or if it has a transaction
"""
type Proposal {
  """
  If the proposal was canceled, the transaction that canceled it (otherwise null)
  """
  canceled: Transaction

  """
  Number of unique wallets that voted against this proposal
  """
  countVotersAgainst: Int!

  """
  Number of unique wallets that voted for this proposal
  """
  countVotersFor: Int!

  """
  Transaction that created the proposal
  """
  created: Transaction!

  """
  Brief description of what this SIP is for, sometimes with a link to the github repo and README for this proposal
  """
  description: String!

  """
  The contract that emitted this event
  """
  emittedBy: Bytes!

  """
  Block when voting ends
  """
  endBlock: Int!

  """
  If the proposal was executed, the transaction that executed it (otherwise null)
  """
  executed: Transaction

  """
  ID is the address of the governor contract that was used to create the proposal, + the id of the proposal
  """
  id: ID!
  proposalId: Int!

  """
  Address of the user who created this proposal
  """
  proposer: Bytes!

  """
  If the proposal was queued, the transaction that queued it (otherwise null)
  """
  queued: Transaction

  """
  Function signatures in the targeted contract that would be affected by this proposal passing
  """
  signatures: [String!]!

  """
  Block when voting starts
  """
  startBlock: Int!

  """
  Contract or contracts that this proposal targets
  """
  targets: [String!]!

  """
  Timestamp when this proposal was created. This is also available in the created transaction, but is included here so it is possible to order by timestamp
  """
  timestamp: Int!
  values: [BigInt!]!

  """
  Individual vote transactions
  """
  votes(
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VoteCast_filter
  ): [VoteCast!]

  """
  Number of votes against the proposal (weighted vote, not number of voters)
  """
  votesAgainst: BigInt!

  """
  Number of votes for the proposal (weighted vote, not number of voters)
  """
  votesFor: BigInt!
}

input Proposal_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  canceled: String
  canceled_: Transaction_filter
  canceled_contains: String
  canceled_contains_nocase: String
  canceled_ends_with: String
  canceled_ends_with_nocase: String
  canceled_gt: String
  canceled_gte: String
  canceled_in: [String!]
  canceled_lt: String
  canceled_lte: String
  canceled_not: String
  canceled_not_contains: String
  canceled_not_contains_nocase: String
  canceled_not_ends_with: String
  canceled_not_ends_with_nocase: String
  canceled_not_in: [String!]
  canceled_not_starts_with: String
  canceled_not_starts_with_nocase: String
  canceled_starts_with: String
  canceled_starts_with_nocase: String
  countVotersAgainst: Int
  countVotersAgainst_gt: Int
  countVotersAgainst_gte: Int
  countVotersAgainst_in: [Int!]
  countVotersAgainst_lt: Int
  countVotersAgainst_lte: Int
  countVotersAgainst_not: Int
  countVotersAgainst_not_in: [Int!]
  countVotersFor: Int
  countVotersFor_gt: Int
  countVotersFor_gte: Int
  countVotersFor_in: [Int!]
  countVotersFor_lt: Int
  countVotersFor_lte: Int
  countVotersFor_not: Int
  countVotersFor_not_in: [Int!]
  created: String
  created_: Transaction_filter
  created_contains: String
  created_contains_nocase: String
  created_ends_with: String
  created_ends_with_nocase: String
  created_gt: String
  created_gte: String
  created_in: [String!]
  created_lt: String
  created_lte: String
  created_not: String
  created_not_contains: String
  created_not_contains_nocase: String
  created_not_ends_with: String
  created_not_ends_with_nocase: String
  created_not_in: [String!]
  created_not_starts_with: String
  created_not_starts_with_nocase: String
  created_starts_with: String
  created_starts_with_nocase: String
  description: String
  description_contains: String
  description_contains_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  endBlock: Int
  endBlock_gt: Int
  endBlock_gte: Int
  endBlock_in: [Int!]
  endBlock_lt: Int
  endBlock_lte: Int
  endBlock_not: Int
  endBlock_not_in: [Int!]
  executed: String
  executed_: Transaction_filter
  executed_contains: String
  executed_contains_nocase: String
  executed_ends_with: String
  executed_ends_with_nocase: String
  executed_gt: String
  executed_gte: String
  executed_in: [String!]
  executed_lt: String
  executed_lte: String
  executed_not: String
  executed_not_contains: String
  executed_not_contains_nocase: String
  executed_not_ends_with: String
  executed_not_ends_with_nocase: String
  executed_not_in: [String!]
  executed_not_starts_with: String
  executed_not_starts_with_nocase: String
  executed_starts_with: String
  executed_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  proposalId: Int
  proposalId_gt: Int
  proposalId_gte: Int
  proposalId_in: [Int!]
  proposalId_lt: Int
  proposalId_lte: Int
  proposalId_not: Int
  proposalId_not_in: [Int!]
  proposer: Bytes
  proposer_contains: Bytes
  proposer_in: [Bytes!]
  proposer_not: Bytes
  proposer_not_contains: Bytes
  proposer_not_in: [Bytes!]
  queued: String
  queued_: Transaction_filter
  queued_contains: String
  queued_contains_nocase: String
  queued_ends_with: String
  queued_ends_with_nocase: String
  queued_gt: String
  queued_gte: String
  queued_in: [String!]
  queued_lt: String
  queued_lte: String
  queued_not: String
  queued_not_contains: String
  queued_not_contains_nocase: String
  queued_not_ends_with: String
  queued_not_ends_with_nocase: String
  queued_not_in: [String!]
  queued_not_starts_with: String
  queued_not_starts_with_nocase: String
  queued_starts_with: String
  queued_starts_with_nocase: String
  signatures: [String!]
  signatures_contains: [String!]
  signatures_contains_nocase: [String!]
  signatures_not: [String!]
  signatures_not_contains: [String!]
  signatures_not_contains_nocase: [String!]
  startBlock: Int
  startBlock_gt: Int
  startBlock_gte: Int
  startBlock_in: [Int!]
  startBlock_lt: Int
  startBlock_lte: Int
  startBlock_not: Int
  startBlock_not_in: [Int!]
  targets: [String!]
  targets_contains: [String!]
  targets_contains_nocase: [String!]
  targets_not: [String!]
  targets_not_contains: [String!]
  targets_not_contains_nocase: [String!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  values: [BigInt!]
  values_contains: [BigInt!]
  values_contains_nocase: [BigInt!]
  values_not: [BigInt!]
  values_not_contains: [BigInt!]
  values_not_contains_nocase: [BigInt!]
  votesAgainst: BigInt
  votesAgainst_gt: BigInt
  votesAgainst_gte: BigInt
  votesAgainst_in: [BigInt!]
  votesAgainst_lt: BigInt
  votesAgainst_lte: BigInt
  votesAgainst_not: BigInt
  votesAgainst_not_in: [BigInt!]
  votesFor: BigInt
  votesFor_gt: BigInt
  votesFor_gte: BigInt
  votesFor_in: [BigInt!]
  votesFor_lt: BigInt
  votesFor_lte: BigInt
  votesFor_not: BigInt
  votesFor_not_in: [BigInt!]
  votes_: VoteCast_filter
}

enum Proposal_orderBy {
  canceled
  countVotersAgainst
  countVotersFor
  created
  description
  emittedBy
  endBlock
  executed
  id
  proposalId
  proposer
  queued
  signatures
  startBlock
  targets
  timestamp
  values
  votes
  votesAgainst
  votesFor
}

"""
This entity will have only one instance and will be used to store protocol-wide data like list of tokens and number or users.
The ID of this one entity is "0"
"""
type ProtocolStats {
  """
  Current price of BTC in usdStablecoin
  """
  btcUsdPrice: BigDecimal!

  """
  This is SOV staked by vesting contracts. It in incremented when the contracts stake the tokens, and decremented when users claim their unlocked tokens
  """
  currentStakedByVestingSov: BigDecimal!

  """
  This is SOV staked by users (not vesting contracts). It is incremented when users stake tokens, and decremented when users withdraw tokens from the staking contract
  """
  currentVoluntarilyStakedSov: BigDecimal!

  """
  Only one entity should be created, with ID "0"
  """
  id: ID!

  """
  An array of all tokens in the protocol
  """
  tokens(
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Token_filter
  ): [Token!]!

  """
  Total volume of fees earned by liquidity providers to AMM pools (in usd)
  """
  totalAmmLpFeesUsd: BigDecimal!

  """
  Total volume of fees earned by SOV stakers from AMM conversion events (in usd). These fees began after the fee-sharing SIP was executed.
  """
  totalAmmStakerFeesUsd: BigDecimal!

  """
  Total volume that has passed through every AMM pool of the Sovryn protocol (in usd)
  """
  totalAmmVolumeUsd: BigDecimal!

  """
  Total of collateral property in Trade event (in usd). This may be changed to borrowed amount volume, but collateral keeps it consistent with margin trading
  """
  totalBorrowVolumeUsd: BigDecimal!

  """
  Total fees from Borrowing earned by SOV stakers (in usd)
  """
  totalBorrowingFeesUsd: BigDecimal!

  """
  Total volume of Borrows closed (in usd)
  """
  totalCloseWithDepositVolumeUsd: BigDecimal!

  """
  Total position volume closed for Margin Trades (in usd)
  """
  totalCloseWithSwapVolumeUsd: BigDecimal!

  """
  Total additional collateral deposited for Margin Trades and Borrows (in usd)
  """
  totalDepositCollateralVolumeUsd: BigDecimal!

  """
  Total volume supplied to Lending Pools over all time (in usd)
  """
  totalLendVolumeUsd: BigDecimal!

  """
  Total fees from Lending and Unlending earned by SOV stakers (in usd)
  """
  totalLendingFeesUsd: BigDecimal!

  """
  Total Margin Trade and Borrow position size that has been liquidated (in usd)
  """
  totalLiquidateVolumeUsd: BigDecimal!

  """
  Total of positionSize property in Trade event (in usd). This includes user collateral and borrowed amount
  """
  totalMarginTradeVolumeUsd: BigDecimal!

  """
  Total fees from Margin Trading earned by SOV stakers (in usd)
  """
  totalTradingFeesUsd: BigDecimal!

  """
  Total volume withdrawn from Lending Pool over all time (in usd)
  """
  totalUnlendVolumeUsd: BigDecimal!

  """
  Total number of users of the protocol. This number is incremented each time a user initiates a transaction with the Protocol.
  Incremented when a user interacts with any contracts tracked by this subgraph.
  Does not include the Zero, Mynt and Perperpetual Swaps users (unless they have also used the core protocol)
  """
  totalUsers: Int!

  """
  The token currently used as a proxy for USD/BTC prices
  """
  usdStablecoin: Token!
}

input ProtocolStats_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  btcUsdPrice: BigDecimal
  btcUsdPrice_gt: BigDecimal
  btcUsdPrice_gte: BigDecimal
  btcUsdPrice_in: [BigDecimal!]
  btcUsdPrice_lt: BigDecimal
  btcUsdPrice_lte: BigDecimal
  btcUsdPrice_not: BigDecimal
  btcUsdPrice_not_in: [BigDecimal!]
  currentStakedByVestingSov: BigDecimal
  currentStakedByVestingSov_gt: BigDecimal
  currentStakedByVestingSov_gte: BigDecimal
  currentStakedByVestingSov_in: [BigDecimal!]
  currentStakedByVestingSov_lt: BigDecimal
  currentStakedByVestingSov_lte: BigDecimal
  currentStakedByVestingSov_not: BigDecimal
  currentStakedByVestingSov_not_in: [BigDecimal!]
  currentVoluntarilyStakedSov: BigDecimal
  currentVoluntarilyStakedSov_gt: BigDecimal
  currentVoluntarilyStakedSov_gte: BigDecimal
  currentVoluntarilyStakedSov_in: [BigDecimal!]
  currentVoluntarilyStakedSov_lt: BigDecimal
  currentVoluntarilyStakedSov_lte: BigDecimal
  currentVoluntarilyStakedSov_not: BigDecimal
  currentVoluntarilyStakedSov_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  tokens: [String!]
  tokens_: Token_filter
  tokens_contains: [String!]
  tokens_contains_nocase: [String!]
  tokens_not: [String!]
  tokens_not_contains: [String!]
  tokens_not_contains_nocase: [String!]
  totalAmmLpFeesUsd: BigDecimal
  totalAmmLpFeesUsd_gt: BigDecimal
  totalAmmLpFeesUsd_gte: BigDecimal
  totalAmmLpFeesUsd_in: [BigDecimal!]
  totalAmmLpFeesUsd_lt: BigDecimal
  totalAmmLpFeesUsd_lte: BigDecimal
  totalAmmLpFeesUsd_not: BigDecimal
  totalAmmLpFeesUsd_not_in: [BigDecimal!]
  totalAmmStakerFeesUsd: BigDecimal
  totalAmmStakerFeesUsd_gt: BigDecimal
  totalAmmStakerFeesUsd_gte: BigDecimal
  totalAmmStakerFeesUsd_in: [BigDecimal!]
  totalAmmStakerFeesUsd_lt: BigDecimal
  totalAmmStakerFeesUsd_lte: BigDecimal
  totalAmmStakerFeesUsd_not: BigDecimal
  totalAmmStakerFeesUsd_not_in: [BigDecimal!]
  totalAmmVolumeUsd: BigDecimal
  totalAmmVolumeUsd_gt: BigDecimal
  totalAmmVolumeUsd_gte: BigDecimal
  totalAmmVolumeUsd_in: [BigDecimal!]
  totalAmmVolumeUsd_lt: BigDecimal
  totalAmmVolumeUsd_lte: BigDecimal
  totalAmmVolumeUsd_not: BigDecimal
  totalAmmVolumeUsd_not_in: [BigDecimal!]
  totalBorrowVolumeUsd: BigDecimal
  totalBorrowVolumeUsd_gt: BigDecimal
  totalBorrowVolumeUsd_gte: BigDecimal
  totalBorrowVolumeUsd_in: [BigDecimal!]
  totalBorrowVolumeUsd_lt: BigDecimal
  totalBorrowVolumeUsd_lte: BigDecimal
  totalBorrowVolumeUsd_not: BigDecimal
  totalBorrowVolumeUsd_not_in: [BigDecimal!]
  totalBorrowingFeesUsd: BigDecimal
  totalBorrowingFeesUsd_gt: BigDecimal
  totalBorrowingFeesUsd_gte: BigDecimal
  totalBorrowingFeesUsd_in: [BigDecimal!]
  totalBorrowingFeesUsd_lt: BigDecimal
  totalBorrowingFeesUsd_lte: BigDecimal
  totalBorrowingFeesUsd_not: BigDecimal
  totalBorrowingFeesUsd_not_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd: BigDecimal
  totalCloseWithDepositVolumeUsd_gt: BigDecimal
  totalCloseWithDepositVolumeUsd_gte: BigDecimal
  totalCloseWithDepositVolumeUsd_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd_lt: BigDecimal
  totalCloseWithDepositVolumeUsd_lte: BigDecimal
  totalCloseWithDepositVolumeUsd_not: BigDecimal
  totalCloseWithDepositVolumeUsd_not_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd: BigDecimal
  totalCloseWithSwapVolumeUsd_gt: BigDecimal
  totalCloseWithSwapVolumeUsd_gte: BigDecimal
  totalCloseWithSwapVolumeUsd_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd_lt: BigDecimal
  totalCloseWithSwapVolumeUsd_lte: BigDecimal
  totalCloseWithSwapVolumeUsd_not: BigDecimal
  totalCloseWithSwapVolumeUsd_not_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd: BigDecimal
  totalDepositCollateralVolumeUsd_gt: BigDecimal
  totalDepositCollateralVolumeUsd_gte: BigDecimal
  totalDepositCollateralVolumeUsd_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd_lt: BigDecimal
  totalDepositCollateralVolumeUsd_lte: BigDecimal
  totalDepositCollateralVolumeUsd_not: BigDecimal
  totalDepositCollateralVolumeUsd_not_in: [BigDecimal!]
  totalLendVolumeUsd: BigDecimal
  totalLendVolumeUsd_gt: BigDecimal
  totalLendVolumeUsd_gte: BigDecimal
  totalLendVolumeUsd_in: [BigDecimal!]
  totalLendVolumeUsd_lt: BigDecimal
  totalLendVolumeUsd_lte: BigDecimal
  totalLendVolumeUsd_not: BigDecimal
  totalLendVolumeUsd_not_in: [BigDecimal!]
  totalLendingFeesUsd: BigDecimal
  totalLendingFeesUsd_gt: BigDecimal
  totalLendingFeesUsd_gte: BigDecimal
  totalLendingFeesUsd_in: [BigDecimal!]
  totalLendingFeesUsd_lt: BigDecimal
  totalLendingFeesUsd_lte: BigDecimal
  totalLendingFeesUsd_not: BigDecimal
  totalLendingFeesUsd_not_in: [BigDecimal!]
  totalLiquidateVolumeUsd: BigDecimal
  totalLiquidateVolumeUsd_gt: BigDecimal
  totalLiquidateVolumeUsd_gte: BigDecimal
  totalLiquidateVolumeUsd_in: [BigDecimal!]
  totalLiquidateVolumeUsd_lt: BigDecimal
  totalLiquidateVolumeUsd_lte: BigDecimal
  totalLiquidateVolumeUsd_not: BigDecimal
  totalLiquidateVolumeUsd_not_in: [BigDecimal!]
  totalMarginTradeVolumeUsd: BigDecimal
  totalMarginTradeVolumeUsd_gt: BigDecimal
  totalMarginTradeVolumeUsd_gte: BigDecimal
  totalMarginTradeVolumeUsd_in: [BigDecimal!]
  totalMarginTradeVolumeUsd_lt: BigDecimal
  totalMarginTradeVolumeUsd_lte: BigDecimal
  totalMarginTradeVolumeUsd_not: BigDecimal
  totalMarginTradeVolumeUsd_not_in: [BigDecimal!]
  totalTradingFeesUsd: BigDecimal
  totalTradingFeesUsd_gt: BigDecimal
  totalTradingFeesUsd_gte: BigDecimal
  totalTradingFeesUsd_in: [BigDecimal!]
  totalTradingFeesUsd_lt: BigDecimal
  totalTradingFeesUsd_lte: BigDecimal
  totalTradingFeesUsd_not: BigDecimal
  totalTradingFeesUsd_not_in: [BigDecimal!]
  totalUnlendVolumeUsd: BigDecimal
  totalUnlendVolumeUsd_gt: BigDecimal
  totalUnlendVolumeUsd_gte: BigDecimal
  totalUnlendVolumeUsd_in: [BigDecimal!]
  totalUnlendVolumeUsd_lt: BigDecimal
  totalUnlendVolumeUsd_lte: BigDecimal
  totalUnlendVolumeUsd_not: BigDecimal
  totalUnlendVolumeUsd_not_in: [BigDecimal!]
  totalUsers: Int
  totalUsers_gt: Int
  totalUsers_gte: Int
  totalUsers_in: [Int!]
  totalUsers_lt: Int
  totalUsers_lte: Int
  totalUsers_not: Int
  totalUsers_not_in: [Int!]
  usdStablecoin: String
  usdStablecoin_: Token_filter
  usdStablecoin_contains: String
  usdStablecoin_contains_nocase: String
  usdStablecoin_ends_with: String
  usdStablecoin_ends_with_nocase: String
  usdStablecoin_gt: String
  usdStablecoin_gte: String
  usdStablecoin_in: [String!]
  usdStablecoin_lt: String
  usdStablecoin_lte: String
  usdStablecoin_not: String
  usdStablecoin_not_contains: String
  usdStablecoin_not_contains_nocase: String
  usdStablecoin_not_ends_with: String
  usdStablecoin_not_ends_with_nocase: String
  usdStablecoin_not_in: [String!]
  usdStablecoin_not_starts_with: String
  usdStablecoin_not_starts_with_nocase: String
  usdStablecoin_starts_with: String
  usdStablecoin_starts_with_nocase: String
}

enum ProtocolStats_orderBy {
  btcUsdPrice
  currentStakedByVestingSov
  currentVoluntarilyStakedSov
  id
  tokens
  totalAmmLpFeesUsd
  totalAmmStakerFeesUsd
  totalAmmVolumeUsd
  totalBorrowVolumeUsd
  totalBorrowingFeesUsd
  totalCloseWithDepositVolumeUsd
  totalCloseWithSwapVolumeUsd
  totalDepositCollateralVolumeUsd
  totalLendVolumeUsd
  totalLendingFeesUsd
  totalLiquidateVolumeUsd
  totalMarginTradeVolumeUsd
  totalTradingFeesUsd
  totalUnlendVolumeUsd
  totalUsers
  usdStablecoin
}

type ProtocolWithdrawFee {
  amount: BigDecimal!
  amountUsd: BigDecimal!
  emittedBy: String!
  feeType: FeeType!

  """
  ID is txHash-logIndex-tokenSymbol
  """
  id: ID!
  timestamp: Int!
  token: Token!
  transaction: Transaction!
}

input ProtocolWithdrawFee_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amountUsd: BigDecimal
  amountUsd_gt: BigDecimal
  amountUsd_gte: BigDecimal
  amountUsd_in: [BigDecimal!]
  amountUsd_lt: BigDecimal
  amountUsd_lte: BigDecimal
  amountUsd_not: BigDecimal
  amountUsd_not_in: [BigDecimal!]
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: String
  emittedBy_contains: String
  emittedBy_contains_nocase: String
  emittedBy_ends_with: String
  emittedBy_ends_with_nocase: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_contains_nocase: String
  emittedBy_not_ends_with: String
  emittedBy_not_ends_with_nocase: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_not_starts_with_nocase: String
  emittedBy_starts_with: String
  emittedBy_starts_with_nocase: String
  feeType: FeeType
  feeType_in: [FeeType!]
  feeType_not: FeeType
  feeType_not_in: [FeeType!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum ProtocolWithdrawFee_orderBy {
  amount
  amountUsd
  emittedBy
  feeType
  id
  timestamp
  token
  transaction
}

type Query {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  bitcoinTransfer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransfer
  bitcoinTransferBatchSending(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransferBatchSending
  bitcoinTransferBatchSendings(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BitcoinTransferBatchSending_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BitcoinTransferBatchSending_filter
  ): [BitcoinTransferBatchSending!]!
  bitcoinTransfers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BitcoinTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BitcoinTransfer_filter
  ): [BitcoinTransfer!]!
  borrow(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Borrow
  borrows(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Borrow_filter
  ): [Borrow!]!
  bridge(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bridge
  bridges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Bridge_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Bridge_filter
  ): [Bridge!]!
  candleStickDay(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickDay
  candleStickDays(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStickDay_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStickDay_filter
  ): [CandleStickDay!]!
  candleStickFifteenMinute(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickFifteenMinute
  candleStickFifteenMinutes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStickFifteenMinute_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStickFifteenMinute_filter
  ): [CandleStickFifteenMinute!]!
  candleStickFourHour(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickFourHour
  candleStickFourHours(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStickFourHour_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStickFourHour_filter
  ): [CandleStickFourHour!]!
  candleStickHour(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickHour
  candleStickHours(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStickHour_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStickHour_filter
  ): [CandleStickHour!]!
  candleStickMinute(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickMinute
  candleStickMinutes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStickMinute_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStickMinute_filter
  ): [CandleStickMinute!]!
  closeWithDeposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithDeposit
  closeWithDeposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithDeposit_filter
  ): [CloseWithDeposit!]!
  closeWithSwap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithSwap
  closeWithSwaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithSwap_filter
  ): [CloseWithSwap!]!
  conversion(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Conversion_filter
  ): [Conversion!]!
  converterRegistries(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ConverterRegistry_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ConverterRegistry_filter
  ): [ConverterRegistry!]!
  converterRegistry(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConverterRegistry
  crossTransfer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrossTransfer
  crossTransfers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrossTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrossTransfer_filter
  ): [CrossTransfer!]!
  deposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  depositCollateral(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositCollateral
  depositCollaterals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DepositCollateral_filter
  ): [DepositCollateral!]!
  deposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Deposit_filter
  ): [Deposit!]!
  fastBTCBridgeStat(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FastBTCBridgeStat
  fastBTCBridgeStats(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FastBTCBridgeStat_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FastBTCBridgeStat_filter
  ): [FastBTCBridgeStat!]!
  federation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Federation
  federations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Federation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Federation_filter
  ): [Federation!]!
  feeSharingTokensTransferred(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeSharingTokensTransferred
  feeSharingTokensTransferreds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeSharingTokensTransferred_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeSharingTokensTransferred_filter
  ): [FeeSharingTokensTransferred!]!
  icandleStick(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ICandleStick
  icandleSticks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ICandleStick_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ICandleStick_filter
  ): [ICandleStick!]!
  lendingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingHistoryItem
  lendingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingHistoryItem_filter
  ): [LendingHistoryItem!]!
  lendingPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingPool
  lendingPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingPool_filter
  ): [LendingPool!]!
  liquidate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidate
  liquidates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Liquidate_filter
  ): [Liquidate!]!
  liquidityHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityHistoryItem
  liquidityHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityHistoryItem_filter
  ): [LiquidityHistoryItem!]!
  liquidityMiningAllocationPoint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningAllocationPoint
  liquidityMiningAllocationPoints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityMiningAllocationPoint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityMiningAllocationPoint_filter
  ): [LiquidityMiningAllocationPoint!]!
  liquidityMiningGlobal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningGlobal
  liquidityMiningGlobals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityMiningGlobal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityMiningGlobal_filter
  ): [LiquidityMiningGlobal!]!
  liquidityPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPoolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolToken
  liquidityPoolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]!
  liquidityPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPool_filter
  ): [LiquidityPool!]!
  loan(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loans(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Loan_filter
  ): [Loan!]!
  marginOrderCanceled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderCanceled
  marginOrderCanceleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MarginOrderCanceled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MarginOrderCanceled_filter
  ): [MarginOrderCanceled!]!
  marginOrderFilled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderFilled
  marginOrderFilleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MarginOrderFilled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MarginOrderFilled_filter
  ): [MarginOrderFilled!]!
  newBitcoinTransferIncoming(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewBitcoinTransferIncoming
  newBitcoinTransferIncomings(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NewBitcoinTransferIncoming_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NewBitcoinTransferIncoming_filter
  ): [NewBitcoinTransferIncoming!]!
  orderCanceled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCanceled
  orderCanceleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderCanceled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderCanceled_filter
  ): [OrderCanceled!]!
  orderCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCreated
  orderCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderCreated_filter
  ): [OrderCreated!]!
  orderFilled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderFilled
  orderFilleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderFilled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderFilled_filter
  ): [OrderFilled!]!
  ownerUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnerUpdate
  ownerUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OwnerUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OwnerUpdate_filter
  ): [OwnerUpdate!]!
  payBorrowingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayBorrowingFee
  payBorrowingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayBorrowingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayBorrowingFee_filter
  ): [PayBorrowingFee!]!
  payInterestTransfer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayInterestTransfer
  payInterestTransfers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayInterestTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayInterestTransfer_filter
  ): [PayInterestTransfer!]!
  payLendingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayLendingFee
  payLendingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayLendingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayLendingFee_filter
  ): [PayLendingFee!]!
  payTradingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayTradingFee
  payTradingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayTradingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayTradingFee_filter
  ): [PayTradingFee!]!
  poolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolToken_filter
  ): [PoolToken!]!
  proposal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Proposal_filter
  ): [Proposal!]!
  protocolStats(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ProtocolStats_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ProtocolStats_filter
  ): [ProtocolStats!]!
  protocolWithdrawFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProtocolWithdrawFee
  protocolWithdrawFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ProtocolWithdrawFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ProtocolWithdrawFee_filter
  ): [ProtocolWithdrawFee!]!
  rewardsEarnedHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardsEarnedHistoryItem
  rewardsEarnedHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardsEarnedHistoryItem_filter
  ): [RewardsEarnedHistoryItem!]!
  rollover(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Rollover
  rollovers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Rollover_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Rollover_filter
  ): [Rollover!]!
  sideToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SideToken
  sideTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SideToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SideToken_filter
  ): [SideToken!]!
  smartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartToken
  smartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SmartToken_filter
  ): [SmartToken!]!
  stake(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Stake
  stakeHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistoryItem
  stakeHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StakeHistoryItem_filter
  ): [StakeHistoryItem!]!
  stakes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Stake_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Stake_filter
  ): [Stake!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenSmartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSmartToken
  tokenSmartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  tokensStaked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensStaked
  tokensStakeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokensStaked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokensStaked_filter
  ): [TokensStaked!]!
  trade(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Trade_filter
  ): [Trade!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userLendingHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLendingHistory_filter
  ): [UserLendingHistory!]!
  userLendingHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLendingHistory
  userLiquidityHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLiquidityHistory_filter
  ): [UserLiquidityHistory!]!
  userLiquidityHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLiquidityHistory
  userRewardsEarnedHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserRewardsEarnedHistory_filter
  ): [UserRewardsEarnedHistory!]!
  userRewardsEarnedHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserRewardsEarnedHistory
  userStakeHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserStakeHistory_filter
  ): [UserStakeHistory!]!
  userStakeHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserStakeHistory
  userTotal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserTotal
  userTotals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserTotal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserTotal_filter
  ): [UserTotal!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  vestingContract(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingContract
  vestingContracts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingContract_filter
  ): [VestingContract!]!
  vestingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingHistoryItem
  vestingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingHistoryItem_filter
  ): [VestingHistoryItem!]!
  voteCast(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteCast
  voteCasts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VoteCast_filter
  ): [VoteCast!]!
  withdrawal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawal
  withdrawals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Withdrawal_filter
  ): [Withdrawal!]!
}

enum RewardsEarnedAction {
  """
  SOV reward earned when a user margin trades or one of their trades is rolled over.
  The reward is a percentage of the trading fee, paid in SOV.
  """
  EarnReward

  """
  When a user claims a liquidity mining reward
  """
  RewardClaimed

  """
  When SOV is staked by a Rewards vesting contract (eg after it has been claimed by the user)
  """
  RewardSovStaked

  """
  When a SOV Staker withdraws their liquid SOV reward for staking
  """
  StakingRewardWithdrawn

  """
  When an SOV Staker withdraws their share of the fees earned by the Protocol
  """
  UserFeeWithdrawn
}

type RewardsEarnedHistoryItem {
  action: RewardsEarnedAction!
  amount: BigDecimal!
  id: ID!
  timestamp: Int!
  token: String
  transaction: Transaction!
  user: UserRewardsEarnedHistory!
}

input RewardsEarnedHistoryItem_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  action: RewardsEarnedAction
  action_in: [RewardsEarnedAction!]
  action_not: RewardsEarnedAction
  action_not_in: [RewardsEarnedAction!]
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: String
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  user: String
  user_: UserRewardsEarnedHistory_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum RewardsEarnedHistoryItem_orderBy {
  action
  amount
  id
  timestamp
  token
  transaction
  user
}

"""
Granular event data for the Loan entity. Emitted when a Loan is rolled over.
This is when the next installment of interest is paid from the collateral, and the trading fee is paid
This transaction is initiated by the Sovryn node, which earns a reward for doing this
"""
type Rollover {
  collateral: BigDecimal!
  emittedBy: Bytes!
  endTimestamp: Int!
  id: ID!
  lender: Bytes!
  loanId: Loan!
  principal: BigDecimal!

  """
  The reward received by the User for performing this function
  """
  reward: BigDecimal!

  """
  The User running the Sovryn node that made this transaction
  """
  rewardReceiver: User!
  timestamp: Int!
  transaction: Transaction!
  user: User!
}

input Rollover_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  collateral: BigDecimal
  collateral_gt: BigDecimal
  collateral_gte: BigDecimal
  collateral_in: [BigDecimal!]
  collateral_lt: BigDecimal
  collateral_lte: BigDecimal
  collateral_not: BigDecimal
  collateral_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  endTimestamp: Int
  endTimestamp_gt: Int
  endTimestamp_gte: Int
  endTimestamp_in: [Int!]
  endTimestamp_lt: Int
  endTimestamp_lte: Int
  endTimestamp_not: Int
  endTimestamp_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanId: String
  loanId_: Loan_filter
  loanId_contains: String
  loanId_contains_nocase: String
  loanId_ends_with: String
  loanId_ends_with_nocase: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_contains_nocase: String
  loanId_not_ends_with: String
  loanId_not_ends_with_nocase: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_not_starts_with_nocase: String
  loanId_starts_with: String
  loanId_starts_with_nocase: String
  principal: BigDecimal
  principal_gt: BigDecimal
  principal_gte: BigDecimal
  principal_in: [BigDecimal!]
  principal_lt: BigDecimal
  principal_lte: BigDecimal
  principal_not: BigDecimal
  principal_not_in: [BigDecimal!]
  reward: BigDecimal
  rewardReceiver: String
  rewardReceiver_: User_filter
  rewardReceiver_contains: String
  rewardReceiver_contains_nocase: String
  rewardReceiver_ends_with: String
  rewardReceiver_ends_with_nocase: String
  rewardReceiver_gt: String
  rewardReceiver_gte: String
  rewardReceiver_in: [String!]
  rewardReceiver_lt: String
  rewardReceiver_lte: String
  rewardReceiver_not: String
  rewardReceiver_not_contains: String
  rewardReceiver_not_contains_nocase: String
  rewardReceiver_not_ends_with: String
  rewardReceiver_not_ends_with_nocase: String
  rewardReceiver_not_in: [String!]
  rewardReceiver_not_starts_with: String
  rewardReceiver_not_starts_with_nocase: String
  rewardReceiver_starts_with: String
  rewardReceiver_starts_with_nocase: String
  reward_gt: BigDecimal
  reward_gte: BigDecimal
  reward_in: [BigDecimal!]
  reward_lt: BigDecimal
  reward_lte: BigDecimal
  reward_not: BigDecimal
  reward_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum Rollover_orderBy {
  collateral
  emittedBy
  endTimestamp
  id
  lender
  loanId
  principal
  reward
  rewardReceiver
  timestamp
  transaction
  user
}

"""
SideToken entity - for every token that is passed across the bridge and does not exist on sovryn a side token is created
"""
type SideToken {
  """
  CreatedAtTx - the creation transaction of the side token
  """
  createdAtTx: Transaction!

  """
  Granularity - this is the ERC777 granularity value for the side token
  """
  granularity: BigInt!

  """
  Id - the side token is stored twice, once with the original token address as id and another with the side token address
  """
  id: ID!

  """
  newSymbol - the new symbol given to the side token
  """
  newSymbol: String!

  """
  OriginalTokenAddress - the original token address of the side token
  """
  originalTokenAddress: Bytes!

  """
  SideTokenAddress - the token address on RSK of the side token
  """
  sideTokenAddress: Bytes!

  """
  UpdatedAtTx - The side token was last updated at this transaction
  """
  updatedAtTx: Transaction!
}

input SideToken_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  createdAtTx: String
  createdAtTx_: Transaction_filter
  createdAtTx_contains: String
  createdAtTx_contains_nocase: String
  createdAtTx_ends_with: String
  createdAtTx_ends_with_nocase: String
  createdAtTx_gt: String
  createdAtTx_gte: String
  createdAtTx_in: [String!]
  createdAtTx_lt: String
  createdAtTx_lte: String
  createdAtTx_not: String
  createdAtTx_not_contains: String
  createdAtTx_not_contains_nocase: String
  createdAtTx_not_ends_with: String
  createdAtTx_not_ends_with_nocase: String
  createdAtTx_not_in: [String!]
  createdAtTx_not_starts_with: String
  createdAtTx_not_starts_with_nocase: String
  createdAtTx_starts_with: String
  createdAtTx_starts_with_nocase: String
  granularity: BigInt
  granularity_gt: BigInt
  granularity_gte: BigInt
  granularity_in: [BigInt!]
  granularity_lt: BigInt
  granularity_lte: BigInt
  granularity_not: BigInt
  granularity_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  newSymbol: String
  newSymbol_contains: String
  newSymbol_contains_nocase: String
  newSymbol_ends_with: String
  newSymbol_ends_with_nocase: String
  newSymbol_gt: String
  newSymbol_gte: String
  newSymbol_in: [String!]
  newSymbol_lt: String
  newSymbol_lte: String
  newSymbol_not: String
  newSymbol_not_contains: String
  newSymbol_not_contains_nocase: String
  newSymbol_not_ends_with: String
  newSymbol_not_ends_with_nocase: String
  newSymbol_not_in: [String!]
  newSymbol_not_starts_with: String
  newSymbol_not_starts_with_nocase: String
  newSymbol_starts_with: String
  newSymbol_starts_with_nocase: String
  originalTokenAddress: Bytes
  originalTokenAddress_contains: Bytes
  originalTokenAddress_in: [Bytes!]
  originalTokenAddress_not: Bytes
  originalTokenAddress_not_contains: Bytes
  originalTokenAddress_not_in: [Bytes!]
  sideTokenAddress: Bytes
  sideTokenAddress_contains: Bytes
  sideTokenAddress_in: [Bytes!]
  sideTokenAddress_not: Bytes
  sideTokenAddress_not_contains: Bytes
  sideTokenAddress_not_in: [Bytes!]
  updatedAtTx: String
  updatedAtTx_: Transaction_filter
  updatedAtTx_contains: String
  updatedAtTx_contains_nocase: String
  updatedAtTx_ends_with: String
  updatedAtTx_ends_with_nocase: String
  updatedAtTx_gt: String
  updatedAtTx_gte: String
  updatedAtTx_in: [String!]
  updatedAtTx_lt: String
  updatedAtTx_lte: String
  updatedAtTx_not: String
  updatedAtTx_not_contains: String
  updatedAtTx_not_contains_nocase: String
  updatedAtTx_not_ends_with: String
  updatedAtTx_not_ends_with_nocase: String
  updatedAtTx_not_in: [String!]
  updatedAtTx_not_starts_with: String
  updatedAtTx_not_starts_with_nocase: String
  updatedAtTx_starts_with: String
  updatedAtTx_starts_with_nocase: String
}

enum SideToken_orderBy {
  createdAtTx
  granularity
  id
  newSymbol
  originalTokenAddress
  sideTokenAddress
  updatedAtTx
}

"""
The smart token represents a single reserve asset on a single pool.
For V1 pools, there is 1 smart token representing both reserve assets. For V2 pools, there are 2 smart tokens, one for each reserve asset.
"""
type SmartToken {
  addedToRegistryBlockNumber: Int
  addedToRegistryTransactionHash: Bytes

  """
  connectorTokens are the entity that holds the many-to-many relationship between the underlying token asset and the smart token
  """
  connectorTokens(
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]

  """
  The converter registry this smart token belongs to. Can be null if token is removed from th registry
  """
  currentConverterRegistry: ConverterRegistry

  """
  Number of decimal places for this token
  """
  decimals: Int

  """
  ID is smart token contract address
  """
  id: ID!

  """
  The AMM pool this smart token "belongs" to
  """
  liquidityPool: LiquidityPool!

  """
  Name of the smart token (set on the contract)
  """
  name: String

  """
  The contract/account that owns the SmartToken contract. This will typically be the converter registry
  """
  owner: String!

  """
  smartTokenType can be Relay or Liquid
  """
  smartTokenType: String

  """
  Symbol for the smart token asset (set on the contract)
  """
  symbol: String
}

input SmartToken_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  addedToRegistryBlockNumber: Int
  addedToRegistryBlockNumber_gt: Int
  addedToRegistryBlockNumber_gte: Int
  addedToRegistryBlockNumber_in: [Int!]
  addedToRegistryBlockNumber_lt: Int
  addedToRegistryBlockNumber_lte: Int
  addedToRegistryBlockNumber_not: Int
  addedToRegistryBlockNumber_not_in: [Int!]
  addedToRegistryTransactionHash: Bytes
  addedToRegistryTransactionHash_contains: Bytes
  addedToRegistryTransactionHash_in: [Bytes!]
  addedToRegistryTransactionHash_not: Bytes
  addedToRegistryTransactionHash_not_contains: Bytes
  addedToRegistryTransactionHash_not_in: [Bytes!]
  connectorTokens_: TokenSmartToken_filter
  currentConverterRegistry: String
  currentConverterRegistry_: ConverterRegistry_filter
  currentConverterRegistry_contains: String
  currentConverterRegistry_contains_nocase: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_ends_with_nocase: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_lt: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_not: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_not_contains_nocase: String
  currentConverterRegistry_not_ends_with: String
  currentConverterRegistry_not_ends_with_nocase: String
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_not_starts_with_nocase: String
  currentConverterRegistry_starts_with: String
  currentConverterRegistry_starts_with_nocase: String
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPool_: LiquidityPool_filter
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  owner: String
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  smartTokenType: String
  smartTokenType_contains: String
  smartTokenType_contains_nocase: String
  smartTokenType_ends_with: String
  smartTokenType_ends_with_nocase: String
  smartTokenType_gt: String
  smartTokenType_gte: String
  smartTokenType_in: [String!]
  smartTokenType_lt: String
  smartTokenType_lte: String
  smartTokenType_not: String
  smartTokenType_not_contains: String
  smartTokenType_not_contains_nocase: String
  smartTokenType_not_ends_with: String
  smartTokenType_not_ends_with_nocase: String
  smartTokenType_not_in: [String!]
  smartTokenType_not_starts_with: String
  smartTokenType_not_starts_with_nocase: String
  smartTokenType_starts_with: String
  smartTokenType_starts_with_nocase: String
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
}

enum SmartToken_orderBy {
  addedToRegistryBlockNumber
  addedToRegistryTransactionHash
  connectorTokens
  currentConverterRegistry
  decimals
  id
  liquidityPool
  name
  owner
  smartTokenType
  symbol
}

type Stake {
  amount: BigDecimal
  delegatedAmount: BigDecimal!
  id: ID!
  lockedUntil: Int
  user: User
  vestingAmount: BigDecimal!
}

enum StakeHistoryAction {
  """
  When a user delegates voting power to another user. This can also be for voting power that the user has through a vesting contract.
  """
  Delegate

  """
  Extending an existing stake. The amount of the stake remains the same, but the lockedUntil date increases.
  """
  ExtendStake

  """
  When a user withdraws their share of the Protocol fees that is shared amongst stakers
  """
  FeeWithdrawn

  """
  Increasing the amount of an existing stake. The lockedUntil date of this stake remains the same, but amount increases.
  """
  IncreaseStake

  """
  Voluntarily staking SOV (ie not staked through a vesting contract)
  """
  Stake

  """
  Unstake is early unstaking, when a user withdraws staked SOV before the lockedUntil date and incurs a slashing penalty.
  """
  Unstake

  """
  WithdrawStaked is when a user withdraws SOV from the staking contract after the unlock date, when the funds are no longer staked or locked
  """
  WithdrawStaked
}

"""
This entity is the granular history of user actions related to voluntary staking
"""
type StakeHistoryItem {
  action: StakeHistoryAction!
  amount: BigDecimal
  id: ID!
  lockedUntil: Int
  timestamp: Int!
  token: String
  transaction: Transaction!
  user: UserStakeHistory!
}

input StakeHistoryItem_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  action: StakeHistoryAction
  action_in: [StakeHistoryAction!]
  action_not: StakeHistoryAction
  action_not_in: [StakeHistoryAction!]
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedUntil: Int
  lockedUntil_gt: Int
  lockedUntil_gte: Int
  lockedUntil_in: [Int!]
  lockedUntil_lt: Int
  lockedUntil_lte: Int
  lockedUntil_not: Int
  lockedUntil_not_in: [Int!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: String
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  user: String
  user_: UserStakeHistory_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum StakeHistoryItem_orderBy {
  action
  amount
  id
  lockedUntil
  timestamp
  token
  transaction
  user
}

input Stake_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  delegatedAmount: BigDecimal
  delegatedAmount_gt: BigDecimal
  delegatedAmount_gte: BigDecimal
  delegatedAmount_in: [BigDecimal!]
  delegatedAmount_lt: BigDecimal
  delegatedAmount_lte: BigDecimal
  delegatedAmount_not: BigDecimal
  delegatedAmount_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedUntil: Int
  lockedUntil_gt: Int
  lockedUntil_gte: Int
  lockedUntil_in: [Int!]
  lockedUntil_lt: Int
  lockedUntil_lte: Int
  lockedUntil_not: Int
  lockedUntil_not_in: [Int!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  vestingAmount: BigDecimal
  vestingAmount_gt: BigDecimal
  vestingAmount_gte: BigDecimal
  vestingAmount_in: [BigDecimal!]
  vestingAmount_lt: BigDecimal
  vestingAmount_lte: BigDecimal
  vestingAmount_not: BigDecimal
  vestingAmount_not_in: [BigDecimal!]
}

enum Stake_orderBy {
  amount
  delegatedAmount
  id
  lockedUntil
  user
  vestingAmount
}

type Subscription {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  bitcoinTransfer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransfer
  bitcoinTransferBatchSending(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransferBatchSending
  bitcoinTransferBatchSendings(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BitcoinTransferBatchSending_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BitcoinTransferBatchSending_filter
  ): [BitcoinTransferBatchSending!]!
  bitcoinTransfers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BitcoinTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BitcoinTransfer_filter
  ): [BitcoinTransfer!]!
  borrow(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Borrow
  borrows(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Borrow_filter
  ): [Borrow!]!
  bridge(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bridge
  bridges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Bridge_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Bridge_filter
  ): [Bridge!]!
  candleStickDay(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickDay
  candleStickDays(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStickDay_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStickDay_filter
  ): [CandleStickDay!]!
  candleStickFifteenMinute(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickFifteenMinute
  candleStickFifteenMinutes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStickFifteenMinute_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStickFifteenMinute_filter
  ): [CandleStickFifteenMinute!]!
  candleStickFourHour(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickFourHour
  candleStickFourHours(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStickFourHour_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStickFourHour_filter
  ): [CandleStickFourHour!]!
  candleStickHour(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickHour
  candleStickHours(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStickHour_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStickHour_filter
  ): [CandleStickHour!]!
  candleStickMinute(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStickMinute
  candleStickMinutes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStickMinute_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStickMinute_filter
  ): [CandleStickMinute!]!
  closeWithDeposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithDeposit
  closeWithDeposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithDeposit_filter
  ): [CloseWithDeposit!]!
  closeWithSwap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithSwap
  closeWithSwaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithSwap_filter
  ): [CloseWithSwap!]!
  conversion(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Conversion_filter
  ): [Conversion!]!
  converterRegistries(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ConverterRegistry_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ConverterRegistry_filter
  ): [ConverterRegistry!]!
  converterRegistry(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConverterRegistry
  crossTransfer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CrossTransfer
  crossTransfers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CrossTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CrossTransfer_filter
  ): [CrossTransfer!]!
  deposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  depositCollateral(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositCollateral
  depositCollaterals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DepositCollateral_filter
  ): [DepositCollateral!]!
  deposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Deposit_filter
  ): [Deposit!]!
  fastBTCBridgeStat(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FastBTCBridgeStat
  fastBTCBridgeStats(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FastBTCBridgeStat_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FastBTCBridgeStat_filter
  ): [FastBTCBridgeStat!]!
  federation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Federation
  federations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Federation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Federation_filter
  ): [Federation!]!
  feeSharingTokensTransferred(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeSharingTokensTransferred
  feeSharingTokensTransferreds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeSharingTokensTransferred_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeSharingTokensTransferred_filter
  ): [FeeSharingTokensTransferred!]!
  icandleStick(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ICandleStick
  icandleSticks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ICandleStick_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ICandleStick_filter
  ): [ICandleStick!]!
  lendingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingHistoryItem
  lendingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingHistoryItem_filter
  ): [LendingHistoryItem!]!
  lendingPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingPool
  lendingPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingPool_filter
  ): [LendingPool!]!
  liquidate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidate
  liquidates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Liquidate_filter
  ): [Liquidate!]!
  liquidityHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityHistoryItem
  liquidityHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityHistoryItem_filter
  ): [LiquidityHistoryItem!]!
  liquidityMiningAllocationPoint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningAllocationPoint
  liquidityMiningAllocationPoints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityMiningAllocationPoint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityMiningAllocationPoint_filter
  ): [LiquidityMiningAllocationPoint!]!
  liquidityMiningGlobal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningGlobal
  liquidityMiningGlobals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityMiningGlobal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityMiningGlobal_filter
  ): [LiquidityMiningGlobal!]!
  liquidityPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPoolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolToken
  liquidityPoolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]!
  liquidityPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPool_filter
  ): [LiquidityPool!]!
  loan(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loans(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Loan_filter
  ): [Loan!]!
  marginOrderCanceled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderCanceled
  marginOrderCanceleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MarginOrderCanceled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MarginOrderCanceled_filter
  ): [MarginOrderCanceled!]!
  marginOrderFilled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderFilled
  marginOrderFilleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MarginOrderFilled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MarginOrderFilled_filter
  ): [MarginOrderFilled!]!
  newBitcoinTransferIncoming(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewBitcoinTransferIncoming
  newBitcoinTransferIncomings(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NewBitcoinTransferIncoming_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NewBitcoinTransferIncoming_filter
  ): [NewBitcoinTransferIncoming!]!
  orderCanceled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCanceled
  orderCanceleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderCanceled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderCanceled_filter
  ): [OrderCanceled!]!
  orderCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCreated
  orderCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderCreated_filter
  ): [OrderCreated!]!
  orderFilled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderFilled
  orderFilleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderFilled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderFilled_filter
  ): [OrderFilled!]!
  ownerUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnerUpdate
  ownerUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OwnerUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OwnerUpdate_filter
  ): [OwnerUpdate!]!
  payBorrowingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayBorrowingFee
  payBorrowingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayBorrowingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayBorrowingFee_filter
  ): [PayBorrowingFee!]!
  payInterestTransfer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayInterestTransfer
  payInterestTransfers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayInterestTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayInterestTransfer_filter
  ): [PayInterestTransfer!]!
  payLendingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayLendingFee
  payLendingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayLendingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayLendingFee_filter
  ): [PayLendingFee!]!
  payTradingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayTradingFee
  payTradingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayTradingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayTradingFee_filter
  ): [PayTradingFee!]!
  poolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolToken_filter
  ): [PoolToken!]!
  proposal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Proposal_filter
  ): [Proposal!]!
  protocolStats(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ProtocolStats_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ProtocolStats_filter
  ): [ProtocolStats!]!
  protocolWithdrawFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProtocolWithdrawFee
  protocolWithdrawFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ProtocolWithdrawFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ProtocolWithdrawFee_filter
  ): [ProtocolWithdrawFee!]!
  rewardsEarnedHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardsEarnedHistoryItem
  rewardsEarnedHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardsEarnedHistoryItem_filter
  ): [RewardsEarnedHistoryItem!]!
  rollover(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Rollover
  rollovers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Rollover_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Rollover_filter
  ): [Rollover!]!
  sideToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SideToken
  sideTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SideToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SideToken_filter
  ): [SideToken!]!
  smartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartToken
  smartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SmartToken_filter
  ): [SmartToken!]!
  stake(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Stake
  stakeHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistoryItem
  stakeHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StakeHistoryItem_filter
  ): [StakeHistoryItem!]!
  stakes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Stake_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Stake_filter
  ): [Stake!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenSmartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSmartToken
  tokenSmartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  tokensStaked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensStaked
  tokensStakeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokensStaked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokensStaked_filter
  ): [TokensStaked!]!
  trade(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Trade_filter
  ): [Trade!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userLendingHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLendingHistory_filter
  ): [UserLendingHistory!]!
  userLendingHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLendingHistory
  userLiquidityHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLiquidityHistory_filter
  ): [UserLiquidityHistory!]!
  userLiquidityHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLiquidityHistory
  userRewardsEarnedHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserRewardsEarnedHistory_filter
  ): [UserRewardsEarnedHistory!]!
  userRewardsEarnedHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserRewardsEarnedHistory
  userStakeHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserStakeHistory_filter
  ): [UserStakeHistory!]!
  userStakeHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserStakeHistory
  userTotal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserTotal
  userTotals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserTotal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserTotal_filter
  ): [UserTotal!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  vestingContract(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingContract
  vestingContracts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingContract_filter
  ): [VestingContract!]!
  vestingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingHistoryItem
  vestingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingHistoryItem_filter
  ): [VestingHistoryItem!]!
  voteCast(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteCast
  voteCasts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VoteCast_filter
  ): [VoteCast!]!
  withdrawal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawal
  withdrawals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Withdrawal_filter
  ): [Withdrawal!]!
}

"""
The Swap entity is an aggregated entity of the individual Conversion events in a transaction.
For example, if a User swaps XUSD to SOV, there will be 2 Conversion events through 2 AMMs (XUSD-BTC and BTC-SOV) in one transaction. These two Conversions are aggregated here.
"""
type Swap {
  fromAmount: BigDecimal!

  """
  Token the user converted
  """
  fromToken: Token!

  """
  Transaction hash of this swap
  """
  id: ID!

  """
  Not in use - this property is always false. It is kept for backwards compatibility and will be deprecated
  """
  isLimit: Boolean!

  """
  The number of AMM Conversions involved in this swap (this is primarily for debugging purposes)
  """
  numConversions: Int!

  """
  Rate is calculated as toAmount / fromAmount
  """
  rate: BigDecimal!
  swapType: SwapType
  timestamp: Int!
  toAmount: BigDecimal!

  """
  Token the user received
  """
  toToken: Token!
  transaction: Transaction!

  """
  If this swap was initiated by a contract (for example as part of a Margin Trade), User will be null.
  Otherwise, this is the user that initiated the transaction.
  """
  user: User
}

enum SwapType {
  Limit
  Market
  Other
}

input Swap_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  fromAmount: BigDecimal
  fromAmount_gt: BigDecimal
  fromAmount_gte: BigDecimal
  fromAmount_in: [BigDecimal!]
  fromAmount_lt: BigDecimal
  fromAmount_lte: BigDecimal
  fromAmount_not: BigDecimal
  fromAmount_not_in: [BigDecimal!]
  fromToken: String
  fromToken_: Token_filter
  fromToken_contains: String
  fromToken_contains_nocase: String
  fromToken_ends_with: String
  fromToken_ends_with_nocase: String
  fromToken_gt: String
  fromToken_gte: String
  fromToken_in: [String!]
  fromToken_lt: String
  fromToken_lte: String
  fromToken_not: String
  fromToken_not_contains: String
  fromToken_not_contains_nocase: String
  fromToken_not_ends_with: String
  fromToken_not_ends_with_nocase: String
  fromToken_not_in: [String!]
  fromToken_not_starts_with: String
  fromToken_not_starts_with_nocase: String
  fromToken_starts_with: String
  fromToken_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isLimit: Boolean
  isLimit_in: [Boolean!]
  isLimit_not: Boolean
  isLimit_not_in: [Boolean!]
  numConversions: Int
  numConversions_gt: Int
  numConversions_gte: Int
  numConversions_in: [Int!]
  numConversions_lt: Int
  numConversions_lte: Int
  numConversions_not: Int
  numConversions_not_in: [Int!]
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  swapType: SwapType
  swapType_in: [SwapType!]
  swapType_not: SwapType
  swapType_not_in: [SwapType!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  toAmount: BigDecimal
  toAmount_gt: BigDecimal
  toAmount_gte: BigDecimal
  toAmount_in: [BigDecimal!]
  toAmount_lt: BigDecimal
  toAmount_lte: BigDecimal
  toAmount_not: BigDecimal
  toAmount_not_in: [BigDecimal!]
  toToken: String
  toToken_: Token_filter
  toToken_contains: String
  toToken_contains_nocase: String
  toToken_ends_with: String
  toToken_ends_with_nocase: String
  toToken_gt: String
  toToken_gte: String
  toToken_in: [String!]
  toToken_lt: String
  toToken_lte: String
  toToken_not: String
  toToken_not_contains: String
  toToken_not_contains_nocase: String
  toToken_not_ends_with: String
  toToken_not_ends_with_nocase: String
  toToken_not_in: [String!]
  toToken_not_starts_with: String
  toToken_not_starts_with_nocase: String
  toToken_starts_with: String
  toToken_starts_with_nocase: String
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum Swap_orderBy {
  fromAmount
  fromToken
  id
  isLimit
  numConversions
  rate
  swapType
  timestamp
  toAmount
  toToken
  transaction
  user
}

"""
This entity represents an ERC20 token traded on the Sovryn Protocol
"""
type Token {
  """
  The total volume of this token that has been traded through the protocol quoted in BTC
  """
  btcVolume: BigDecimal!

  """
  CrossTransfers: cross transfers list (currently only relevant to SOV)
  """
  crossTransfers(
    first: Int = 100
    orderBy: CrossTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: CrossTransfer_filter
  ): [CrossTransfer!]
  currentConverterRegistry: ConverterRegistry

  """
  Number of decimal places used in the smart contract for this token
  """
  decimals: Int

  """
  Does this token have an AMM pool with rBTC as the other reserve asset?
  """
  hasBtcPool: Boolean

  """
  Does this token have an AMM pool with the protocol stablecoin as the other reserve asset?
  """
  hasStablecoinPool: Boolean

  """
  The ID is the contract address of the token on RSK
  """
  id: ID!

  """
  lastPriceBtc is the last traded price of this token in BTC
  """
  lastPriceBtc: BigDecimal!

  """
  lastPriceUsd is the last traded price of this token in USD
  """
  lastPriceUsd: BigDecimal!

  """
  The addresses of the LiquidityPools where this token is a reserve asset
  """
  liquidityPools(
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]
  name: String

  """
  Internal use only - previous BTC price used for candleSticks
  """
  prevPriceBtc: BigDecimal!

  """
  Internal use only - previous BTC price used for candleSticks
  """
  prevPriceUsd: BigDecimal!

  """
  The smart tokens that have this token as an underlying asset
  """
  smartTokens(
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]
  symbol: String

  """
  The total volume of this token that has been traded through the protocol
  """
  tokenVolume: BigDecimal!

  """
  The total volume of this token that has been traded through the protocol quoted in USD
  """
  usdVolume: BigDecimal!
  version: Int
}

"""
This entity is to store a many-to-many relationship between tokens and smart tokens
"""
type TokenSmartToken {
  """
  ID is token address + smart token address
  """
  id: ID!
  smartToken: SmartToken!

  """
  token is the underlying asset represented by the smartToken
  """
  token: Token!
}

input TokenSmartToken_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  smartToken: String
  smartToken_: SmartToken_filter
  smartToken_contains: String
  smartToken_contains_nocase: String
  smartToken_ends_with: String
  smartToken_ends_with_nocase: String
  smartToken_gt: String
  smartToken_gte: String
  smartToken_in: [String!]
  smartToken_lt: String
  smartToken_lte: String
  smartToken_not: String
  smartToken_not_contains: String
  smartToken_not_contains_nocase: String
  smartToken_not_ends_with: String
  smartToken_not_ends_with_nocase: String
  smartToken_not_in: [String!]
  smartToken_not_starts_with: String
  smartToken_not_starts_with_nocase: String
  smartToken_starts_with: String
  smartToken_starts_with_nocase: String
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum TokenSmartToken_orderBy {
  id
  smartToken
  token
}

input Token_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  btcVolume: BigDecimal
  btcVolume_gt: BigDecimal
  btcVolume_gte: BigDecimal
  btcVolume_in: [BigDecimal!]
  btcVolume_lt: BigDecimal
  btcVolume_lte: BigDecimal
  btcVolume_not: BigDecimal
  btcVolume_not_in: [BigDecimal!]
  crossTransfers_: CrossTransfer_filter
  currentConverterRegistry: String
  currentConverterRegistry_: ConverterRegistry_filter
  currentConverterRegistry_contains: String
  currentConverterRegistry_contains_nocase: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_ends_with_nocase: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_lt: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_not: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_not_contains_nocase: String
  currentConverterRegistry_not_ends_with: String
  currentConverterRegistry_not_ends_with_nocase: String
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_not_starts_with_nocase: String
  currentConverterRegistry_starts_with: String
  currentConverterRegistry_starts_with_nocase: String
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  hasBtcPool: Boolean
  hasBtcPool_in: [Boolean!]
  hasBtcPool_not: Boolean
  hasBtcPool_not_in: [Boolean!]
  hasStablecoinPool: Boolean
  hasStablecoinPool_in: [Boolean!]
  hasStablecoinPool_not: Boolean
  hasStablecoinPool_not_in: [Boolean!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastPriceBtc: BigDecimal
  lastPriceBtc_gt: BigDecimal
  lastPriceBtc_gte: BigDecimal
  lastPriceBtc_in: [BigDecimal!]
  lastPriceBtc_lt: BigDecimal
  lastPriceBtc_lte: BigDecimal
  lastPriceBtc_not: BigDecimal
  lastPriceBtc_not_in: [BigDecimal!]
  lastPriceUsd: BigDecimal
  lastPriceUsd_gt: BigDecimal
  lastPriceUsd_gte: BigDecimal
  lastPriceUsd_in: [BigDecimal!]
  lastPriceUsd_lt: BigDecimal
  lastPriceUsd_lte: BigDecimal
  lastPriceUsd_not: BigDecimal
  lastPriceUsd_not_in: [BigDecimal!]
  liquidityPools_: LiquidityPoolToken_filter
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  prevPriceBtc: BigDecimal
  prevPriceBtc_gt: BigDecimal
  prevPriceBtc_gte: BigDecimal
  prevPriceBtc_in: [BigDecimal!]
  prevPriceBtc_lt: BigDecimal
  prevPriceBtc_lte: BigDecimal
  prevPriceBtc_not: BigDecimal
  prevPriceBtc_not_in: [BigDecimal!]
  prevPriceUsd: BigDecimal
  prevPriceUsd_gt: BigDecimal
  prevPriceUsd_gte: BigDecimal
  prevPriceUsd_in: [BigDecimal!]
  prevPriceUsd_lt: BigDecimal
  prevPriceUsd_lte: BigDecimal
  prevPriceUsd_not: BigDecimal
  prevPriceUsd_not_in: [BigDecimal!]
  smartTokens_: TokenSmartToken_filter
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  tokenVolume: BigDecimal
  tokenVolume_gt: BigDecimal
  tokenVolume_gte: BigDecimal
  tokenVolume_in: [BigDecimal!]
  tokenVolume_lt: BigDecimal
  tokenVolume_lte: BigDecimal
  tokenVolume_not: BigDecimal
  tokenVolume_not_in: [BigDecimal!]
  usdVolume: BigDecimal
  usdVolume_gt: BigDecimal
  usdVolume_gte: BigDecimal
  usdVolume_in: [BigDecimal!]
  usdVolume_lt: BigDecimal
  usdVolume_lte: BigDecimal
  usdVolume_not: BigDecimal
  usdVolume_not_in: [BigDecimal!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum Token_orderBy {
  btcVolume
  crossTransfers
  currentConverterRegistry
  decimals
  hasBtcPool
  hasStablecoinPool
  id
  lastPriceBtc
  lastPriceUsd
  liquidityPools
  name
  prevPriceBtc
  prevPriceUsd
  smartTokens
  symbol
  tokenVolume
  usdVolume
  version
}

"""
This is an event emitted from the staking contract when tokens are staked, either by a user or by a vesting contract
If tokens are staked by a vesting contract, there may be multiple tokens staked event per transaction (eg if tokensa are vested over 10 months, there would be 10 TokensStaked events each with a different lockedUntil date)
We have improvements planned to better represent staking on our subgraph.
"""
type TokensStaked {
  """
  The amount of SOV staked in this event (as mentioned above, there can be multiple TokensStaked events per transaction)
  """
  amount: BigDecimal!
  emittedBy: Bytes!

  """
  ID is transaction hash + log index
  """
  id: ID!

  """
  If this is false, the tokens were staked by a vesting contract, and not voluntarily by a user
  """
  isUserStaked: Boolean!

  """
  The date when these tokens will unlock
  A user/vesting contract can have multiple stakes with different lockedUntil dates
  """
  lockedUntil: Int!

  """
  The staker is either a user address or a vesting contract address
  """
  staker: Bytes!
  timestamp: Int!

  """
  The total amount staked for this specific user until this specific lockedUntil date
  """
  totalStaked: BigDecimal!
  transaction: Transaction!

  """
  If tokens were staked by a vesting contract, user property will be null
  """
  user: User
}

input TokensStaked_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isUserStaked: Boolean
  isUserStaked_in: [Boolean!]
  isUserStaked_not: Boolean
  isUserStaked_not_in: [Boolean!]
  lockedUntil: Int
  lockedUntil_gt: Int
  lockedUntil_gte: Int
  lockedUntil_in: [Int!]
  lockedUntil_lt: Int
  lockedUntil_lte: Int
  lockedUntil_not: Int
  lockedUntil_not_in: [Int!]
  staker: Bytes
  staker_contains: Bytes
  staker_in: [Bytes!]
  staker_not: Bytes
  staker_not_contains: Bytes
  staker_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalStaked: BigDecimal
  totalStaked_gt: BigDecimal
  totalStaked_gte: BigDecimal
  totalStaked_in: [BigDecimal!]
  totalStaked_lt: BigDecimal
  totalStaked_lte: BigDecimal
  totalStaked_not: BigDecimal
  totalStaked_not_in: [BigDecimal!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum TokensStaked_orderBy {
  amount
  emittedBy
  id
  isUserStaked
  lockedUntil
  staker
  timestamp
  totalStaked
  transaction
  user
}

"""
Granular event data for the Loan entity. Emitted when a user opens a Margin Trade
"""
type Trade {
  borrowedAmount: BigDecimal!
  collateralToken: Token!
  currentLeverage: BigDecimal!
  emittedBy: Bytes!
  entryLeverage: BigDecimal!
  entryPrice: BigDecimal!
  id: ID!
  interestRate: BigDecimal!
  lender: Bytes!
  loanId: Loan!
  loanToken: Token!
  positionSize: BigDecimal!
  settlementDate: Int!
  timestamp: Int!
  transaction: Transaction!
  user: User!
}

input Trade_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  borrowedAmount: BigDecimal
  borrowedAmount_gt: BigDecimal
  borrowedAmount_gte: BigDecimal
  borrowedAmount_in: [BigDecimal!]
  borrowedAmount_lt: BigDecimal
  borrowedAmount_lte: BigDecimal
  borrowedAmount_not: BigDecimal
  borrowedAmount_not_in: [BigDecimal!]
  collateralToken: String
  collateralToken_: Token_filter
  collateralToken_contains: String
  collateralToken_contains_nocase: String
  collateralToken_ends_with: String
  collateralToken_ends_with_nocase: String
  collateralToken_gt: String
  collateralToken_gte: String
  collateralToken_in: [String!]
  collateralToken_lt: String
  collateralToken_lte: String
  collateralToken_not: String
  collateralToken_not_contains: String
  collateralToken_not_contains_nocase: String
  collateralToken_not_ends_with: String
  collateralToken_not_ends_with_nocase: String
  collateralToken_not_in: [String!]
  collateralToken_not_starts_with: String
  collateralToken_not_starts_with_nocase: String
  collateralToken_starts_with: String
  collateralToken_starts_with_nocase: String
  currentLeverage: BigDecimal
  currentLeverage_gt: BigDecimal
  currentLeverage_gte: BigDecimal
  currentLeverage_in: [BigDecimal!]
  currentLeverage_lt: BigDecimal
  currentLeverage_lte: BigDecimal
  currentLeverage_not: BigDecimal
  currentLeverage_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  entryLeverage: BigDecimal
  entryLeverage_gt: BigDecimal
  entryLeverage_gte: BigDecimal
  entryLeverage_in: [BigDecimal!]
  entryLeverage_lt: BigDecimal
  entryLeverage_lte: BigDecimal
  entryLeverage_not: BigDecimal
  entryLeverage_not_in: [BigDecimal!]
  entryPrice: BigDecimal
  entryPrice_gt: BigDecimal
  entryPrice_gte: BigDecimal
  entryPrice_in: [BigDecimal!]
  entryPrice_lt: BigDecimal
  entryPrice_lte: BigDecimal
  entryPrice_not: BigDecimal
  entryPrice_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  interestRate: BigDecimal
  interestRate_gt: BigDecimal
  interestRate_gte: BigDecimal
  interestRate_in: [BigDecimal!]
  interestRate_lt: BigDecimal
  interestRate_lte: BigDecimal
  interestRate_not: BigDecimal
  interestRate_not_in: [BigDecimal!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanId: String
  loanId_: Loan_filter
  loanId_contains: String
  loanId_contains_nocase: String
  loanId_ends_with: String
  loanId_ends_with_nocase: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_contains_nocase: String
  loanId_not_ends_with: String
  loanId_not_ends_with_nocase: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_not_starts_with_nocase: String
  loanId_starts_with: String
  loanId_starts_with_nocase: String
  loanToken: String
  loanToken_: Token_filter
  loanToken_contains: String
  loanToken_contains_nocase: String
  loanToken_ends_with: String
  loanToken_ends_with_nocase: String
  loanToken_gt: String
  loanToken_gte: String
  loanToken_in: [String!]
  loanToken_lt: String
  loanToken_lte: String
  loanToken_not: String
  loanToken_not_contains: String
  loanToken_not_contains_nocase: String
  loanToken_not_ends_with: String
  loanToken_not_ends_with_nocase: String
  loanToken_not_in: [String!]
  loanToken_not_starts_with: String
  loanToken_not_starts_with_nocase: String
  loanToken_starts_with: String
  loanToken_starts_with_nocase: String
  positionSize: BigDecimal
  positionSize_gt: BigDecimal
  positionSize_gte: BigDecimal
  positionSize_in: [BigDecimal!]
  positionSize_lt: BigDecimal
  positionSize_lte: BigDecimal
  positionSize_not: BigDecimal
  positionSize_not_in: [BigDecimal!]
  settlementDate: Int
  settlementDate_gt: Int
  settlementDate_gte: Int
  settlementDate_in: [Int!]
  settlementDate_lt: Int
  settlementDate_lte: Int
  settlementDate_not: Int
  settlementDate_not_in: [Int!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum Trade_orderBy {
  borrowedAmount
  collateralToken
  currentLeverage
  emittedBy
  entryLeverage
  entryPrice
  id
  interestRate
  lender
  loanId
  loanToken
  positionSize
  settlementDate
  timestamp
  transaction
  user
}

"""
Transaction data, including hash and timestamp
"""
type Transaction {
  blockNumber: Int!

  """
  The account that initiated this transaction. This must be an Account and not a Contract.
  """
  from: User!
  functionSignature: String!
  gasLimit: BigInt!
  gasPrice: BigInt!

  """
  ID is transaction hash
  """
  id: ID!

  """
  The index of this transaction within the block
  """
  index: Int!

  """
  The timestamp the transaction was confirmed
  """
  timestamp: Int!

  """
  The contract the user interacted with
  """
  to: Bytes
  value: BigInt!
}

input Transaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  blockNumber: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_in: [Int!]
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_not: Int
  blockNumber_not_in: [Int!]
  from: String
  from_: User_filter
  from_contains: String
  from_contains_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_gt: String
  from_gte: String
  from_in: [String!]
  from_lt: String
  from_lte: String
  from_not: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_not_in: [String!]
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  functionSignature: String
  functionSignature_contains: String
  functionSignature_contains_nocase: String
  functionSignature_ends_with: String
  functionSignature_ends_with_nocase: String
  functionSignature_gt: String
  functionSignature_gte: String
  functionSignature_in: [String!]
  functionSignature_lt: String
  functionSignature_lte: String
  functionSignature_not: String
  functionSignature_not_contains: String
  functionSignature_not_contains_nocase: String
  functionSignature_not_ends_with: String
  functionSignature_not_ends_with_nocase: String
  functionSignature_not_in: [String!]
  functionSignature_not_starts_with: String
  functionSignature_not_starts_with_nocase: String
  functionSignature_starts_with: String
  functionSignature_starts_with_nocase: String
  gasLimit: BigInt
  gasLimit_gt: BigInt
  gasLimit_gte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_lt: BigInt
  gasLimit_lte: BigInt
  gasLimit_not: BigInt
  gasLimit_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  to: Bytes
  to_contains: Bytes
  to_in: [Bytes!]
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum Transaction_orderBy {
  blockNumber
  from
  functionSignature
  gasLimit
  gasPrice
  id
  index
  timestamp
  to
  value
}

"""
This entity contains all user-specific data displayed on the dapp, including all user actions
"""
type User {
  """
  FastBTCBridge transfers from BTC to RSK
  """
  bitcoinTransfers(
    first: Int = 100
    orderBy: BitcoinTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: BitcoinTransfer_filter
  ): [BitcoinTransfer!]

  """
  An array of Borrow events
  """
  borrows(
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Borrow_filter
  ): [Borrow!]

  """
  Timestamp of User's first interaction with the protocol (first transaction)
  """
  createdAtTimestamp: Int!

  """
  EVM Bridge transfers
  """
  crossChainTransfer(
    first: Int = 100
    orderBy: CrossTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: CrossTransfer_filter
  ): [CrossTransfer!]

  """
  Stakes the user owns, including stakes from Vesting Contracts
  """
  currentStakes(
    first: Int = 100
    orderBy: Stake_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Stake_filter
  ): [Stake!]
  fastBTCBridgeStats(
    first: Int = 100
    orderBy: FastBTCBridgeStat_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: FastBTCBridgeStat_filter
  ): [FastBTCBridgeStat!]

  """
  ID is user wallet address
  """
  id: ID!

  """
  The lending history of a User, separated into lending pools. Explore the UserLendingHistory entity for more granular events.
  """
  lendingHistory(
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserLendingHistory_filter
  ): [UserLendingHistory!]

  """
  An array of Liquidation events linked to this user
  """
  liquidations(
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Liquidate_filter
  ): [Liquidate!]

  """
  An array of all LiquidityAdded and LiquidityRemoved events
  """
  liquidityHistory(
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserLiquidityHistory_filter
  ): [UserLiquidityHistory!]

  """
  All loans taken out by this user, including for margin trading and for borrowing
  """
  loans(
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Loan_filter
  ): [Loan!]

  """
  The Rewards history of one user. This includes actions like EarnReward, RewardSovDeposited, and RewardSovStaked.
  Explore the UserRewardsEarnedHistory entity for more granular events
  """
  rewardsEarnedHistory(
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserRewardsEarnedHistory_filter
  ): [UserRewardsEarnedHistory!]

  """
  The SOV Staking history of a user. This includes withdrawing vested tokens. Explore the UserStakeHistory entity for more granular events.
  """
  stakeHistory(
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserStakeHistory_filter
  ): [UserStakeHistory!]

  """
  Swaps here refers to only user-triggered swaps. For example, a swap that is part of a margin trade would not be included.
  Swaps involving multiple amm pools are stored as a single swap, comprised of multiple Conversion events
  """
  swaps(
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Swap_filter
  ): [Swap!]

  """
  An array of margin trade Trade events
  """
  trades(
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Trade_filter
  ): [Trade!]

  """
  Transactions initiated by this user
  """
  transactions(
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Transaction_filter
  ): [Transaction!]

  """
  See UserTotals entity for full documentation
  """
  userTotals: UserTotal

  """
  Vesting contracts owned by User, labelled by type
  """
  vestingContracts(
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VestingContract_filter
  ): [VestingContract!]

  """
  Voting history of User
  """
  votes(
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VoteCast_filter
  ): [VoteCast!]
}

"""
This entity contains the lending and unlending history of one User
"""
type UserLendingHistory {
  """
  ID is userAddress + lendingPoolAddress (lendingPool in this case is the lending pool token)
  """
  id: ID!

  """
  Granular Lend/UnLend events. Derived from Mint/Burn events on the contracts
  """
  lendingHistory(
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LendingHistoryItem_filter
  ): [LendingHistoryItem!]
  lendingPool: LendingPool!

  """
  Total volume this User has lent to this pool over all time (in the underlying asset currency, ie rBTC for the rBTC lending pool)
  """
  totalLendVolume: BigDecimal!

  """
  Total volume this User has withdrawn from this pool over all time
  """
  totalUnlendVolume: BigDecimal!
  user: User!
}

input UserLendingHistory_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lendingHistory_: LendingHistoryItem_filter
  lendingPool: String
  lendingPool_: LendingPool_filter
  lendingPool_contains: String
  lendingPool_contains_nocase: String
  lendingPool_ends_with: String
  lendingPool_ends_with_nocase: String
  lendingPool_gt: String
  lendingPool_gte: String
  lendingPool_in: [String!]
  lendingPool_lt: String
  lendingPool_lte: String
  lendingPool_not: String
  lendingPool_not_contains: String
  lendingPool_not_contains_nocase: String
  lendingPool_not_ends_with: String
  lendingPool_not_ends_with_nocase: String
  lendingPool_not_in: [String!]
  lendingPool_not_starts_with: String
  lendingPool_not_starts_with_nocase: String
  lendingPool_starts_with: String
  lendingPool_starts_with_nocase: String
  totalLendVolume: BigDecimal
  totalLendVolume_gt: BigDecimal
  totalLendVolume_gte: BigDecimal
  totalLendVolume_in: [BigDecimal!]
  totalLendVolume_lt: BigDecimal
  totalLendVolume_lte: BigDecimal
  totalLendVolume_not: BigDecimal
  totalLendVolume_not_in: [BigDecimal!]
  totalUnlendVolume: BigDecimal
  totalUnlendVolume_gt: BigDecimal
  totalUnlendVolume_gte: BigDecimal
  totalUnlendVolume_in: [BigDecimal!]
  totalUnlendVolume_lt: BigDecimal
  totalUnlendVolume_lte: BigDecimal
  totalUnlendVolume_not: BigDecimal
  totalUnlendVolume_not_in: [BigDecimal!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum UserLendingHistory_orderBy {
  id
  lendingHistory
  lendingPool
  totalLendVolume
  totalUnlendVolume
  user
}

"""
This entity stores one User's history of adding and removing liquidity from one AMM pool
"""
type UserLiquidityHistory {
  """
  The ID is userAddress + '-' + smartToken
  Liquidity Pool address is not used here because when a liquidity pool is updated the address changes, but the smart token address remains the same.
  """
  id: ID!

  """
  Granular transaction history for transactions adding or removing liquidity from an AMM pool
  """
  liquidityHistory(
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityHistoryItem_filter
  ): [LiquidityHistoryItem!]

  """
  This is the pool token (sometimes called smart token), not the liquidity pool address
  """
  poolToken: PoolToken!

  """
  Asset0 is defined on the LiquidityPool.
  These totals are amounts added and removed over all time. These values are used to calculate a user's PnL from liquidity provision.
  """
  totalAsset0LiquidityAdded: BigDecimal!
  totalAsset0LiquidityRemoved: BigDecimal!

  """
  Asset1 is defined on the LiquidityPool
  These totals are amounts added and removed over all time. These values are used to calculate a user's PnL from liquidity provision.
  """
  totalAsset1LiquidityAdded: BigDecimal!
  totalAsset1LiquidityRemoved: BigDecimal!
  user: User!
}

input UserLiquidityHistory_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityHistory_: LiquidityHistoryItem_filter
  poolToken: String
  poolToken_: PoolToken_filter
  poolToken_contains: String
  poolToken_contains_nocase: String
  poolToken_ends_with: String
  poolToken_ends_with_nocase: String
  poolToken_gt: String
  poolToken_gte: String
  poolToken_in: [String!]
  poolToken_lt: String
  poolToken_lte: String
  poolToken_not: String
  poolToken_not_contains: String
  poolToken_not_contains_nocase: String
  poolToken_not_ends_with: String
  poolToken_not_ends_with_nocase: String
  poolToken_not_in: [String!]
  poolToken_not_starts_with: String
  poolToken_not_starts_with_nocase: String
  poolToken_starts_with: String
  poolToken_starts_with_nocase: String
  totalAsset0LiquidityAdded: BigDecimal
  totalAsset0LiquidityAdded_gt: BigDecimal
  totalAsset0LiquidityAdded_gte: BigDecimal
  totalAsset0LiquidityAdded_in: [BigDecimal!]
  totalAsset0LiquidityAdded_lt: BigDecimal
  totalAsset0LiquidityAdded_lte: BigDecimal
  totalAsset0LiquidityAdded_not: BigDecimal
  totalAsset0LiquidityAdded_not_in: [BigDecimal!]
  totalAsset0LiquidityRemoved: BigDecimal
  totalAsset0LiquidityRemoved_gt: BigDecimal
  totalAsset0LiquidityRemoved_gte: BigDecimal
  totalAsset0LiquidityRemoved_in: [BigDecimal!]
  totalAsset0LiquidityRemoved_lt: BigDecimal
  totalAsset0LiquidityRemoved_lte: BigDecimal
  totalAsset0LiquidityRemoved_not: BigDecimal
  totalAsset0LiquidityRemoved_not_in: [BigDecimal!]
  totalAsset1LiquidityAdded: BigDecimal
  totalAsset1LiquidityAdded_gt: BigDecimal
  totalAsset1LiquidityAdded_gte: BigDecimal
  totalAsset1LiquidityAdded_in: [BigDecimal!]
  totalAsset1LiquidityAdded_lt: BigDecimal
  totalAsset1LiquidityAdded_lte: BigDecimal
  totalAsset1LiquidityAdded_not: BigDecimal
  totalAsset1LiquidityAdded_not_in: [BigDecimal!]
  totalAsset1LiquidityRemoved: BigDecimal
  totalAsset1LiquidityRemoved_gt: BigDecimal
  totalAsset1LiquidityRemoved_gte: BigDecimal
  totalAsset1LiquidityRemoved_in: [BigDecimal!]
  totalAsset1LiquidityRemoved_lt: BigDecimal
  totalAsset1LiquidityRemoved_lte: BigDecimal
  totalAsset1LiquidityRemoved_not: BigDecimal
  totalAsset1LiquidityRemoved_not_in: [BigDecimal!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum UserLiquidityHistory_orderBy {
  id
  liquidityHistory
  poolToken
  totalAsset0LiquidityAdded
  totalAsset0LiquidityRemoved
  totalAsset1LiquidityAdded
  totalAsset1LiquidityRemoved
  user
}

"""
This entity contains the history, fees and totals regarding one users' SOV rewards
"""
type UserRewardsEarnedHistory {
  """
  SOV rewards earned from margin trading, but not yet claimed and vested
  Incremented by EarnReward events, and set to 0 by TokensStaked events on the LockedSOV contract
  """
  availableTradingRewards: BigDecimal!
  id: ID!

  """
  Granular events for transaction where a reward is earned
  """
  rewardsEarnedHistory(
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: RewardsEarnedHistoryItem_filter
  ): [RewardsEarnedHistoryItem!]

  """
  The total protocol fees this user has earned and withdrawn, quoted in RBTC.
  Fees can be paid out in different tokens (usually RBTC and SOV).
  This is the total amount, converted to RBTC using the rate at the time of transaction.
  Incremented by UserFeeWithdrawn
  """
  totalFeeWithdrawn: BigDecimal!

  """
  This is the total of all EarnReward and RewardClaimed events
  """
  totalFeesAndRewardsEarned: BigDecimal!

  """
  The total liquidity mining rewards the user has claimed, earned from the lending pools.
  Incremented by RewardClaimed, where poolToken is a lending pool token
  """
  totalLendingRewards: BigDecimal!

  """
  The total liquidity mining rewards the user has claimed, earned from the amm pools.
  Incremented by RewardClaimed, where poolToken is an amm pool token
  """
  totalLiquidityRewards: BigDecimal!

  """
  Total liquid SOV rewards the user has earned through staking.
  Incremented by RewardWithdrawn
  """
  totalStakingRewards: BigDecimal!

  """
  Sum of all SOV rewards earned from margin trading.
  Incremented by EarnReward events
  """
  totalTradingRewards: BigDecimal!
  user: User!
}

input UserRewardsEarnedHistory_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  availableTradingRewards: BigDecimal
  availableTradingRewards_gt: BigDecimal
  availableTradingRewards_gte: BigDecimal
  availableTradingRewards_in: [BigDecimal!]
  availableTradingRewards_lt: BigDecimal
  availableTradingRewards_lte: BigDecimal
  availableTradingRewards_not: BigDecimal
  availableTradingRewards_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  rewardsEarnedHistory_: RewardsEarnedHistoryItem_filter
  totalFeeWithdrawn: BigDecimal
  totalFeeWithdrawn_gt: BigDecimal
  totalFeeWithdrawn_gte: BigDecimal
  totalFeeWithdrawn_in: [BigDecimal!]
  totalFeeWithdrawn_lt: BigDecimal
  totalFeeWithdrawn_lte: BigDecimal
  totalFeeWithdrawn_not: BigDecimal
  totalFeeWithdrawn_not_in: [BigDecimal!]
  totalFeesAndRewardsEarned: BigDecimal
  totalFeesAndRewardsEarned_gt: BigDecimal
  totalFeesAndRewardsEarned_gte: BigDecimal
  totalFeesAndRewardsEarned_in: [BigDecimal!]
  totalFeesAndRewardsEarned_lt: BigDecimal
  totalFeesAndRewardsEarned_lte: BigDecimal
  totalFeesAndRewardsEarned_not: BigDecimal
  totalFeesAndRewardsEarned_not_in: [BigDecimal!]
  totalLendingRewards: BigDecimal
  totalLendingRewards_gt: BigDecimal
  totalLendingRewards_gte: BigDecimal
  totalLendingRewards_in: [BigDecimal!]
  totalLendingRewards_lt: BigDecimal
  totalLendingRewards_lte: BigDecimal
  totalLendingRewards_not: BigDecimal
  totalLendingRewards_not_in: [BigDecimal!]
  totalLiquidityRewards: BigDecimal
  totalLiquidityRewards_gt: BigDecimal
  totalLiquidityRewards_gte: BigDecimal
  totalLiquidityRewards_in: [BigDecimal!]
  totalLiquidityRewards_lt: BigDecimal
  totalLiquidityRewards_lte: BigDecimal
  totalLiquidityRewards_not: BigDecimal
  totalLiquidityRewards_not_in: [BigDecimal!]
  totalStakingRewards: BigDecimal
  totalStakingRewards_gt: BigDecimal
  totalStakingRewards_gte: BigDecimal
  totalStakingRewards_in: [BigDecimal!]
  totalStakingRewards_lt: BigDecimal
  totalStakingRewards_lte: BigDecimal
  totalStakingRewards_not: BigDecimal
  totalStakingRewards_not_in: [BigDecimal!]
  totalTradingRewards: BigDecimal
  totalTradingRewards_gt: BigDecimal
  totalTradingRewards_gte: BigDecimal
  totalTradingRewards_in: [BigDecimal!]
  totalTradingRewards_lt: BigDecimal
  totalTradingRewards_lte: BigDecimal
  totalTradingRewards_not: BigDecimal
  totalTradingRewards_not_in: [BigDecimal!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum UserRewardsEarnedHistory_orderBy {
  availableTradingRewards
  id
  rewardsEarnedHistory
  totalFeeWithdrawn
  totalFeesAndRewardsEarned
  totalLendingRewards
  totalLiquidityRewards
  totalStakingRewards
  totalTradingRewards
  user
}

"""
This entity holds the voluntary staking history (ie not staking by a vesting contract) of one user
"""
type UserStakeHistory {
  """
  ID is the user address
  """
  id: ID!

  """
  Granular history of the user's voluntary staking activity
  """
  stakeHistory(
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: StakeHistoryItem_filter
  ): [StakeHistoryItem!]

  """
  totalRemaining is the amount the user currently has staked.
  It should be the same as the result of calling the balanceOf(USER_ADDRESS) method on the staking contract.
  """
  totalRemaining: BigDecimal!

  """
  totalStaked is the total amount the user has EVER staked (over all time).
  Eg if they stake 10 SOV and then withdraw it and stake it again, totalStaked is 20 SOV
  """
  totalStaked: BigDecimal!

  """
  totalWithdrawn is the total amount the user has ever withdrawn from voluntary staking (over all time)
  """
  totalWithdrawn: BigDecimal!
  user: User!
}

input UserStakeHistory_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  stakeHistory_: StakeHistoryItem_filter
  totalRemaining: BigDecimal
  totalRemaining_gt: BigDecimal
  totalRemaining_gte: BigDecimal
  totalRemaining_in: [BigDecimal!]
  totalRemaining_lt: BigDecimal
  totalRemaining_lte: BigDecimal
  totalRemaining_not: BigDecimal
  totalRemaining_not_in: [BigDecimal!]
  totalStaked: BigDecimal
  totalStaked_gt: BigDecimal
  totalStaked_gte: BigDecimal
  totalStaked_in: [BigDecimal!]
  totalStaked_lt: BigDecimal
  totalStaked_lte: BigDecimal
  totalStaked_not: BigDecimal
  totalStaked_not_in: [BigDecimal!]
  totalWithdrawn: BigDecimal
  totalWithdrawn_gt: BigDecimal
  totalWithdrawn_gte: BigDecimal
  totalWithdrawn_in: [BigDecimal!]
  totalWithdrawn_lt: BigDecimal
  totalWithdrawn_lte: BigDecimal
  totalWithdrawn_not: BigDecimal
  totalWithdrawn_not_in: [BigDecimal!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum UserStakeHistory_orderBy {
  id
  stakeHistory
  totalRemaining
  totalStaked
  totalWithdrawn
  user
}

"""
This is the total volumes of different actions for one user. See ProtocolStats entity for full descriptions.
"""
type UserTotal {
  id: ID!
  totalAmmLpFeesUsd: BigDecimal!
  totalAmmStakerFeesUsd: BigDecimal!
  totalAmmVolumeUsd: BigDecimal!
  totalBorrowVolumeUsd: BigDecimal!
  totalBorrowingFeesUsd: BigDecimal!
  totalCloseWithDepositVolumeUsd: BigDecimal!
  totalCloseWithSwapVolumeUsd: BigDecimal!
  totalDepositCollateralVolumeUsd: BigDecimal!
  totalLendVolumeUsd: BigDecimal!
  totalLendingFeesUsd: BigDecimal!
  totalLiquidateVolumeUsd: BigDecimal!
  totalMarginTradeVolumeUsd: BigDecimal!
  totalTradingFeesUsd: BigDecimal!
  totalUnlendVolumeUsd: BigDecimal!
  user: User!
}

input UserTotal_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  totalAmmLpFeesUsd: BigDecimal
  totalAmmLpFeesUsd_gt: BigDecimal
  totalAmmLpFeesUsd_gte: BigDecimal
  totalAmmLpFeesUsd_in: [BigDecimal!]
  totalAmmLpFeesUsd_lt: BigDecimal
  totalAmmLpFeesUsd_lte: BigDecimal
  totalAmmLpFeesUsd_not: BigDecimal
  totalAmmLpFeesUsd_not_in: [BigDecimal!]
  totalAmmStakerFeesUsd: BigDecimal
  totalAmmStakerFeesUsd_gt: BigDecimal
  totalAmmStakerFeesUsd_gte: BigDecimal
  totalAmmStakerFeesUsd_in: [BigDecimal!]
  totalAmmStakerFeesUsd_lt: BigDecimal
  totalAmmStakerFeesUsd_lte: BigDecimal
  totalAmmStakerFeesUsd_not: BigDecimal
  totalAmmStakerFeesUsd_not_in: [BigDecimal!]
  totalAmmVolumeUsd: BigDecimal
  totalAmmVolumeUsd_gt: BigDecimal
  totalAmmVolumeUsd_gte: BigDecimal
  totalAmmVolumeUsd_in: [BigDecimal!]
  totalAmmVolumeUsd_lt: BigDecimal
  totalAmmVolumeUsd_lte: BigDecimal
  totalAmmVolumeUsd_not: BigDecimal
  totalAmmVolumeUsd_not_in: [BigDecimal!]
  totalBorrowVolumeUsd: BigDecimal
  totalBorrowVolumeUsd_gt: BigDecimal
  totalBorrowVolumeUsd_gte: BigDecimal
  totalBorrowVolumeUsd_in: [BigDecimal!]
  totalBorrowVolumeUsd_lt: BigDecimal
  totalBorrowVolumeUsd_lte: BigDecimal
  totalBorrowVolumeUsd_not: BigDecimal
  totalBorrowVolumeUsd_not_in: [BigDecimal!]
  totalBorrowingFeesUsd: BigDecimal
  totalBorrowingFeesUsd_gt: BigDecimal
  totalBorrowingFeesUsd_gte: BigDecimal
  totalBorrowingFeesUsd_in: [BigDecimal!]
  totalBorrowingFeesUsd_lt: BigDecimal
  totalBorrowingFeesUsd_lte: BigDecimal
  totalBorrowingFeesUsd_not: BigDecimal
  totalBorrowingFeesUsd_not_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd: BigDecimal
  totalCloseWithDepositVolumeUsd_gt: BigDecimal
  totalCloseWithDepositVolumeUsd_gte: BigDecimal
  totalCloseWithDepositVolumeUsd_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd_lt: BigDecimal
  totalCloseWithDepositVolumeUsd_lte: BigDecimal
  totalCloseWithDepositVolumeUsd_not: BigDecimal
  totalCloseWithDepositVolumeUsd_not_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd: BigDecimal
  totalCloseWithSwapVolumeUsd_gt: BigDecimal
  totalCloseWithSwapVolumeUsd_gte: BigDecimal
  totalCloseWithSwapVolumeUsd_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd_lt: BigDecimal
  totalCloseWithSwapVolumeUsd_lte: BigDecimal
  totalCloseWithSwapVolumeUsd_not: BigDecimal
  totalCloseWithSwapVolumeUsd_not_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd: BigDecimal
  totalDepositCollateralVolumeUsd_gt: BigDecimal
  totalDepositCollateralVolumeUsd_gte: BigDecimal
  totalDepositCollateralVolumeUsd_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd_lt: BigDecimal
  totalDepositCollateralVolumeUsd_lte: BigDecimal
  totalDepositCollateralVolumeUsd_not: BigDecimal
  totalDepositCollateralVolumeUsd_not_in: [BigDecimal!]
  totalLendVolumeUsd: BigDecimal
  totalLendVolumeUsd_gt: BigDecimal
  totalLendVolumeUsd_gte: BigDecimal
  totalLendVolumeUsd_in: [BigDecimal!]
  totalLendVolumeUsd_lt: BigDecimal
  totalLendVolumeUsd_lte: BigDecimal
  totalLendVolumeUsd_not: BigDecimal
  totalLendVolumeUsd_not_in: [BigDecimal!]
  totalLendingFeesUsd: BigDecimal
  totalLendingFeesUsd_gt: BigDecimal
  totalLendingFeesUsd_gte: BigDecimal
  totalLendingFeesUsd_in: [BigDecimal!]
  totalLendingFeesUsd_lt: BigDecimal
  totalLendingFeesUsd_lte: BigDecimal
  totalLendingFeesUsd_not: BigDecimal
  totalLendingFeesUsd_not_in: [BigDecimal!]
  totalLiquidateVolumeUsd: BigDecimal
  totalLiquidateVolumeUsd_gt: BigDecimal
  totalLiquidateVolumeUsd_gte: BigDecimal
  totalLiquidateVolumeUsd_in: [BigDecimal!]
  totalLiquidateVolumeUsd_lt: BigDecimal
  totalLiquidateVolumeUsd_lte: BigDecimal
  totalLiquidateVolumeUsd_not: BigDecimal
  totalLiquidateVolumeUsd_not_in: [BigDecimal!]
  totalMarginTradeVolumeUsd: BigDecimal
  totalMarginTradeVolumeUsd_gt: BigDecimal
  totalMarginTradeVolumeUsd_gte: BigDecimal
  totalMarginTradeVolumeUsd_in: [BigDecimal!]
  totalMarginTradeVolumeUsd_lt: BigDecimal
  totalMarginTradeVolumeUsd_lte: BigDecimal
  totalMarginTradeVolumeUsd_not: BigDecimal
  totalMarginTradeVolumeUsd_not_in: [BigDecimal!]
  totalTradingFeesUsd: BigDecimal
  totalTradingFeesUsd_gt: BigDecimal
  totalTradingFeesUsd_gte: BigDecimal
  totalTradingFeesUsd_in: [BigDecimal!]
  totalTradingFeesUsd_lt: BigDecimal
  totalTradingFeesUsd_lte: BigDecimal
  totalTradingFeesUsd_not: BigDecimal
  totalTradingFeesUsd_not_in: [BigDecimal!]
  totalUnlendVolumeUsd: BigDecimal
  totalUnlendVolumeUsd_gt: BigDecimal
  totalUnlendVolumeUsd_gte: BigDecimal
  totalUnlendVolumeUsd_in: [BigDecimal!]
  totalUnlendVolumeUsd_lt: BigDecimal
  totalUnlendVolumeUsd_lte: BigDecimal
  totalUnlendVolumeUsd_not: BigDecimal
  totalUnlendVolumeUsd_not_in: [BigDecimal!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum UserTotal_orderBy {
  id
  totalAmmLpFeesUsd
  totalAmmStakerFeesUsd
  totalAmmVolumeUsd
  totalBorrowVolumeUsd
  totalBorrowingFeesUsd
  totalCloseWithDepositVolumeUsd
  totalCloseWithSwapVolumeUsd
  totalDepositCollateralVolumeUsd
  totalLendVolumeUsd
  totalLendingFeesUsd
  totalLiquidateVolumeUsd
  totalMarginTradeVolumeUsd
  totalTradingFeesUsd
  totalUnlendVolumeUsd
  user
}

input User_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  bitcoinTransfers_: BitcoinTransfer_filter
  borrows_: Borrow_filter
  createdAtTimestamp: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_lt: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_not_in: [Int!]
  crossChainTransfer_: CrossTransfer_filter
  currentStakes_: Stake_filter
  fastBTCBridgeStats_: FastBTCBridgeStat_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lendingHistory_: UserLendingHistory_filter
  liquidations_: Liquidate_filter
  liquidityHistory_: UserLiquidityHistory_filter
  loans_: Loan_filter
  rewardsEarnedHistory_: UserRewardsEarnedHistory_filter
  stakeHistory_: UserStakeHistory_filter
  swaps_: Swap_filter
  trades_: Trade_filter
  transactions_: Transaction_filter
  userTotals_: UserTotal_filter
  vestingContracts_: VestingContract_filter
  votes_: VoteCast_filter
}

enum User_orderBy {
  bitcoinTransfers
  borrows
  createdAtTimestamp
  crossChainTransfer
  currentStakes
  fastBTCBridgeStats
  id
  lendingHistory
  liquidations
  liquidityHistory
  loans
  rewardsEarnedHistory
  stakeHistory
  swaps
  trades
  transactions
  userTotals
  vestingContracts
  votes
}

"""
This entity represents one vesting contract
A User can have multiple vesting contracts
"""
type VestingContract {
  """
  The cliff is the period (in seconds) until the first tokens become liquid on this contract
  """
  cliff: Int

  """
  Date that the vesting contract was created
  """
  createdAtTimestamp: Int!
  createdAtTransaction: Transaction!

  """
  Current balance of tokens on the contract, including locked and liquid tokens that have not been withdrawn.
  Incremented on TokensStaked actions, decremented on TokensWithdrawn actions
  """
  currentBalance: BigDecimal!

  """
  The total duration of the vesting contract, including the cliff, in seconds.
  For example, a 9 month vesting contract with a 1 month cliff would have a duration of 26280000 (10 months in seconds)
  """
  duration: Int
  emittedBy: Bytes!

  """
  ID is the vesting contract address
  """
  id: ID!

  """
  A granular history of every action involving this vesting contract
  """
  stakeHistory(
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VestingHistoryItem_filter
  ): [VestingHistoryItem!]

  """
  The initial balance when this contract was created. This is often 0, as tokens can be added to the contract after contract creation
  """
  startingBalance: BigDecimal!

  """
  Type of contract (see VestingContractType docs for more details)
  """
  type: VestingContractType!

  """
  The owner of the vesting contract
  """
  user: User!
}

enum VestingContractType {
  """
  FISH (Babelfish governance token) vesting contracts
  """
  Fish

  """
  Babelfish team vesting contracts
  """
  FishTeam

  """
  Vesting contracts for strategic investors with a four-year lockup
  """
  FourYearVesting

  """
  Vesting contracts for investors who participated in the Sovryn Genesis sale
  """
  Genesis

  """
  Vesting contracts for investors who participated in the Sovryn Origin sale
  """
  Origins

  """
  Vesting contracts for vested rewards
  """
  Rewards

  """
  Vesting contracts for early strategic investors
  """
  Strategic

  """
  Sovryn team vesting contracts
  """
  Team
}

input VestingContract_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  cliff: Int
  cliff_gt: Int
  cliff_gte: Int
  cliff_in: [Int!]
  cliff_lt: Int
  cliff_lte: Int
  cliff_not: Int
  cliff_not_in: [Int!]
  createdAtTimestamp: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_lt: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_not_in: [Int!]
  createdAtTransaction: String
  createdAtTransaction_: Transaction_filter
  createdAtTransaction_contains: String
  createdAtTransaction_contains_nocase: String
  createdAtTransaction_ends_with: String
  createdAtTransaction_ends_with_nocase: String
  createdAtTransaction_gt: String
  createdAtTransaction_gte: String
  createdAtTransaction_in: [String!]
  createdAtTransaction_lt: String
  createdAtTransaction_lte: String
  createdAtTransaction_not: String
  createdAtTransaction_not_contains: String
  createdAtTransaction_not_contains_nocase: String
  createdAtTransaction_not_ends_with: String
  createdAtTransaction_not_ends_with_nocase: String
  createdAtTransaction_not_in: [String!]
  createdAtTransaction_not_starts_with: String
  createdAtTransaction_not_starts_with_nocase: String
  createdAtTransaction_starts_with: String
  createdAtTransaction_starts_with_nocase: String
  currentBalance: BigDecimal
  currentBalance_gt: BigDecimal
  currentBalance_gte: BigDecimal
  currentBalance_in: [BigDecimal!]
  currentBalance_lt: BigDecimal
  currentBalance_lte: BigDecimal
  currentBalance_not: BigDecimal
  currentBalance_not_in: [BigDecimal!]
  duration: Int
  duration_gt: Int
  duration_gte: Int
  duration_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_not: Int
  duration_not_in: [Int!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  stakeHistory_: VestingHistoryItem_filter
  startingBalance: BigDecimal
  startingBalance_gt: BigDecimal
  startingBalance_gte: BigDecimal
  startingBalance_in: [BigDecimal!]
  startingBalance_lt: BigDecimal
  startingBalance_lte: BigDecimal
  startingBalance_not: BigDecimal
  startingBalance_not_in: [BigDecimal!]
  type: VestingContractType
  type_in: [VestingContractType!]
  type_not: VestingContractType
  type_not_in: [VestingContractType!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum VestingContract_orderBy {
  cliff
  createdAtTimestamp
  createdAtTransaction
  currentBalance
  duration
  emittedBy
  id
  stakeHistory
  startingBalance
  type
  user
}

"""
Granular data for each vesting contract, and any actions involving that contract
"""
type VestingHistoryItem {
  action: VestingHistoryItemAction!

  """
  Amount being staked
  """
  amount: BigDecimal!
  emittedBy: Bytes!

  """
  ID is transaction hash + "-" + log index
  For TokensStaked actions, there can be multiple actions per transactions, and each will create a new entity
  """
  id: ID!

  """
  The date when the tokens become unlocked
  """
  lockedUntil: Int

  """
  The staker here will always be the vesting contract
  """
  staker: VestingContract!
  timestamp: Int!

  """
  Total number of tokens staked until this lockedUntil date
  """
  totalStaked: BigDecimal!
  transaction: Transaction!
}

enum VestingHistoryItemAction {
  """
  This is only relevant to Team tokens. For Team contracts, a vesting contract can be revoked by governance if a team member leaves the project.
  If this happens, all tokens still locked are returned to the exchequer.
  This is ONLY possible with Team or FishTeam vesting contracts.
  """
  TeamTokensRevoked

  """
  Tokens are staked by the Vesting contract. This happens when the Vesting contract receives funds.
  """
  TokensStaked

  """
  When a user withdraws unlocked tokens from the vesting contract
  """
  TokensWithdrawn
}

input VestingHistoryItem_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  action: VestingHistoryItemAction
  action_in: [VestingHistoryItemAction!]
  action_not: VestingHistoryItemAction
  action_not_in: [VestingHistoryItemAction!]
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedUntil: Int
  lockedUntil_gt: Int
  lockedUntil_gte: Int
  lockedUntil_in: [Int!]
  lockedUntil_lt: Int
  lockedUntil_lte: Int
  lockedUntil_not: Int
  lockedUntil_not_in: [Int!]
  staker: String
  staker_: VestingContract_filter
  staker_contains: String
  staker_contains_nocase: String
  staker_ends_with: String
  staker_ends_with_nocase: String
  staker_gt: String
  staker_gte: String
  staker_in: [String!]
  staker_lt: String
  staker_lte: String
  staker_not: String
  staker_not_contains: String
  staker_not_contains_nocase: String
  staker_not_ends_with: String
  staker_not_ends_with_nocase: String
  staker_not_in: [String!]
  staker_not_starts_with: String
  staker_not_starts_with_nocase: String
  staker_starts_with: String
  staker_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalStaked: BigDecimal
  totalStaked_gt: BigDecimal
  totalStaked_gte: BigDecimal
  totalStaked_in: [BigDecimal!]
  totalStaked_lt: BigDecimal
  totalStaked_lte: BigDecimal
  totalStaked_not: BigDecimal
  totalStaked_not_in: [BigDecimal!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum VestingHistoryItem_orderBy {
  action
  amount
  emittedBy
  id
  lockedUntil
  staker
  timestamp
  totalStaked
  transaction
}

"""
This is the event emitted when a user votes for or against a proposed SIP
"""
type VoteCast {
  emittedBy: Bytes!

  """
  ID is transaction hash + log index
  """
  id: ID!

  """
  The ID of the Proposal entity that this vote is for/against
  """
  proposal: Proposal!

  """
  The ID of the proposal
  """
  proposalId: Int!

  """
  True if the vote is for the proposal, False if it is against
  """
  support: Boolean!
  timestamp: Int!
  transaction: Transaction!
  voter: User!

  """
  The number of votes the user cast (the voting power of that user)
  """
  votes: BigInt!
}

input VoteCast_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  proposal: String
  proposalId: Int
  proposalId_gt: Int
  proposalId_gte: Int
  proposalId_in: [Int!]
  proposalId_lt: Int
  proposalId_lte: Int
  proposalId_not: Int
  proposalId_not_in: [Int!]
  proposal_: Proposal_filter
  proposal_contains: String
  proposal_contains_nocase: String
  proposal_ends_with: String
  proposal_ends_with_nocase: String
  proposal_gt: String
  proposal_gte: String
  proposal_in: [String!]
  proposal_lt: String
  proposal_lte: String
  proposal_not: String
  proposal_not_contains: String
  proposal_not_contains_nocase: String
  proposal_not_ends_with: String
  proposal_not_ends_with_nocase: String
  proposal_not_in: [String!]
  proposal_not_starts_with: String
  proposal_not_starts_with_nocase: String
  proposal_starts_with: String
  proposal_starts_with_nocase: String
  support: Boolean
  support_in: [Boolean!]
  support_not: Boolean
  support_not_in: [Boolean!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  voter: String
  voter_: User_filter
  voter_contains: String
  voter_contains_nocase: String
  voter_ends_with: String
  voter_ends_with_nocase: String
  voter_gt: String
  voter_gte: String
  voter_in: [String!]
  voter_lt: String
  voter_lte: String
  voter_not: String
  voter_not_contains: String
  voter_not_contains_nocase: String
  voter_not_ends_with: String
  voter_not_ends_with_nocase: String
  voter_not_in: [String!]
  voter_not_starts_with: String
  voter_not_starts_with_nocase: String
  voter_starts_with: String
  voter_starts_with_nocase: String
  votes: BigInt
  votes_gt: BigInt
  votes_gte: BigInt
  votes_in: [BigInt!]
  votes_lt: BigInt
  votes_lte: BigInt
  votes_not: BigInt
  votes_not_in: [BigInt!]
}

enum VoteCast_orderBy {
  emittedBy
  id
  proposal
  proposalId
  support
  timestamp
  transaction
  voter
  votes
}

type Withdrawal {
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  receiver: Bytes!
  timestamp: Int!
  transaction: Transaction!
}

input Withdrawal_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  receiver: Bytes
  receiver_contains: Bytes
  receiver_in: [Bytes!]
  receiver_not: Bytes
  receiver_not_contains: Bytes
  receiver_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Withdrawal_orderBy {
  amount
  emittedBy
  id
  receiver
  timestamp
  transaction
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
