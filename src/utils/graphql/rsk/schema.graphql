directive @derivedFrom(field: String) on FIELD_DEFINITION

directive @entity on OBJECT

directive @subgraphId(id: String) on OBJECT

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows (takes out a loan)
"""
type Borrow {
  collateralToLoanRate: BigInt!
  collateralToken: Bytes!
  currentMargin: BigInt!
  emittedBy: Bytes!
  id: ID!
  interestDuration: BigInt!
  interestRate: BigInt!
  lender: Bytes!
  loanId: Loan!
  loanToken: Bytes!
  newCollateral: BigInt!
  newPrincipal: BigInt!
  timestamp: BigInt!
  transaction: Transaction!
  user: User!
}

input Borrow_filter {
  collateralToLoanRate: BigInt
  collateralToLoanRate_gt: BigInt
  collateralToLoanRate_gte: BigInt
  collateralToLoanRate_in: [BigInt!]
  collateralToLoanRate_lt: BigInt
  collateralToLoanRate_lte: BigInt
  collateralToLoanRate_not: BigInt
  collateralToLoanRate_not_in: [BigInt!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  currentMargin: BigInt
  currentMargin_gt: BigInt
  currentMargin_gte: BigInt
  currentMargin_in: [BigInt!]
  currentMargin_lt: BigInt
  currentMargin_lte: BigInt
  currentMargin_not: BigInt
  currentMargin_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  interestDuration: BigInt
  interestDuration_gt: BigInt
  interestDuration_gte: BigInt
  interestDuration_in: [BigInt!]
  interestDuration_lt: BigInt
  interestDuration_lte: BigInt
  interestDuration_not: BigInt
  interestDuration_not_in: [BigInt!]
  interestRate: BigInt
  interestRate_gt: BigInt
  interestRate_gte: BigInt
  interestRate_in: [BigInt!]
  interestRate_lt: BigInt
  interestRate_lte: BigInt
  interestRate_not: BigInt
  interestRate_not_in: [BigInt!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  newCollateral: BigInt
  newCollateral_gt: BigInt
  newCollateral_gte: BigInt
  newCollateral_in: [BigInt!]
  newCollateral_lt: BigInt
  newCollateral_lte: BigInt
  newCollateral_not: BigInt
  newCollateral_not_in: [BigInt!]
  newPrincipal: BigInt
  newPrincipal_gt: BigInt
  newPrincipal_gte: BigInt
  newPrincipal_in: [BigInt!]
  newPrincipal_lt: BigInt
  newPrincipal_lte: BigInt
  newPrincipal_not: BigInt
  newPrincipal_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum Borrow_orderBy {
  collateralToLoanRate
  collateralToken
  currentMargin
  emittedBy
  id
  interestDuration
  interestRate
  lender
  loanId
  loanToken
  newCollateral
  newPrincipal
  timestamp
  transaction
  user
}

scalar Bytes

type CandleStick {
  baseToken: Token
  close: BigDecimal!
  high: BigDecimal!
  id: ID!
  interval: CandleSticksInterval
  low: BigDecimal!
  open: BigDecimal
  periodStartUnix: Int!
  quoteToken: Token
  totalVolume: BigDecimal!
  txCount: Int!
}

input CandleStick_filter {
  baseToken: String
  baseToken_contains: String
  baseToken_ends_with: String
  baseToken_gt: String
  baseToken_gte: String
  baseToken_in: [String!]
  baseToken_lt: String
  baseToken_lte: String
  baseToken_not: String
  baseToken_not_contains: String
  baseToken_not_ends_with: String
  baseToken_not_in: [String!]
  baseToken_not_starts_with: String
  baseToken_starts_with: String
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  interval: CandleSticksInterval
  interval_in: [CandleSticksInterval!]
  interval_not: CandleSticksInterval
  interval_not_in: [CandleSticksInterval!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  periodStartUnix: Int
  periodStartUnix_gt: Int
  periodStartUnix_gte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_lt: Int
  periodStartUnix_lte: Int
  periodStartUnix_not: Int
  periodStartUnix_not_in: [Int!]
  quoteToken: String
  quoteToken_contains: String
  quoteToken_ends_with: String
  quoteToken_gt: String
  quoteToken_gte: String
  quoteToken_in: [String!]
  quoteToken_lt: String
  quoteToken_lte: String
  quoteToken_not: String
  quoteToken_not_contains: String
  quoteToken_not_ends_with: String
  quoteToken_not_in: [String!]
  quoteToken_not_starts_with: String
  quoteToken_starts_with: String
  totalVolume: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_lt: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_not_in: [BigDecimal!]
  txCount: Int
  txCount_gt: Int
  txCount_gte: Int
  txCount_in: [Int!]
  txCount_lt: Int
  txCount_lte: Int
  txCount_not: Int
  txCount_not_in: [Int!]
}

enum CandleStick_orderBy {
  baseToken
  close
  high
  id
  interval
  low
  open
  periodStartUnix
  quoteToken
  totalVolume
  txCount
}

enum CandleSticksInterval {
  DayInterval
  FifteenMintuesInterval
  FourHourInterval
  HourInterval
  MinuteInterval
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Borrow event
"""
type CloseWithDeposit {
  closer: Bytes!
  collateralToLoanRate: BigInt!
  collateralToken: Bytes!
  collateralWithdrawAmount: BigInt!
  currentMargin: BigInt!
  emittedBy: Bytes!
  id: ID!
  lender: Bytes!
  loanId: Loan!
  loanToken: Bytes!
  repayAmount: BigInt!
  timestamp: BigInt!
  transaction: Transaction!
  user: Bytes!
}

input CloseWithDeposit_filter {
  closer: Bytes
  closer_contains: Bytes
  closer_in: [Bytes!]
  closer_not: Bytes
  closer_not_contains: Bytes
  closer_not_in: [Bytes!]
  collateralToLoanRate: BigInt
  collateralToLoanRate_gt: BigInt
  collateralToLoanRate_gte: BigInt
  collateralToLoanRate_in: [BigInt!]
  collateralToLoanRate_lt: BigInt
  collateralToLoanRate_lte: BigInt
  collateralToLoanRate_not: BigInt
  collateralToLoanRate_not_in: [BigInt!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  collateralWithdrawAmount: BigInt
  collateralWithdrawAmount_gt: BigInt
  collateralWithdrawAmount_gte: BigInt
  collateralWithdrawAmount_in: [BigInt!]
  collateralWithdrawAmount_lt: BigInt
  collateralWithdrawAmount_lte: BigInt
  collateralWithdrawAmount_not: BigInt
  collateralWithdrawAmount_not_in: [BigInt!]
  currentMargin: BigInt
  currentMargin_gt: BigInt
  currentMargin_gte: BigInt
  currentMargin_in: [BigInt!]
  currentMargin_lt: BigInt
  currentMargin_lte: BigInt
  currentMargin_not: BigInt
  currentMargin_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  repayAmount: BigInt
  repayAmount_gt: BigInt
  repayAmount_gte: BigInt
  repayAmount_in: [BigInt!]
  repayAmount_lt: BigInt
  repayAmount_lte: BigInt
  repayAmount_not: BigInt
  repayAmount_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: Bytes
  user_contains: Bytes
  user_in: [Bytes!]
  user_not: Bytes
  user_not_contains: Bytes
  user_not_in: [Bytes!]
}

enum CloseWithDeposit_orderBy {
  closer
  collateralToLoanRate
  collateralToken
  collateralWithdrawAmount
  currentMargin
  emittedBy
  id
  lender
  loanId
  loanToken
  repayAmount
  timestamp
  transaction
  user
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Margin Trade
"""
type CloseWithSwap {
  closer: Bytes!
  collateralToken: Bytes!
  currentLeverage: BigInt!
  emittedBy: Bytes!
  exitPrice: BigInt!
  id: ID!
  lender: Bytes!
  loanCloseAmount: BigInt!
  loanId: Loan!
  loanToken: Bytes!
  positionCloseSize: BigInt!
  timestamp: BigInt!
  transaction: Transaction!
  user: Bytes!
}

input CloseWithSwap_filter {
  closer: Bytes
  closer_contains: Bytes
  closer_in: [Bytes!]
  closer_not: Bytes
  closer_not_contains: Bytes
  closer_not_in: [Bytes!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  currentLeverage: BigInt
  currentLeverage_gt: BigInt
  currentLeverage_gte: BigInt
  currentLeverage_in: [BigInt!]
  currentLeverage_lt: BigInt
  currentLeverage_lte: BigInt
  currentLeverage_not: BigInt
  currentLeverage_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  exitPrice: BigInt
  exitPrice_gt: BigInt
  exitPrice_gte: BigInt
  exitPrice_in: [BigInt!]
  exitPrice_lt: BigInt
  exitPrice_lte: BigInt
  exitPrice_not: BigInt
  exitPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanCloseAmount: BigInt
  loanCloseAmount_gt: BigInt
  loanCloseAmount_gte: BigInt
  loanCloseAmount_in: [BigInt!]
  loanCloseAmount_lt: BigInt
  loanCloseAmount_lte: BigInt
  loanCloseAmount_not: BigInt
  loanCloseAmount_not_in: [BigInt!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  positionCloseSize: BigInt
  positionCloseSize_gt: BigInt
  positionCloseSize_gte: BigInt
  positionCloseSize_in: [BigInt!]
  positionCloseSize_lt: BigInt
  positionCloseSize_lte: BigInt
  positionCloseSize_not: BigInt
  positionCloseSize_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: Bytes
  user_contains: Bytes
  user_in: [Bytes!]
  user_not: Bytes
  user_not_contains: Bytes
  user_not_in: [Bytes!]
}

enum CloseWithSwap_orderBy {
  closer
  collateralToken
  currentLeverage
  emittedBy
  exitPrice
  id
  lender
  loanCloseAmount
  loanId
  loanToken
  positionCloseSize
  timestamp
  transaction
  user
}

"""
Autogenerated for debugging - to be eventually deleted. Although this is pretty useful, maybe keep
"""
type Conversion {
  _amount: BigInt!
  _conversionFee: BigInt!
  _fromToken: Token!
  _protocolFee: BigInt!
  _return: BigInt!
  _toToken: Token!
  _trader: Bytes!
  emittedBy: Bytes!
  id: ID!
  swapTransaction: Swap!
  timestamp: BigInt!
  transaction: Transaction!
}

input Conversion_filter {
  _amount: BigInt
  _amount_gt: BigInt
  _amount_gte: BigInt
  _amount_in: [BigInt!]
  _amount_lt: BigInt
  _amount_lte: BigInt
  _amount_not: BigInt
  _amount_not_in: [BigInt!]
  _conversionFee: BigInt
  _conversionFee_gt: BigInt
  _conversionFee_gte: BigInt
  _conversionFee_in: [BigInt!]
  _conversionFee_lt: BigInt
  _conversionFee_lte: BigInt
  _conversionFee_not: BigInt
  _conversionFee_not_in: [BigInt!]
  _fromToken: String
  _fromToken_contains: String
  _fromToken_ends_with: String
  _fromToken_gt: String
  _fromToken_gte: String
  _fromToken_in: [String!]
  _fromToken_lt: String
  _fromToken_lte: String
  _fromToken_not: String
  _fromToken_not_contains: String
  _fromToken_not_ends_with: String
  _fromToken_not_in: [String!]
  _fromToken_not_starts_with: String
  _fromToken_starts_with: String
  _protocolFee: BigInt
  _protocolFee_gt: BigInt
  _protocolFee_gte: BigInt
  _protocolFee_in: [BigInt!]
  _protocolFee_lt: BigInt
  _protocolFee_lte: BigInt
  _protocolFee_not: BigInt
  _protocolFee_not_in: [BigInt!]
  _return: BigInt
  _return_gt: BigInt
  _return_gte: BigInt
  _return_in: [BigInt!]
  _return_lt: BigInt
  _return_lte: BigInt
  _return_not: BigInt
  _return_not_in: [BigInt!]
  _toToken: String
  _toToken_contains: String
  _toToken_ends_with: String
  _toToken_gt: String
  _toToken_gte: String
  _toToken_in: [String!]
  _toToken_lt: String
  _toToken_lte: String
  _toToken_not: String
  _toToken_not_contains: String
  _toToken_not_ends_with: String
  _toToken_not_in: [String!]
  _toToken_not_starts_with: String
  _toToken_starts_with: String
  _trader: Bytes
  _trader_contains: Bytes
  _trader_in: [Bytes!]
  _trader_not: Bytes
  _trader_not_contains: Bytes
  _trader_not_in: [Bytes!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  swapTransaction: String
  swapTransaction_contains: String
  swapTransaction_ends_with: String
  swapTransaction_gt: String
  swapTransaction_gte: String
  swapTransaction_in: [String!]
  swapTransaction_lt: String
  swapTransaction_lte: String
  swapTransaction_not: String
  swapTransaction_not_contains: String
  swapTransaction_not_ends_with: String
  swapTransaction_not_in: [String!]
  swapTransaction_not_starts_with: String
  swapTransaction_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum Conversion_orderBy {
  _amount
  _conversionFee
  _fromToken
  _protocolFee
  _return
  _toToken
  _trader
  emittedBy
  id
  swapTransaction
  timestamp
  transaction
}

"""
The ConverterRegistry registers each new AMM pool added to the Sovryn Protocol
"""
type ConverterRegistry {
  addedToContractRegistryAtBlockNumber: BigInt
  addedToContractRegistryAtBlockTimestamp: BigInt
  addedToContractRegistryAtTransactionHash: String
  connectorTokens(
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Token_filter
  ): [Token!]

  """
  All the converters (AMM pools) associated with this registry
  """
  converters(
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityPool_filter
  ): [LiquidityPool!]

  """
  ID is the address of the converter registry contract
  """
  id: ID!
  lastUsedAtBlockNumber: BigInt
  lastUsedAtBlockTimestamp: BigInt
  lastUsedAtTransactionHash: String
  numConverters: BigInt!
  owner: Bytes!
  smartTokens(
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: SmartToken_filter
  ): [SmartToken!]
}

input ConverterRegistry_filter {
  addedToContractRegistryAtBlockNumber: BigInt
  addedToContractRegistryAtBlockNumber_gt: BigInt
  addedToContractRegistryAtBlockNumber_gte: BigInt
  addedToContractRegistryAtBlockNumber_in: [BigInt!]
  addedToContractRegistryAtBlockNumber_lt: BigInt
  addedToContractRegistryAtBlockNumber_lte: BigInt
  addedToContractRegistryAtBlockNumber_not: BigInt
  addedToContractRegistryAtBlockNumber_not_in: [BigInt!]
  addedToContractRegistryAtBlockTimestamp: BigInt
  addedToContractRegistryAtBlockTimestamp_gt: BigInt
  addedToContractRegistryAtBlockTimestamp_gte: BigInt
  addedToContractRegistryAtBlockTimestamp_in: [BigInt!]
  addedToContractRegistryAtBlockTimestamp_lt: BigInt
  addedToContractRegistryAtBlockTimestamp_lte: BigInt
  addedToContractRegistryAtBlockTimestamp_not: BigInt
  addedToContractRegistryAtBlockTimestamp_not_in: [BigInt!]
  addedToContractRegistryAtTransactionHash: String
  addedToContractRegistryAtTransactionHash_contains: String
  addedToContractRegistryAtTransactionHash_ends_with: String
  addedToContractRegistryAtTransactionHash_gt: String
  addedToContractRegistryAtTransactionHash_gte: String
  addedToContractRegistryAtTransactionHash_in: [String!]
  addedToContractRegistryAtTransactionHash_lt: String
  addedToContractRegistryAtTransactionHash_lte: String
  addedToContractRegistryAtTransactionHash_not: String
  addedToContractRegistryAtTransactionHash_not_contains: String
  addedToContractRegistryAtTransactionHash_not_ends_with: String
  addedToContractRegistryAtTransactionHash_not_in: [String!]
  addedToContractRegistryAtTransactionHash_not_starts_with: String
  addedToContractRegistryAtTransactionHash_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastUsedAtBlockNumber: BigInt
  lastUsedAtBlockNumber_gt: BigInt
  lastUsedAtBlockNumber_gte: BigInt
  lastUsedAtBlockNumber_in: [BigInt!]
  lastUsedAtBlockNumber_lt: BigInt
  lastUsedAtBlockNumber_lte: BigInt
  lastUsedAtBlockNumber_not: BigInt
  lastUsedAtBlockNumber_not_in: [BigInt!]
  lastUsedAtBlockTimestamp: BigInt
  lastUsedAtBlockTimestamp_gt: BigInt
  lastUsedAtBlockTimestamp_gte: BigInt
  lastUsedAtBlockTimestamp_in: [BigInt!]
  lastUsedAtBlockTimestamp_lt: BigInt
  lastUsedAtBlockTimestamp_lte: BigInt
  lastUsedAtBlockTimestamp_not: BigInt
  lastUsedAtBlockTimestamp_not_in: [BigInt!]
  lastUsedAtTransactionHash: String
  lastUsedAtTransactionHash_contains: String
  lastUsedAtTransactionHash_ends_with: String
  lastUsedAtTransactionHash_gt: String
  lastUsedAtTransactionHash_gte: String
  lastUsedAtTransactionHash_in: [String!]
  lastUsedAtTransactionHash_lt: String
  lastUsedAtTransactionHash_lte: String
  lastUsedAtTransactionHash_not: String
  lastUsedAtTransactionHash_not_contains: String
  lastUsedAtTransactionHash_not_ends_with: String
  lastUsedAtTransactionHash_not_in: [String!]
  lastUsedAtTransactionHash_not_starts_with: String
  lastUsedAtTransactionHash_starts_with: String
  numConverters: BigInt
  numConverters_gt: BigInt
  numConverters_gte: BigInt
  numConverters_in: [BigInt!]
  numConverters_lt: BigInt
  numConverters_lte: BigInt
  numConverters_not: BigInt
  numConverters_not_in: [BigInt!]
  owner: Bytes
  owner_contains: Bytes
  owner_in: [Bytes!]
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
}

enum ConverterRegistry_orderBy {
  addedToContractRegistryAtBlockNumber
  addedToContractRegistryAtBlockTimestamp
  addedToContractRegistryAtTransactionHash
  connectorTokens
  converters
  id
  lastUsedAtBlockNumber
  lastUsedAtBlockTimestamp
  lastUsedAtTransactionHash
  numConverters
  owner
  smartTokens
}

"""
Granular event data for the Loan entity. Emitted when a user closes adds collateral to a Margin Trade or Borrow
"""
type DepositCollateral {
  depositAmount: BigInt!
  emittedBy: Bytes!
  id: ID!
  loanId: Loan!
  rate: BigInt
  timestamp: BigInt!
  transaction: Transaction!
}

input DepositCollateral_filter {
  depositAmount: BigInt
  depositAmount_gt: BigInt
  depositAmount_gte: BigInt
  depositAmount_in: [BigInt!]
  depositAmount_lt: BigInt
  depositAmount_lte: BigInt
  depositAmount_not: BigInt
  depositAmount_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  rate: BigInt
  rate_gt: BigInt
  rate_gte: BigInt
  rate_in: [BigInt!]
  rate_lt: BigInt
  rate_lte: BigInt
  rate_not: BigInt
  rate_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum DepositCollateral_orderBy {
  depositAmount
  emittedBy
  id
  loanId
  rate
  timestamp
  transaction
}

type FeeSharingTokensTransferred {
  amount: BigInt!
  id: ID!
  sender: Bytes!
  token: Bytes!
}

input FeeSharingTokensTransferred_filter {
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  sender: Bytes
  sender_contains: Bytes
  sender_in: [Bytes!]
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
}

enum FeeSharingTokensTransferred_orderBy {
  amount
  id
  sender
  token
}

type LendingHistoryItem {
  amount: BigInt!

  """
  The underlying asset for this pool (eg USDT for the iUSDT pool)
  """
  asset: Token
  emittedBy: String!
  id: ID!
  lender: User!
  lendingPool: LendingPool!
  loanTokenAmount: BigInt!
  transaction: Transaction!
  type: LendingHistoryType!
  userLendingHistory: UserLendingHistory!
}

input LendingHistoryItem_filter {
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  asset: String
  asset_contains: String
  asset_ends_with: String
  asset_gt: String
  asset_gte: String
  asset_in: [String!]
  asset_lt: String
  asset_lte: String
  asset_not: String
  asset_not_contains: String
  asset_not_ends_with: String
  asset_not_in: [String!]
  asset_not_starts_with: String
  asset_starts_with: String
  emittedBy: String
  emittedBy_contains: String
  emittedBy_ends_with: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_ends_with: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: String
  lender_contains: String
  lender_ends_with: String
  lender_gt: String
  lender_gte: String
  lender_in: [String!]
  lender_lt: String
  lender_lte: String
  lender_not: String
  lender_not_contains: String
  lender_not_ends_with: String
  lender_not_in: [String!]
  lender_not_starts_with: String
  lender_starts_with: String
  lendingPool: String
  lendingPool_contains: String
  lendingPool_ends_with: String
  lendingPool_gt: String
  lendingPool_gte: String
  lendingPool_in: [String!]
  lendingPool_lt: String
  lendingPool_lte: String
  lendingPool_not: String
  lendingPool_not_contains: String
  lendingPool_not_ends_with: String
  lendingPool_not_in: [String!]
  lendingPool_not_starts_with: String
  lendingPool_starts_with: String
  loanTokenAmount: BigInt
  loanTokenAmount_gt: BigInt
  loanTokenAmount_gte: BigInt
  loanTokenAmount_in: [BigInt!]
  loanTokenAmount_lt: BigInt
  loanTokenAmount_lte: BigInt
  loanTokenAmount_not: BigInt
  loanTokenAmount_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  type: LendingHistoryType
  type_in: [LendingHistoryType!]
  type_not: LendingHistoryType
  type_not_in: [LendingHistoryType!]
  userLendingHistory: String
  userLendingHistory_contains: String
  userLendingHistory_ends_with: String
  userLendingHistory_gt: String
  userLendingHistory_gte: String
  userLendingHistory_in: [String!]
  userLendingHistory_lt: String
  userLendingHistory_lte: String
  userLendingHistory_not: String
  userLendingHistory_not_contains: String
  userLendingHistory_not_ends_with: String
  userLendingHistory_not_in: [String!]
  userLendingHistory_not_starts_with: String
  userLendingHistory_starts_with: String
}

enum LendingHistoryItem_orderBy {
  amount
  asset
  emittedBy
  id
  lender
  lendingPool
  loanTokenAmount
  transaction
  type
  userLendingHistory
}

enum LendingHistoryType {
  Lend
  UnLend
}

"""
A Lending Pool (iToken), where Users can lend assets to earn interest, and Users can borrow assets to Margin Trade or just as a regular loan.
"""
type LendingPool {
  assetBalance: BigInt!

  """
  ID is the contract address of the iToken
  """
  id: ID!
  poolTokenBalance: BigInt!

  """
  Total asset volume lent over all time
  """
  totalAssetLent: BigInt!

  """
  The actual asset being lent and borrowed in this pool
  """
  underlyingAsset: Token!
}

input LendingPool_filter {
  assetBalance: BigInt
  assetBalance_gt: BigInt
  assetBalance_gte: BigInt
  assetBalance_in: [BigInt!]
  assetBalance_lt: BigInt
  assetBalance_lte: BigInt
  assetBalance_not: BigInt
  assetBalance_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolTokenBalance: BigInt
  poolTokenBalance_gt: BigInt
  poolTokenBalance_gte: BigInt
  poolTokenBalance_in: [BigInt!]
  poolTokenBalance_lt: BigInt
  poolTokenBalance_lte: BigInt
  poolTokenBalance_not: BigInt
  poolTokenBalance_not_in: [BigInt!]
  totalAssetLent: BigInt
  totalAssetLent_gt: BigInt
  totalAssetLent_gte: BigInt
  totalAssetLent_in: [BigInt!]
  totalAssetLent_lt: BigInt
  totalAssetLent_lte: BigInt
  totalAssetLent_not: BigInt
  totalAssetLent_not_in: [BigInt!]
  underlyingAsset: String
  underlyingAsset_contains: String
  underlyingAsset_ends_with: String
  underlyingAsset_gt: String
  underlyingAsset_gte: String
  underlyingAsset_in: [String!]
  underlyingAsset_lt: String
  underlyingAsset_lte: String
  underlyingAsset_not: String
  underlyingAsset_not_contains: String
  underlyingAsset_not_ends_with: String
  underlyingAsset_not_in: [String!]
  underlyingAsset_not_starts_with: String
  underlyingAsset_starts_with: String
}

enum LendingPool_orderBy {
  assetBalance
  id
  poolTokenBalance
  totalAssetLent
  underlyingAsset
}

"""
Granular event data for the Loan entity. Emitted when a loan is fully or partially liquidated
"""
type Liquidate {
  collateralToLoanRate: BigInt!
  collateralToken: Bytes!
  collateralWithdrawAmount: BigInt!
  currentMargin: BigInt!
  emittedBy: Bytes!
  id: ID!
  lender: Bytes!
  liquidator: Bytes!
  loanId: Loan!
  loanToken: Bytes!
  repayAmount: BigInt!
  timestamp: BigInt!
  transaction: Transaction!
  user: User!
}

input Liquidate_filter {
  collateralToLoanRate: BigInt
  collateralToLoanRate_gt: BigInt
  collateralToLoanRate_gte: BigInt
  collateralToLoanRate_in: [BigInt!]
  collateralToLoanRate_lt: BigInt
  collateralToLoanRate_lte: BigInt
  collateralToLoanRate_not: BigInt
  collateralToLoanRate_not_in: [BigInt!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  collateralWithdrawAmount: BigInt
  collateralWithdrawAmount_gt: BigInt
  collateralWithdrawAmount_gte: BigInt
  collateralWithdrawAmount_in: [BigInt!]
  collateralWithdrawAmount_lt: BigInt
  collateralWithdrawAmount_lte: BigInt
  collateralWithdrawAmount_not: BigInt
  collateralWithdrawAmount_not_in: [BigInt!]
  currentMargin: BigInt
  currentMargin_gt: BigInt
  currentMargin_gte: BigInt
  currentMargin_in: [BigInt!]
  currentMargin_lt: BigInt
  currentMargin_lte: BigInt
  currentMargin_not: BigInt
  currentMargin_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  liquidator: Bytes
  liquidator_contains: Bytes
  liquidator_in: [Bytes!]
  liquidator_not: Bytes
  liquidator_not_contains: Bytes
  liquidator_not_in: [Bytes!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  repayAmount: BigInt
  repayAmount_gt: BigInt
  repayAmount_gte: BigInt
  repayAmount_in: [BigInt!]
  repayAmount_lt: BigInt
  repayAmount_lte: BigInt
  repayAmount_not: BigInt
  repayAmount_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum Liquidate_orderBy {
  collateralToLoanRate
  collateralToken
  collateralWithdrawAmount
  currentMargin
  emittedBy
  id
  lender
  liquidator
  loanId
  loanToken
  repayAmount
  timestamp
  transaction
  user
}

type LiquidityHistoryItem {
  amount: BigInt!
  emittedBy: String!

  """
  ID is transaction hash + log index
  """
  id: ID!
  liquidityPool: LiquidityPool!
  newBalance: BigInt!
  newSupply: BigInt!
  provider: String!
  reserveToken: Token!
  timestamp: BigInt!
  transaction: Transaction!
  type: LiquidityHistoryType!
  user: User!
  userLiquidityHistory: UserLiquidityHistory!
}

input LiquidityHistoryItem_filter {
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  emittedBy: String
  emittedBy_contains: String
  emittedBy_ends_with: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_ends_with: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPool: String
  liquidityPool_contains: String
  liquidityPool_ends_with: String
  liquidityPool_gt: String
  liquidityPool_gte: String
  liquidityPool_in: [String!]
  liquidityPool_lt: String
  liquidityPool_lte: String
  liquidityPool_not: String
  liquidityPool_not_contains: String
  liquidityPool_not_ends_with: String
  liquidityPool_not_in: [String!]
  liquidityPool_not_starts_with: String
  liquidityPool_starts_with: String
  newBalance: BigInt
  newBalance_gt: BigInt
  newBalance_gte: BigInt
  newBalance_in: [BigInt!]
  newBalance_lt: BigInt
  newBalance_lte: BigInt
  newBalance_not: BigInt
  newBalance_not_in: [BigInt!]
  newSupply: BigInt
  newSupply_gt: BigInt
  newSupply_gte: BigInt
  newSupply_in: [BigInt!]
  newSupply_lt: BigInt
  newSupply_lte: BigInt
  newSupply_not: BigInt
  newSupply_not_in: [BigInt!]
  provider: String
  provider_contains: String
  provider_ends_with: String
  provider_gt: String
  provider_gte: String
  provider_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_not: String
  provider_not_contains: String
  provider_not_ends_with: String
  provider_not_in: [String!]
  provider_not_starts_with: String
  provider_starts_with: String
  reserveToken: String
  reserveToken_contains: String
  reserveToken_ends_with: String
  reserveToken_gt: String
  reserveToken_gte: String
  reserveToken_in: [String!]
  reserveToken_lt: String
  reserveToken_lte: String
  reserveToken_not: String
  reserveToken_not_contains: String
  reserveToken_not_ends_with: String
  reserveToken_not_in: [String!]
  reserveToken_not_starts_with: String
  reserveToken_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  type: LiquidityHistoryType
  type_in: [LiquidityHistoryType!]
  type_not: LiquidityHistoryType
  type_not_in: [LiquidityHistoryType!]
  user: String
  userLiquidityHistory: String
  userLiquidityHistory_contains: String
  userLiquidityHistory_ends_with: String
  userLiquidityHistory_gt: String
  userLiquidityHistory_gte: String
  userLiquidityHistory_in: [String!]
  userLiquidityHistory_lt: String
  userLiquidityHistory_lte: String
  userLiquidityHistory_not: String
  userLiquidityHistory_not_contains: String
  userLiquidityHistory_not_ends_with: String
  userLiquidityHistory_not_in: [String!]
  userLiquidityHistory_not_starts_with: String
  userLiquidityHistory_starts_with: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum LiquidityHistoryItem_orderBy {
  amount
  emittedBy
  id
  liquidityPool
  newBalance
  newSupply
  provider
  reserveToken
  timestamp
  transaction
  type
  user
  userLiquidityHistory
}

enum LiquidityHistoryType {
  Added
  Removed
}

"""
AMM Pool (sometimes referred to as a Converter)
"""
type LiquidityPool {
  """
  Activated with be true when this pool is activated, and will change to false is the pool is deactivated
  """
  activated: Boolean
  connectorTokens(
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]!
  conversionFee: BigInt
  createdAtBlockNumber: BigInt
  createdAtTimestamp: BigInt
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry

  """
  ID is the contract address of the Converter
  """
  id: ID!
  lastResetBlockNumber: BigInt
  lastResetTimestamp: BigInt
  maxConversionFee: BigInt
  owner: String
  poolTokens(
    first: Int = 100
    orderBy: TokenPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: TokenPoolToken_filter
  ): [TokenPoolToken!]!
  smartToken: SmartToken

  """
  The reserve assets of this AMM Pool. The are stored here like this so that they can be accessed inside mappings when the LiquidityPool is loaded.
  """
  token0: Token
  token1: Token

  """
  Sovryn uses Bancor V1 and Bancor V2 pools
  """
  type: Int
  version: Int
  weight: BigInt
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type LiquidityPoolAdded {
  _liquidityPool: Bytes!
  emittedBy: Bytes!
  id: ID!
  timestamp: BigInt!
  transaction: Transaction!
}

input LiquidityPoolAdded_filter {
  _liquidityPool: Bytes
  _liquidityPool_contains: Bytes
  _liquidityPool_in: [Bytes!]
  _liquidityPool_not: Bytes
  _liquidityPool_not_contains: Bytes
  _liquidityPool_not_in: [Bytes!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum LiquidityPoolAdded_orderBy {
  _liquidityPool
  emittedBy
  id
  timestamp
  transaction
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type LiquidityPoolRemoved {
  _liquidityPool: Bytes!
  emittedBy: Bytes!
  id: ID!
  timestamp: BigInt!
  transaction: Transaction!
}

input LiquidityPoolRemoved_filter {
  _liquidityPool: Bytes
  _liquidityPool_contains: Bytes
  _liquidityPool_in: [Bytes!]
  _liquidityPool_not: Bytes
  _liquidityPool_not_contains: Bytes
  _liquidityPool_not_in: [Bytes!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum LiquidityPoolRemoved_orderBy {
  _liquidityPool
  emittedBy
  id
  timestamp
  transaction
}

"""
This entity stores the relationship between liquidity pools and underlying tokens
It also currently stores the total volumes bought and so
"""
type LiquidityPoolToken {
  """
  ID is liquidityPool address + tokenAddress
  """
  id: ID!
  liquidityPool: LiquidityPool!

  """
  The pool token that represents this token-liquidityPool relationship
  """
  poolToken: PoolToken!
  token: Token!
  totalVolume: BigDecimal!
  volumeBought: BigDecimal!
  volumeSold: BigDecimal!
}

input LiquidityPoolToken_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPool: String
  liquidityPool_contains: String
  liquidityPool_ends_with: String
  liquidityPool_gt: String
  liquidityPool_gte: String
  liquidityPool_in: [String!]
  liquidityPool_lt: String
  liquidityPool_lte: String
  liquidityPool_not: String
  liquidityPool_not_contains: String
  liquidityPool_not_ends_with: String
  liquidityPool_not_in: [String!]
  liquidityPool_not_starts_with: String
  liquidityPool_starts_with: String
  poolToken: String
  poolToken_contains: String
  poolToken_ends_with: String
  poolToken_gt: String
  poolToken_gte: String
  poolToken_in: [String!]
  poolToken_lt: String
  poolToken_lte: String
  poolToken_not: String
  poolToken_not_contains: String
  poolToken_not_ends_with: String
  poolToken_not_in: [String!]
  poolToken_not_starts_with: String
  poolToken_starts_with: String
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
  totalVolume: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_lt: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_not_in: [BigDecimal!]
  volumeBought: BigDecimal
  volumeBought_gt: BigDecimal
  volumeBought_gte: BigDecimal
  volumeBought_in: [BigDecimal!]
  volumeBought_lt: BigDecimal
  volumeBought_lte: BigDecimal
  volumeBought_not: BigDecimal
  volumeBought_not_in: [BigDecimal!]
  volumeSold: BigDecimal
  volumeSold_gt: BigDecimal
  volumeSold_gte: BigDecimal
  volumeSold_in: [BigDecimal!]
  volumeSold_lt: BigDecimal
  volumeSold_lte: BigDecimal
  volumeSold_not: BigDecimal
  volumeSold_not_in: [BigDecimal!]
}

enum LiquidityPoolToken_orderBy {
  id
  liquidityPool
  poolToken
  token
  totalVolume
  volumeBought
  volumeSold
}

input LiquidityPool_filter {
  activated: Boolean
  activated_in: [Boolean!]
  activated_not: Boolean
  activated_not_in: [Boolean!]
  conversionFee: BigInt
  conversionFee_gt: BigInt
  conversionFee_gte: BigInt
  conversionFee_in: [BigInt!]
  conversionFee_lt: BigInt
  conversionFee_lte: BigInt
  conversionFee_not: BigInt
  conversionFee_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_not_in: [BigInt!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_not_in: [BigInt!]
  createdAtTransaction: String
  createdAtTransaction_contains: String
  createdAtTransaction_ends_with: String
  createdAtTransaction_gt: String
  createdAtTransaction_gte: String
  createdAtTransaction_in: [String!]
  createdAtTransaction_lt: String
  createdAtTransaction_lte: String
  createdAtTransaction_not: String
  createdAtTransaction_not_contains: String
  createdAtTransaction_not_ends_with: String
  createdAtTransaction_not_in: [String!]
  createdAtTransaction_not_starts_with: String
  createdAtTransaction_starts_with: String
  currentConverterRegistry: String
  currentConverterRegistry_contains: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_lt: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_not: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_not_ends_with: String
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastResetBlockNumber: BigInt
  lastResetBlockNumber_gt: BigInt
  lastResetBlockNumber_gte: BigInt
  lastResetBlockNumber_in: [BigInt!]
  lastResetBlockNumber_lt: BigInt
  lastResetBlockNumber_lte: BigInt
  lastResetBlockNumber_not: BigInt
  lastResetBlockNumber_not_in: [BigInt!]
  lastResetTimestamp: BigInt
  lastResetTimestamp_gt: BigInt
  lastResetTimestamp_gte: BigInt
  lastResetTimestamp_in: [BigInt!]
  lastResetTimestamp_lt: BigInt
  lastResetTimestamp_lte: BigInt
  lastResetTimestamp_not: BigInt
  lastResetTimestamp_not_in: [BigInt!]
  maxConversionFee: BigInt
  maxConversionFee_gt: BigInt
  maxConversionFee_gte: BigInt
  maxConversionFee_in: [BigInt!]
  maxConversionFee_lt: BigInt
  maxConversionFee_lte: BigInt
  maxConversionFee_not: BigInt
  maxConversionFee_not_in: [BigInt!]
  owner: String
  owner_contains: String
  owner_ends_with: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_ends_with: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_starts_with: String
  smartToken: String
  smartToken_contains: String
  smartToken_ends_with: String
  smartToken_gt: String
  smartToken_gte: String
  smartToken_in: [String!]
  smartToken_lt: String
  smartToken_lte: String
  smartToken_not: String
  smartToken_not_contains: String
  smartToken_not_ends_with: String
  smartToken_not_in: [String!]
  smartToken_not_starts_with: String
  smartToken_starts_with: String
  token0: String
  token0_contains: String
  token0_ends_with: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_ends_with: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_starts_with: String
  token1: String
  token1_contains: String
  token1_ends_with: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_ends_with: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_starts_with: String
  type: Int
  type_gt: Int
  type_gte: Int
  type_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_not: Int
  type_not_in: [Int!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
  weight: BigInt
  weight_gt: BigInt
  weight_gte: BigInt
  weight_in: [BigInt!]
  weight_lt: BigInt
  weight_lte: BigInt
  weight_not: BigInt
  weight_not_in: [BigInt!]
}

enum LiquidityPool_orderBy {
  activated
  connectorTokens
  conversionFee
  createdAtBlockNumber
  createdAtTimestamp
  createdAtTransaction
  currentConverterRegistry
  id
  lastResetBlockNumber
  lastResetTimestamp
  maxConversionFee
  owner
  poolTokens
  smartToken
  token0
  token1
  type
  version
  weight
}

"""
A Loan can be initialized by either a Margin Trade event or a Borrow event
"""
type Loan {
  """
  Average price per token from all loan open events
  """
  averageBuyPrice: BigDecimal!

  """
  Average price per token from all loan close events
  """
  averageSellPrice: BigDecimal!
  borrow(
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Borrow_filter
  ): [Borrow!]

  """
  The amount borrowed in loan tokens
  """
  borrowedAmount: BigDecimal!
  closeWithSwaps(
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: CloseWithSwap_filter
  ): [CloseWithSwap!]
  closewithDeposits(
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: CloseWithDeposit_filter
  ): [CloseWithDeposit!]
  collateralToken: Token!
  depositCollateral(
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: DepositCollateral_filter
  ): [DepositCollateral!]
  endTimestamp: BigInt
  id: ID!

  """
  If a Liquidate, CloseWithSwap or CloseWithDeposit event occurs with 0 margin or 0 leverage, this property changes to false
  """
  isOpen: Boolean!
  liquidates(
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Liquidate_filter
  ): [Liquidate!]
  loanToken: Token!
  maxBorrowedAmount: BigDecimal!

  """
  The maximum this position size was - mainly for debugging purposes
  """
  maximumPositionSize: BigDecimal!

  """
  Total of collateral (user collateral in a Borrow, and user collateral + borrowed amount in a Trade) in collateral tokens
  """
  positionSize: BigDecimal!

  """
  The realized PnL is quoted in the collateral currency
  """
  realizedPnL: BigDecimal!
  realizedPnLPercent: BigDecimal!
  startBorrowedAmount: BigDecimal!

  """
  Initial size of the position
  """
  startPositionSize: BigDecimal!

  """
  The start rate of the loan in loan tokens (eg if it is a long USD/BTC margin trade, this is the BTC price in USD)
  """
  startRate: BigDecimal!
  startTimestamp: BigInt!

  """
  Sum of position volume from Trade, Borrow and DepositCollateral events in this loan, in collateral token
  """
  totalBought: BigDecimal!

  """
  Sum of position change volume from CloseWithSwap, CloseWithDeposit and Liquidate events in this loan, in collateral token
  """
  totalSold: BigDecimal!
  trade(
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Trade_filter
  ): [Trade!]

  """
  LoanType is either Trade (for Margin Trades) or Borrow (for Borrows)
  """
  type: LoanType!
  user: User!
}

enum LoanType {
  Borrow
  Trade
}

input Loan_filter {
  averageBuyPrice: BigDecimal
  averageBuyPrice_gt: BigDecimal
  averageBuyPrice_gte: BigDecimal
  averageBuyPrice_in: [BigDecimal!]
  averageBuyPrice_lt: BigDecimal
  averageBuyPrice_lte: BigDecimal
  averageBuyPrice_not: BigDecimal
  averageBuyPrice_not_in: [BigDecimal!]
  averageSellPrice: BigDecimal
  averageSellPrice_gt: BigDecimal
  averageSellPrice_gte: BigDecimal
  averageSellPrice_in: [BigDecimal!]
  averageSellPrice_lt: BigDecimal
  averageSellPrice_lte: BigDecimal
  averageSellPrice_not: BigDecimal
  averageSellPrice_not_in: [BigDecimal!]
  borrowedAmount: BigDecimal
  borrowedAmount_gt: BigDecimal
  borrowedAmount_gte: BigDecimal
  borrowedAmount_in: [BigDecimal!]
  borrowedAmount_lt: BigDecimal
  borrowedAmount_lte: BigDecimal
  borrowedAmount_not: BigDecimal
  borrowedAmount_not_in: [BigDecimal!]
  collateralToken: String
  collateralToken_contains: String
  collateralToken_ends_with: String
  collateralToken_gt: String
  collateralToken_gte: String
  collateralToken_in: [String!]
  collateralToken_lt: String
  collateralToken_lte: String
  collateralToken_not: String
  collateralToken_not_contains: String
  collateralToken_not_ends_with: String
  collateralToken_not_in: [String!]
  collateralToken_not_starts_with: String
  collateralToken_starts_with: String
  endTimestamp: BigInt
  endTimestamp_gt: BigInt
  endTimestamp_gte: BigInt
  endTimestamp_in: [BigInt!]
  endTimestamp_lt: BigInt
  endTimestamp_lte: BigInt
  endTimestamp_not: BigInt
  endTimestamp_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isOpen: Boolean
  isOpen_in: [Boolean!]
  isOpen_not: Boolean
  isOpen_not_in: [Boolean!]
  loanToken: String
  loanToken_contains: String
  loanToken_ends_with: String
  loanToken_gt: String
  loanToken_gte: String
  loanToken_in: [String!]
  loanToken_lt: String
  loanToken_lte: String
  loanToken_not: String
  loanToken_not_contains: String
  loanToken_not_ends_with: String
  loanToken_not_in: [String!]
  loanToken_not_starts_with: String
  loanToken_starts_with: String
  maxBorrowedAmount: BigDecimal
  maxBorrowedAmount_gt: BigDecimal
  maxBorrowedAmount_gte: BigDecimal
  maxBorrowedAmount_in: [BigDecimal!]
  maxBorrowedAmount_lt: BigDecimal
  maxBorrowedAmount_lte: BigDecimal
  maxBorrowedAmount_not: BigDecimal
  maxBorrowedAmount_not_in: [BigDecimal!]
  maximumPositionSize: BigDecimal
  maximumPositionSize_gt: BigDecimal
  maximumPositionSize_gte: BigDecimal
  maximumPositionSize_in: [BigDecimal!]
  maximumPositionSize_lt: BigDecimal
  maximumPositionSize_lte: BigDecimal
  maximumPositionSize_not: BigDecimal
  maximumPositionSize_not_in: [BigDecimal!]
  positionSize: BigDecimal
  positionSize_gt: BigDecimal
  positionSize_gte: BigDecimal
  positionSize_in: [BigDecimal!]
  positionSize_lt: BigDecimal
  positionSize_lte: BigDecimal
  positionSize_not: BigDecimal
  positionSize_not_in: [BigDecimal!]
  realizedPnL: BigDecimal
  realizedPnLPercent: BigDecimal
  realizedPnLPercent_gt: BigDecimal
  realizedPnLPercent_gte: BigDecimal
  realizedPnLPercent_in: [BigDecimal!]
  realizedPnLPercent_lt: BigDecimal
  realizedPnLPercent_lte: BigDecimal
  realizedPnLPercent_not: BigDecimal
  realizedPnLPercent_not_in: [BigDecimal!]
  realizedPnL_gt: BigDecimal
  realizedPnL_gte: BigDecimal
  realizedPnL_in: [BigDecimal!]
  realizedPnL_lt: BigDecimal
  realizedPnL_lte: BigDecimal
  realizedPnL_not: BigDecimal
  realizedPnL_not_in: [BigDecimal!]
  startBorrowedAmount: BigDecimal
  startBorrowedAmount_gt: BigDecimal
  startBorrowedAmount_gte: BigDecimal
  startBorrowedAmount_in: [BigDecimal!]
  startBorrowedAmount_lt: BigDecimal
  startBorrowedAmount_lte: BigDecimal
  startBorrowedAmount_not: BigDecimal
  startBorrowedAmount_not_in: [BigDecimal!]
  startPositionSize: BigDecimal
  startPositionSize_gt: BigDecimal
  startPositionSize_gte: BigDecimal
  startPositionSize_in: [BigDecimal!]
  startPositionSize_lt: BigDecimal
  startPositionSize_lte: BigDecimal
  startPositionSize_not: BigDecimal
  startPositionSize_not_in: [BigDecimal!]
  startRate: BigDecimal
  startRate_gt: BigDecimal
  startRate_gte: BigDecimal
  startRate_in: [BigDecimal!]
  startRate_lt: BigDecimal
  startRate_lte: BigDecimal
  startRate_not: BigDecimal
  startRate_not_in: [BigDecimal!]
  startTimestamp: BigInt
  startTimestamp_gt: BigInt
  startTimestamp_gte: BigInt
  startTimestamp_in: [BigInt!]
  startTimestamp_lt: BigInt
  startTimestamp_lte: BigInt
  startTimestamp_not: BigInt
  startTimestamp_not_in: [BigInt!]
  totalBought: BigDecimal
  totalBought_gt: BigDecimal
  totalBought_gte: BigDecimal
  totalBought_in: [BigDecimal!]
  totalBought_lt: BigDecimal
  totalBought_lte: BigDecimal
  totalBought_not: BigDecimal
  totalBought_not_in: [BigDecimal!]
  totalSold: BigDecimal
  totalSold_gt: BigDecimal
  totalSold_gte: BigDecimal
  totalSold_in: [BigDecimal!]
  totalSold_lt: BigDecimal
  totalSold_lte: BigDecimal
  totalSold_not: BigDecimal
  totalSold_not_in: [BigDecimal!]
  type: LoanType
  type_in: [LoanType!]
  type_not: LoanType
  type_not_in: [LoanType!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum Loan_orderBy {
  averageBuyPrice
  averageSellPrice
  borrow
  borrowedAmount
  closeWithSwaps
  closewithDeposits
  collateralToken
  depositCollateral
  endTimestamp
  id
  isOpen
  liquidates
  loanToken
  maxBorrowedAmount
  maximumPositionSize
  positionSize
  realizedPnL
  realizedPnLPercent
  startBorrowedAmount
  startPositionSize
  startRate
  startTimestamp
  totalBought
  totalSold
  trade
  type
  user
}

type NewConverter {
  _converter: Bytes!
  _owner: Bytes!
  _type: Int!
  id: ID!
  timestamp: BigInt!
  transaction: Transaction!
}

input NewConverter_filter {
  _converter: Bytes
  _converter_contains: Bytes
  _converter_in: [Bytes!]
  _converter_not: Bytes
  _converter_not_contains: Bytes
  _converter_not_in: [Bytes!]
  _owner: Bytes
  _owner_contains: Bytes
  _owner_in: [Bytes!]
  _owner_not: Bytes
  _owner_not_contains: Bytes
  _owner_not_in: [Bytes!]
  _type: Int
  _type_gt: Int
  _type_gte: Int
  _type_in: [Int!]
  _type_lt: Int
  _type_lte: Int
  _type_not: Int
  _type_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum NewConverter_orderBy {
  _converter
  _owner
  _type
  id
  timestamp
  transaction
}

enum OrderDirection {
  asc
  desc
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows and when a loan is rolled over
"""
type PayBorrowingFee {
  amount: BigInt!
  emittedBy: Bytes!
  id: ID!
  loanId: Loan!
  payer: Bytes!
  timestamp: BigInt!
  token: Bytes!
  transaction: Transaction!
}

input PayBorrowingFee_filter {
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  payer: Bytes
  payer_contains: Bytes
  payer_in: [Bytes!]
  payer_not: Bytes
  payer_not_contains: Bytes
  payer_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum PayBorrowingFee_orderBy {
  amount
  emittedBy
  id
  loanId
  payer
  timestamp
  token
  transaction
}

"""
Granular event data for the Loan entity. Emitted when a user Lends or Unlends and when a loan is rolled over
"""
type PayLendingFee {
  amount: BigInt!
  emittedBy: Bytes!
  id: ID!
  payer: Bytes!
  timestamp: BigInt!
  token: Bytes!
  transaction: Transaction!
}

input PayLendingFee_filter {
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  payer: Bytes
  payer_contains: Bytes
  payer_in: [Bytes!]
  payer_not: Bytes
  payer_not_contains: Bytes
  payer_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum PayLendingFee_orderBy {
  amount
  emittedBy
  id
  payer
  timestamp
  token
  transaction
}

"""
Granular event data for the Loan entity. Emitted when a user Margin Trades and when a loan is rolled over
"""
type PayTradingFee {
  amount: BigInt!
  emittedBy: Bytes!
  id: ID!
  loanId: Loan!
  payer: Bytes!
  timestamp: BigInt!
  token: Bytes!
  transaction: Transaction!
}

input PayTradingFee_filter {
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  payer: Bytes
  payer_contains: Bytes
  payer_in: [Bytes!]
  payer_not: Bytes
  payer_not_contains: Bytes
  payer_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum PayTradingFee_orderBy {
  amount
  emittedBy
  id
  loanId
  payer
  timestamp
  token
  transaction
}

"""
For the V1 pools, the pool token and smart token are the same. However, for V2 pools, there is one pool token per asset and only one smart token for the pool.
"""
type PoolToken {
  converters(
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]
  decimals: Int
  id: ID!
  name: String
  symbol: String
  underlyingAssets(
    first: Int = 100
    orderBy: TokenPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: TokenPoolToken_filter
  ): [TokenPoolToken!]
}

input PoolToken_filter {
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  symbol: String
  symbol_contains: String
  symbol_ends_with: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_ends_with: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_starts_with: String
}

enum PoolToken_orderBy {
  converters
  decimals
  id
  name
  symbol
  underlyingAssets
}

type Proposal {
  canceled: Transaction
  countVotersAgainst: BigInt!
  countVotersFor: BigInt!
  created: Transaction!
  description: String!
  emittedBy: Bytes!
  endBlock: BigInt!
  executed: Transaction
  id: ID!
  proposalId: BigInt!
  proposer: Bytes!
  queued: Transaction
  signatures: [String!]!
  startBlock: BigInt!
  targets: [String!]!
  timestamp: BigInt!
  values: [BigInt!]!
  votes(
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VoteCast_filter
  ): [VoteCast!]
  votesAgainst: BigInt!
  votesFor: BigInt!
}

input Proposal_filter {
  canceled: String
  canceled_contains: String
  canceled_ends_with: String
  canceled_gt: String
  canceled_gte: String
  canceled_in: [String!]
  canceled_lt: String
  canceled_lte: String
  canceled_not: String
  canceled_not_contains: String
  canceled_not_ends_with: String
  canceled_not_in: [String!]
  canceled_not_starts_with: String
  canceled_starts_with: String
  countVotersAgainst: BigInt
  countVotersAgainst_gt: BigInt
  countVotersAgainst_gte: BigInt
  countVotersAgainst_in: [BigInt!]
  countVotersAgainst_lt: BigInt
  countVotersAgainst_lte: BigInt
  countVotersAgainst_not: BigInt
  countVotersAgainst_not_in: [BigInt!]
  countVotersFor: BigInt
  countVotersFor_gt: BigInt
  countVotersFor_gte: BigInt
  countVotersFor_in: [BigInt!]
  countVotersFor_lt: BigInt
  countVotersFor_lte: BigInt
  countVotersFor_not: BigInt
  countVotersFor_not_in: [BigInt!]
  created: String
  created_contains: String
  created_ends_with: String
  created_gt: String
  created_gte: String
  created_in: [String!]
  created_lt: String
  created_lte: String
  created_not: String
  created_not_contains: String
  created_not_ends_with: String
  created_not_in: [String!]
  created_not_starts_with: String
  created_starts_with: String
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  endBlock: BigInt
  endBlock_gt: BigInt
  endBlock_gte: BigInt
  endBlock_in: [BigInt!]
  endBlock_lt: BigInt
  endBlock_lte: BigInt
  endBlock_not: BigInt
  endBlock_not_in: [BigInt!]
  executed: String
  executed_contains: String
  executed_ends_with: String
  executed_gt: String
  executed_gte: String
  executed_in: [String!]
  executed_lt: String
  executed_lte: String
  executed_not: String
  executed_not_contains: String
  executed_not_ends_with: String
  executed_not_in: [String!]
  executed_not_starts_with: String
  executed_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  proposalId: BigInt
  proposalId_gt: BigInt
  proposalId_gte: BigInt
  proposalId_in: [BigInt!]
  proposalId_lt: BigInt
  proposalId_lte: BigInt
  proposalId_not: BigInt
  proposalId_not_in: [BigInt!]
  proposer: Bytes
  proposer_contains: Bytes
  proposer_in: [Bytes!]
  proposer_not: Bytes
  proposer_not_contains: Bytes
  proposer_not_in: [Bytes!]
  queued: String
  queued_contains: String
  queued_ends_with: String
  queued_gt: String
  queued_gte: String
  queued_in: [String!]
  queued_lt: String
  queued_lte: String
  queued_not: String
  queued_not_contains: String
  queued_not_ends_with: String
  queued_not_in: [String!]
  queued_not_starts_with: String
  queued_starts_with: String
  signatures: [String!]
  signatures_contains: [String!]
  signatures_not: [String!]
  signatures_not_contains: [String!]
  startBlock: BigInt
  startBlock_gt: BigInt
  startBlock_gte: BigInt
  startBlock_in: [BigInt!]
  startBlock_lt: BigInt
  startBlock_lte: BigInt
  startBlock_not: BigInt
  startBlock_not_in: [BigInt!]
  targets: [String!]
  targets_contains: [String!]
  targets_not: [String!]
  targets_not_contains: [String!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  values: [BigInt!]
  values_contains: [BigInt!]
  values_not: [BigInt!]
  values_not_contains: [BigInt!]
  votesAgainst: BigInt
  votesAgainst_gt: BigInt
  votesAgainst_gte: BigInt
  votesAgainst_in: [BigInt!]
  votesAgainst_lt: BigInt
  votesAgainst_lte: BigInt
  votesAgainst_not: BigInt
  votesAgainst_not_in: [BigInt!]
  votesFor: BigInt
  votesFor_gt: BigInt
  votesFor_gte: BigInt
  votesFor_in: [BigInt!]
  votesFor_lt: BigInt
  votesFor_lte: BigInt
  votesFor_not: BigInt
  votesFor_not_in: [BigInt!]
}

enum Proposal_orderBy {
  canceled
  countVotersAgainst
  countVotersFor
  created
  description
  emittedBy
  endBlock
  executed
  id
  proposalId
  proposer
  queued
  signatures
  startBlock
  targets
  timestamp
  values
  votes
  votesAgainst
  votesFor
}

"""
This entity will have only one instance and will be used to store protocol-wide data like list of tokens and number or users.
The ID of this one entity is "0"
"""
type ProtocolStats {
  btcUsdPrice: BigDecimal!

  """
  Only one entity should be created, with ID "0"
  """
  id: ID!

  """
  An array of all tokens in the protocol
  """
  tokens(
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Token_filter
  ): [Token!]!

  """
  Total volume of fees earned by liquidity providers to AMM pools (in usd)
  """
  totalAmmLpFeesUsd: BigDecimal!

  """
  Total volume of fees earned by SOV stakers from AMM conversion events (in usd). These fees began after the fee-sharing SIP was executed.
  """
  totalAmmStakerFeesUsd: BigDecimal!

  """
  Total volume that has passed through every AMM pool of the Sovryn protocol (in usd)
  """
  totalAmmVolumeUsd: BigDecimal!

  """
  Total of collateral property in Trade event (in usd). This may be changed to borrowed amount volume, but collateral keeps it consistent with margin trading
  """
  totalBorrowVolumeUsd: BigDecimal!

  """
  Total fees from Borrowing earned by SOV stakers (in usd)
  """
  totalBorrowingFeesUsd: BigDecimal!

  """
  Total volume of Borrows closed (in usd)
  """
  totalCloseWithDepositVolumeUsd: BigDecimal!

  """
  Total position volume closed for Margin Trades (in usd)
  """
  totalCloseWithSwapVolumeUsd: BigDecimal!

  """
  Total additional collateral deposited for Margin Trades and Borrows (in usd)
  """
  totalDepositCollateralVolumeUsd: BigDecimal!

  """
  Total volume supplied to Lending Pools over all time (in usd)
  """
  totalLendVolumeUsd: BigDecimal!

  """
  Total fees from Lending and Unlending earned by SOV stakers (in usd)
  """
  totalLendingFeesUsd: BigDecimal!

  """
  Total Margin Trade and Borrow position size that has been liquidated (in usd)
  """
  totalLiquidateVolumeUsd: BigDecimal!

  """
  Total of positionSize property in Trade event (in usd). This includes user collateral and borrowed amount
  """
  totalMarginTradeVolumeUsd: BigDecimal!

  """
  This is SOV staked by vesting contracts. It in incremented when the contracts stake the tokens, and decremented when users claim their unlocked tokens
  """
  totalStakedByVestingSov: BigInt!

  """
  Total fees from Margin Trading earned by SOV stakers (in usd)
  """
  totalTradingFeesUsd: BigDecimal!

  """
  NOT YET IMPLEMENTED: This will be a total of volumes of all transaction types (AMM Swaps, Margin Trades, CloseWithSwap etc etc)
  """
  totalTransactedVolumeUsd: BigInt!

  """
  Total volume withdrawn from Lending Pool over all time (in usd)
  """
  totalUnlendVolumeUsd: BigDecimal!

  """
  Total number of users of the protocol. This number is incremented each time a user initiates a transaction with the Protocol.
  Currently this is incremented by specific user actions, but could be incremented on a per Transaction basis.
  """
  totalUsers: BigInt!

  """
  This is SOV staked by users (not vesting contracts). It is incremented when users stake tokens, and decremented when users withdraw tokens from the staking contract
  """
  totalVoluntarilyStakedSov: BigInt!
  usdStablecoin: Token!
}

input ProtocolStats_filter {
  btcUsdPrice: BigDecimal
  btcUsdPrice_gt: BigDecimal
  btcUsdPrice_gte: BigDecimal
  btcUsdPrice_in: [BigDecimal!]
  btcUsdPrice_lt: BigDecimal
  btcUsdPrice_lte: BigDecimal
  btcUsdPrice_not: BigDecimal
  btcUsdPrice_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  tokens: [String!]
  tokens_contains: [String!]
  tokens_not: [String!]
  tokens_not_contains: [String!]
  totalAmmLpFeesUsd: BigDecimal
  totalAmmLpFeesUsd_gt: BigDecimal
  totalAmmLpFeesUsd_gte: BigDecimal
  totalAmmLpFeesUsd_in: [BigDecimal!]
  totalAmmLpFeesUsd_lt: BigDecimal
  totalAmmLpFeesUsd_lte: BigDecimal
  totalAmmLpFeesUsd_not: BigDecimal
  totalAmmLpFeesUsd_not_in: [BigDecimal!]
  totalAmmStakerFeesUsd: BigDecimal
  totalAmmStakerFeesUsd_gt: BigDecimal
  totalAmmStakerFeesUsd_gte: BigDecimal
  totalAmmStakerFeesUsd_in: [BigDecimal!]
  totalAmmStakerFeesUsd_lt: BigDecimal
  totalAmmStakerFeesUsd_lte: BigDecimal
  totalAmmStakerFeesUsd_not: BigDecimal
  totalAmmStakerFeesUsd_not_in: [BigDecimal!]
  totalAmmVolumeUsd: BigDecimal
  totalAmmVolumeUsd_gt: BigDecimal
  totalAmmVolumeUsd_gte: BigDecimal
  totalAmmVolumeUsd_in: [BigDecimal!]
  totalAmmVolumeUsd_lt: BigDecimal
  totalAmmVolumeUsd_lte: BigDecimal
  totalAmmVolumeUsd_not: BigDecimal
  totalAmmVolumeUsd_not_in: [BigDecimal!]
  totalBorrowVolumeUsd: BigDecimal
  totalBorrowVolumeUsd_gt: BigDecimal
  totalBorrowVolumeUsd_gte: BigDecimal
  totalBorrowVolumeUsd_in: [BigDecimal!]
  totalBorrowVolumeUsd_lt: BigDecimal
  totalBorrowVolumeUsd_lte: BigDecimal
  totalBorrowVolumeUsd_not: BigDecimal
  totalBorrowVolumeUsd_not_in: [BigDecimal!]
  totalBorrowingFeesUsd: BigDecimal
  totalBorrowingFeesUsd_gt: BigDecimal
  totalBorrowingFeesUsd_gte: BigDecimal
  totalBorrowingFeesUsd_in: [BigDecimal!]
  totalBorrowingFeesUsd_lt: BigDecimal
  totalBorrowingFeesUsd_lte: BigDecimal
  totalBorrowingFeesUsd_not: BigDecimal
  totalBorrowingFeesUsd_not_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd: BigDecimal
  totalCloseWithDepositVolumeUsd_gt: BigDecimal
  totalCloseWithDepositVolumeUsd_gte: BigDecimal
  totalCloseWithDepositVolumeUsd_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd_lt: BigDecimal
  totalCloseWithDepositVolumeUsd_lte: BigDecimal
  totalCloseWithDepositVolumeUsd_not: BigDecimal
  totalCloseWithDepositVolumeUsd_not_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd: BigDecimal
  totalCloseWithSwapVolumeUsd_gt: BigDecimal
  totalCloseWithSwapVolumeUsd_gte: BigDecimal
  totalCloseWithSwapVolumeUsd_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd_lt: BigDecimal
  totalCloseWithSwapVolumeUsd_lte: BigDecimal
  totalCloseWithSwapVolumeUsd_not: BigDecimal
  totalCloseWithSwapVolumeUsd_not_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd: BigDecimal
  totalDepositCollateralVolumeUsd_gt: BigDecimal
  totalDepositCollateralVolumeUsd_gte: BigDecimal
  totalDepositCollateralVolumeUsd_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd_lt: BigDecimal
  totalDepositCollateralVolumeUsd_lte: BigDecimal
  totalDepositCollateralVolumeUsd_not: BigDecimal
  totalDepositCollateralVolumeUsd_not_in: [BigDecimal!]
  totalLendVolumeUsd: BigDecimal
  totalLendVolumeUsd_gt: BigDecimal
  totalLendVolumeUsd_gte: BigDecimal
  totalLendVolumeUsd_in: [BigDecimal!]
  totalLendVolumeUsd_lt: BigDecimal
  totalLendVolumeUsd_lte: BigDecimal
  totalLendVolumeUsd_not: BigDecimal
  totalLendVolumeUsd_not_in: [BigDecimal!]
  totalLendingFeesUsd: BigDecimal
  totalLendingFeesUsd_gt: BigDecimal
  totalLendingFeesUsd_gte: BigDecimal
  totalLendingFeesUsd_in: [BigDecimal!]
  totalLendingFeesUsd_lt: BigDecimal
  totalLendingFeesUsd_lte: BigDecimal
  totalLendingFeesUsd_not: BigDecimal
  totalLendingFeesUsd_not_in: [BigDecimal!]
  totalLiquidateVolumeUsd: BigDecimal
  totalLiquidateVolumeUsd_gt: BigDecimal
  totalLiquidateVolumeUsd_gte: BigDecimal
  totalLiquidateVolumeUsd_in: [BigDecimal!]
  totalLiquidateVolumeUsd_lt: BigDecimal
  totalLiquidateVolumeUsd_lte: BigDecimal
  totalLiquidateVolumeUsd_not: BigDecimal
  totalLiquidateVolumeUsd_not_in: [BigDecimal!]
  totalMarginTradeVolumeUsd: BigDecimal
  totalMarginTradeVolumeUsd_gt: BigDecimal
  totalMarginTradeVolumeUsd_gte: BigDecimal
  totalMarginTradeVolumeUsd_in: [BigDecimal!]
  totalMarginTradeVolumeUsd_lt: BigDecimal
  totalMarginTradeVolumeUsd_lte: BigDecimal
  totalMarginTradeVolumeUsd_not: BigDecimal
  totalMarginTradeVolumeUsd_not_in: [BigDecimal!]
  totalStakedByVestingSov: BigInt
  totalStakedByVestingSov_gt: BigInt
  totalStakedByVestingSov_gte: BigInt
  totalStakedByVestingSov_in: [BigInt!]
  totalStakedByVestingSov_lt: BigInt
  totalStakedByVestingSov_lte: BigInt
  totalStakedByVestingSov_not: BigInt
  totalStakedByVestingSov_not_in: [BigInt!]
  totalTradingFeesUsd: BigDecimal
  totalTradingFeesUsd_gt: BigDecimal
  totalTradingFeesUsd_gte: BigDecimal
  totalTradingFeesUsd_in: [BigDecimal!]
  totalTradingFeesUsd_lt: BigDecimal
  totalTradingFeesUsd_lte: BigDecimal
  totalTradingFeesUsd_not: BigDecimal
  totalTradingFeesUsd_not_in: [BigDecimal!]
  totalTransactedVolumeUsd: BigInt
  totalTransactedVolumeUsd_gt: BigInt
  totalTransactedVolumeUsd_gte: BigInt
  totalTransactedVolumeUsd_in: [BigInt!]
  totalTransactedVolumeUsd_lt: BigInt
  totalTransactedVolumeUsd_lte: BigInt
  totalTransactedVolumeUsd_not: BigInt
  totalTransactedVolumeUsd_not_in: [BigInt!]
  totalUnlendVolumeUsd: BigDecimal
  totalUnlendVolumeUsd_gt: BigDecimal
  totalUnlendVolumeUsd_gte: BigDecimal
  totalUnlendVolumeUsd_in: [BigDecimal!]
  totalUnlendVolumeUsd_lt: BigDecimal
  totalUnlendVolumeUsd_lte: BigDecimal
  totalUnlendVolumeUsd_not: BigDecimal
  totalUnlendVolumeUsd_not_in: [BigDecimal!]
  totalUsers: BigInt
  totalUsers_gt: BigInt
  totalUsers_gte: BigInt
  totalUsers_in: [BigInt!]
  totalUsers_lt: BigInt
  totalUsers_lte: BigInt
  totalUsers_not: BigInt
  totalUsers_not_in: [BigInt!]
  totalVoluntarilyStakedSov: BigInt
  totalVoluntarilyStakedSov_gt: BigInt
  totalVoluntarilyStakedSov_gte: BigInt
  totalVoluntarilyStakedSov_in: [BigInt!]
  totalVoluntarilyStakedSov_lt: BigInt
  totalVoluntarilyStakedSov_lte: BigInt
  totalVoluntarilyStakedSov_not: BigInt
  totalVoluntarilyStakedSov_not_in: [BigInt!]
  usdStablecoin: String
  usdStablecoin_contains: String
  usdStablecoin_ends_with: String
  usdStablecoin_gt: String
  usdStablecoin_gte: String
  usdStablecoin_in: [String!]
  usdStablecoin_lt: String
  usdStablecoin_lte: String
  usdStablecoin_not: String
  usdStablecoin_not_contains: String
  usdStablecoin_not_ends_with: String
  usdStablecoin_not_in: [String!]
  usdStablecoin_not_starts_with: String
  usdStablecoin_starts_with: String
}

enum ProtocolStats_orderBy {
  btcUsdPrice
  id
  tokens
  totalAmmLpFeesUsd
  totalAmmStakerFeesUsd
  totalAmmVolumeUsd
  totalBorrowVolumeUsd
  totalBorrowingFeesUsd
  totalCloseWithDepositVolumeUsd
  totalCloseWithSwapVolumeUsd
  totalDepositCollateralVolumeUsd
  totalLendVolumeUsd
  totalLendingFeesUsd
  totalLiquidateVolumeUsd
  totalMarginTradeVolumeUsd
  totalStakedByVestingSov
  totalTradingFeesUsd
  totalTransactedVolumeUsd
  totalUnlendVolumeUsd
  totalUsers
  totalVoluntarilyStakedSov
  usdStablecoin
}

type Query {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  borrow(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Borrow
  borrows(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Borrow_filter
  ): [Borrow!]!
  candleStick(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStick
  candleSticks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStick_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStick_filter
  ): [CandleStick!]!
  closeWithDeposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithDeposit
  closeWithDeposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithDeposit_filter
  ): [CloseWithDeposit!]!
  closeWithSwap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithSwap
  closeWithSwaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithSwap_filter
  ): [CloseWithSwap!]!
  conversion(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Conversion_filter
  ): [Conversion!]!
  converterRegistries(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ConverterRegistry_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ConverterRegistry_filter
  ): [ConverterRegistry!]!
  converterRegistry(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConverterRegistry
  depositCollateral(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositCollateral
  depositCollaterals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DepositCollateral_filter
  ): [DepositCollateral!]!
  feeSharingTokensTransferred(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeSharingTokensTransferred
  feeSharingTokensTransferreds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeSharingTokensTransferred_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeSharingTokensTransferred_filter
  ): [FeeSharingTokensTransferred!]!
  lendingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingHistoryItem
  lendingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingHistoryItem_filter
  ): [LendingHistoryItem!]!
  lendingPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingPool
  lendingPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingPool_filter
  ): [LendingPool!]!
  liquidate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidate
  liquidates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Liquidate_filter
  ): [Liquidate!]!
  liquidityHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityHistoryItem
  liquidityHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityHistoryItem_filter
  ): [LiquidityHistoryItem!]!
  liquidityPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPoolAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolAdded
  liquidityPoolAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPoolAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPoolAdded_filter
  ): [LiquidityPoolAdded!]!
  liquidityPoolRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolRemoved
  liquidityPoolRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPoolRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPoolRemoved_filter
  ): [LiquidityPoolRemoved!]!
  liquidityPoolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolToken
  liquidityPoolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]!
  liquidityPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPool_filter
  ): [LiquidityPool!]!
  loan(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loans(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Loan_filter
  ): [Loan!]!
  newConverter(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewConverter
  newConverters(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NewConverter_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NewConverter_filter
  ): [NewConverter!]!
  payBorrowingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayBorrowingFee
  payBorrowingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayBorrowingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayBorrowingFee_filter
  ): [PayBorrowingFee!]!
  payLendingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayLendingFee
  payLendingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayLendingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayLendingFee_filter
  ): [PayLendingFee!]!
  payTradingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayTradingFee
  payTradingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayTradingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayTradingFee_filter
  ): [PayTradingFee!]!
  poolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolToken_filter
  ): [PoolToken!]!
  proposal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Proposal_filter
  ): [Proposal!]!
  protocolStats(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ProtocolStats_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ProtocolStats_filter
  ): [ProtocolStats!]!
  rewardsEarnedHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardsEarnedHistoryItem
  rewardsEarnedHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardsEarnedHistoryItem_filter
  ): [RewardsEarnedHistoryItem!]!
  smartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartToken
  smartTokenAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartTokenAdded
  smartTokenAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SmartTokenAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SmartTokenAdded_filter
  ): [SmartTokenAdded!]!
  smartTokenRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartTokenRemoved
  smartTokenRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SmartTokenRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SmartTokenRemoved_filter
  ): [SmartTokenRemoved!]!
  smartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SmartToken_filter
  ): [SmartToken!]!
  stakeHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistoryItem
  stakeHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StakeHistoryItem_filter
  ): [StakeHistoryItem!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenPoolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenPoolToken
  tokenPoolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenPoolToken_filter
  ): [TokenPoolToken!]!
  tokenSmartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSmartToken
  tokenSmartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  tokensStaked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensStaked
  tokensStakeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokensStaked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokensStaked_filter
  ): [TokensStaked!]!
  trade(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Trade_filter
  ): [Trade!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userLendingHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLendingHistory_filter
  ): [UserLendingHistory!]!
  userLendingHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLendingHistory
  userLiquidityHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLiquidityHistory_filter
  ): [UserLiquidityHistory!]!
  userLiquidityHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLiquidityHistory
  userRewardsEarnedHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserRewardsEarnedHistory_filter
  ): [UserRewardsEarnedHistory!]!
  userRewardsEarnedHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserRewardsEarnedHistory
  userStakeHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserStakeHistory_filter
  ): [UserStakeHistory!]!
  userStakeHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserStakeHistory
  userTotal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserTotal
  userTotals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserTotal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserTotal_filter
  ): [UserTotal!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  vestingContract(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingContract
  vestingContracts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingContract_filter
  ): [VestingContract!]!
  vestingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingHistoryItem
  vestingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingHistoryItem_filter
  ): [VestingHistoryItem!]!
  voteCast(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteCast
  voteCasts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VoteCast_filter
  ): [VoteCast!]!
}

enum RewardsEarnedAction {
  EarnReward
  RewardClaimed
  RewardSovStaked
  StakingRewardWithdrawn
}

type RewardsEarnedHistoryItem {
  action: RewardsEarnedAction!
  amount: BigInt!
  id: ID!
  timestamp: BigInt!
  token: Token
  transaction: Transaction!
  user: UserRewardsEarnedHistory!
}

input RewardsEarnedHistoryItem_filter {
  action: RewardsEarnedAction
  action_in: [RewardsEarnedAction!]
  action_not: RewardsEarnedAction
  action_not_in: [RewardsEarnedAction!]
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum RewardsEarnedHistoryItem_orderBy {
  action
  amount
  id
  timestamp
  token
  transaction
  user
}

"""
The smart token represents a single reserve asset on a single pool.
For V1 pools, there is 1 smart token representing both reserve assets. For V2 pools, there are 2 smart tokens, one for each reserve asset.
"""
type SmartToken {
  addedToRegistryBlockNumber: BigInt
  addedToRegistryTransactionHash: Bytes

  """
  connectorTokens are the entity that holds the many-to-many relationship between the underlying token asset and the smart token
  """
  connectorTokens(
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]
  currentConverterRegistry: ConverterRegistry
  decimals: Int

  """
  ID is smart token address
  """
  id: ID!

  """
  The AMM pool this smart token "belongs" to
  """
  liquidityPool: LiquidityPool!
  name: String
  owner: Bytes!

  """
  smartTokenType can be Relay or Liquid
  """
  smartTokenType: String
  symbol: String
  transfersEnabled: Boolean
  version: Int
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type SmartTokenAdded {
  _smartToken: Bytes!
  emittedBy: Bytes!
  id: ID!
  timestamp: BigInt!
  transaction: Transaction!
}

input SmartTokenAdded_filter {
  _smartToken: Bytes
  _smartToken_contains: Bytes
  _smartToken_in: [Bytes!]
  _smartToken_not: Bytes
  _smartToken_not_contains: Bytes
  _smartToken_not_in: [Bytes!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum SmartTokenAdded_orderBy {
  _smartToken
  emittedBy
  id
  timestamp
  transaction
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type SmartTokenRemoved {
  _smartToken: Bytes!
  emittedBy: Bytes!
  id: ID!
  timestamp: BigInt!
  transaction: Transaction!
}

input SmartTokenRemoved_filter {
  _smartToken: Bytes
  _smartToken_contains: Bytes
  _smartToken_in: [Bytes!]
  _smartToken_not: Bytes
  _smartToken_not_contains: Bytes
  _smartToken_not_in: [Bytes!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum SmartTokenRemoved_orderBy {
  _smartToken
  emittedBy
  id
  timestamp
  transaction
}

input SmartToken_filter {
  addedToRegistryBlockNumber: BigInt
  addedToRegistryBlockNumber_gt: BigInt
  addedToRegistryBlockNumber_gte: BigInt
  addedToRegistryBlockNumber_in: [BigInt!]
  addedToRegistryBlockNumber_lt: BigInt
  addedToRegistryBlockNumber_lte: BigInt
  addedToRegistryBlockNumber_not: BigInt
  addedToRegistryBlockNumber_not_in: [BigInt!]
  addedToRegistryTransactionHash: Bytes
  addedToRegistryTransactionHash_contains: Bytes
  addedToRegistryTransactionHash_in: [Bytes!]
  addedToRegistryTransactionHash_not: Bytes
  addedToRegistryTransactionHash_not_contains: Bytes
  addedToRegistryTransactionHash_not_in: [Bytes!]
  currentConverterRegistry: String
  currentConverterRegistry_contains: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_lt: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_not: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_not_ends_with: String
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_starts_with: String
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  owner: Bytes
  owner_contains: Bytes
  owner_in: [Bytes!]
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  smartTokenType: String
  smartTokenType_contains: String
  smartTokenType_ends_with: String
  smartTokenType_gt: String
  smartTokenType_gte: String
  smartTokenType_in: [String!]
  smartTokenType_lt: String
  smartTokenType_lte: String
  smartTokenType_not: String
  smartTokenType_not_contains: String
  smartTokenType_not_ends_with: String
  smartTokenType_not_in: [String!]
  smartTokenType_not_starts_with: String
  smartTokenType_starts_with: String
  symbol: String
  symbol_contains: String
  symbol_ends_with: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_ends_with: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_starts_with: String
  transfersEnabled: Boolean
  transfersEnabled_in: [Boolean!]
  transfersEnabled_not: Boolean
  transfersEnabled_not_in: [Boolean!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum SmartToken_orderBy {
  addedToRegistryBlockNumber
  addedToRegistryTransactionHash
  connectorTokens
  currentConverterRegistry
  decimals
  id
  liquidityPool
  name
  owner
  smartTokenType
  symbol
  transfersEnabled
  version
}

enum StakeHistoryAction {
  Delegate
  ExtendStake
  FeeWithdrawn
  IncreaseStake
  Stake
  Unstake
  WithdrawStaked
}

type StakeHistoryItem {
  action: StakeHistoryAction!
  amount: BigInt
  id: ID!
  lockedUntil: BigInt
  timestamp: BigInt!
  transaction: Transaction!
  user: UserStakeHistory!
}

input StakeHistoryItem_filter {
  action: StakeHistoryAction
  action_in: [StakeHistoryAction!]
  action_not: StakeHistoryAction
  action_not_in: [StakeHistoryAction!]
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedUntil: BigInt
  lockedUntil_gt: BigInt
  lockedUntil_gte: BigInt
  lockedUntil_in: [BigInt!]
  lockedUntil_lt: BigInt
  lockedUntil_lte: BigInt
  lockedUntil_not: BigInt
  lockedUntil_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum StakeHistoryItem_orderBy {
  action
  amount
  id
  lockedUntil
  timestamp
  transaction
  user
}

type Subscription {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  borrow(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Borrow
  borrows(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Borrow_filter
  ): [Borrow!]!
  candleStick(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStick
  candleSticks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStick_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStick_filter
  ): [CandleStick!]!
  closeWithDeposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithDeposit
  closeWithDeposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithDeposit_filter
  ): [CloseWithDeposit!]!
  closeWithSwap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithSwap
  closeWithSwaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithSwap_filter
  ): [CloseWithSwap!]!
  conversion(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Conversion_filter
  ): [Conversion!]!
  converterRegistries(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ConverterRegistry_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ConverterRegistry_filter
  ): [ConverterRegistry!]!
  converterRegistry(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConverterRegistry
  depositCollateral(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositCollateral
  depositCollaterals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DepositCollateral_filter
  ): [DepositCollateral!]!
  feeSharingTokensTransferred(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeSharingTokensTransferred
  feeSharingTokensTransferreds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeSharingTokensTransferred_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeSharingTokensTransferred_filter
  ): [FeeSharingTokensTransferred!]!
  lendingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingHistoryItem
  lendingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingHistoryItem_filter
  ): [LendingHistoryItem!]!
  lendingPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingPool
  lendingPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingPool_filter
  ): [LendingPool!]!
  liquidate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidate
  liquidates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Liquidate_filter
  ): [Liquidate!]!
  liquidityHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityHistoryItem
  liquidityHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityHistoryItem_filter
  ): [LiquidityHistoryItem!]!
  liquidityPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPoolAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolAdded
  liquidityPoolAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPoolAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPoolAdded_filter
  ): [LiquidityPoolAdded!]!
  liquidityPoolRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolRemoved
  liquidityPoolRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPoolRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPoolRemoved_filter
  ): [LiquidityPoolRemoved!]!
  liquidityPoolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolToken
  liquidityPoolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]!
  liquidityPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPool_filter
  ): [LiquidityPool!]!
  loan(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loans(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Loan_filter
  ): [Loan!]!
  newConverter(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewConverter
  newConverters(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NewConverter_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NewConverter_filter
  ): [NewConverter!]!
  payBorrowingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayBorrowingFee
  payBorrowingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayBorrowingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayBorrowingFee_filter
  ): [PayBorrowingFee!]!
  payLendingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayLendingFee
  payLendingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayLendingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayLendingFee_filter
  ): [PayLendingFee!]!
  payTradingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayTradingFee
  payTradingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayTradingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayTradingFee_filter
  ): [PayTradingFee!]!
  poolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolToken_filter
  ): [PoolToken!]!
  proposal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Proposal_filter
  ): [Proposal!]!
  protocolStats(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ProtocolStats_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ProtocolStats_filter
  ): [ProtocolStats!]!
  rewardsEarnedHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardsEarnedHistoryItem
  rewardsEarnedHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardsEarnedHistoryItem_filter
  ): [RewardsEarnedHistoryItem!]!
  smartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartToken
  smartTokenAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartTokenAdded
  smartTokenAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SmartTokenAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SmartTokenAdded_filter
  ): [SmartTokenAdded!]!
  smartTokenRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartTokenRemoved
  smartTokenRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SmartTokenRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SmartTokenRemoved_filter
  ): [SmartTokenRemoved!]!
  smartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SmartToken_filter
  ): [SmartToken!]!
  stakeHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistoryItem
  stakeHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StakeHistoryItem_filter
  ): [StakeHistoryItem!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenPoolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenPoolToken
  tokenPoolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenPoolToken_filter
  ): [TokenPoolToken!]!
  tokenSmartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSmartToken
  tokenSmartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  tokensStaked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensStaked
  tokensStakeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokensStaked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokensStaked_filter
  ): [TokensStaked!]!
  trade(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Trade_filter
  ): [Trade!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userLendingHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLendingHistory_filter
  ): [UserLendingHistory!]!
  userLendingHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLendingHistory
  userLiquidityHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLiquidityHistory_filter
  ): [UserLiquidityHistory!]!
  userLiquidityHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLiquidityHistory
  userRewardsEarnedHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserRewardsEarnedHistory_filter
  ): [UserRewardsEarnedHistory!]!
  userRewardsEarnedHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserRewardsEarnedHistory
  userStakeHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserStakeHistory_filter
  ): [UserStakeHistory!]!
  userStakeHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserStakeHistory
  userTotal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserTotal
  userTotals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserTotal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserTotal_filter
  ): [UserTotal!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  vestingContract(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingContract
  vestingContracts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingContract_filter
  ): [VestingContract!]!
  vestingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingHistoryItem
  vestingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingHistoryItem_filter
  ): [VestingHistoryItem!]!
  voteCast(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteCast
  voteCasts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VoteCast_filter
  ): [VoteCast!]!
}

"""
The Swap entity is an aggregated entity of the individual Conversion events in a transaction.
For example, if a User swaps XUSD to SOV, there will be 2 Conversion events through 2 AMMs (XUSD-BTC and BTC-SOV) in one transaction. These two Conversions are aggregated here.
"""
type Swap {
  """
  The AMM Conversion events involved in this swap
  """
  conversions(
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Conversion_filter
  ): [Conversion!]
  fromAmount: BigDecimal!
  fromToken: Token!

  """
  Transaction hash of this swap
  """
  id: ID!
  isBorrow: Boolean!
  isMarginTrade: Boolean!

  """
  The number of AMM Conversions involved in this swap (this is primarily for debugging purposes)
  """
  numConversions: Int!

  """
  Rate is calculated as toAmount / fromAmount
  """
  rate: BigDecimal!
  timestamp: BigInt!
  toAmount: BigDecimal!
  toToken: Token!
  transaction: Transaction!

  """
  If this swap was initiated by a contract (for example as part of a Margin Trade), User will be null
  """
  user: User
}

input Swap_filter {
  fromAmount: BigDecimal
  fromAmount_gt: BigDecimal
  fromAmount_gte: BigDecimal
  fromAmount_in: [BigDecimal!]
  fromAmount_lt: BigDecimal
  fromAmount_lte: BigDecimal
  fromAmount_not: BigDecimal
  fromAmount_not_in: [BigDecimal!]
  fromToken: String
  fromToken_contains: String
  fromToken_ends_with: String
  fromToken_gt: String
  fromToken_gte: String
  fromToken_in: [String!]
  fromToken_lt: String
  fromToken_lte: String
  fromToken_not: String
  fromToken_not_contains: String
  fromToken_not_ends_with: String
  fromToken_not_in: [String!]
  fromToken_not_starts_with: String
  fromToken_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isBorrow: Boolean
  isBorrow_in: [Boolean!]
  isBorrow_not: Boolean
  isBorrow_not_in: [Boolean!]
  isMarginTrade: Boolean
  isMarginTrade_in: [Boolean!]
  isMarginTrade_not: Boolean
  isMarginTrade_not_in: [Boolean!]
  numConversions: Int
  numConversions_gt: Int
  numConversions_gte: Int
  numConversions_in: [Int!]
  numConversions_lt: Int
  numConversions_lte: Int
  numConversions_not: Int
  numConversions_not_in: [Int!]
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  toAmount: BigDecimal
  toAmount_gt: BigDecimal
  toAmount_gte: BigDecimal
  toAmount_in: [BigDecimal!]
  toAmount_lt: BigDecimal
  toAmount_lte: BigDecimal
  toAmount_not: BigDecimal
  toAmount_not_in: [BigDecimal!]
  toToken: String
  toToken_contains: String
  toToken_ends_with: String
  toToken_gt: String
  toToken_gte: String
  toToken_in: [String!]
  toToken_lt: String
  toToken_lte: String
  toToken_not: String
  toToken_not_contains: String
  toToken_not_ends_with: String
  toToken_not_in: [String!]
  toToken_not_starts_with: String
  toToken_starts_with: String
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum Swap_orderBy {
  conversions
  fromAmount
  fromToken
  id
  isBorrow
  isMarginTrade
  numConversions
  rate
  timestamp
  toAmount
  toToken
  transaction
  user
}

"""
This entity represents an ERC20 token traded on the Sovryn Protocol
"""
type Token {
  """
  The total volume of this token that has been traded through the protocol quoted in BTC
  """
  btcVolume: BigDecimal!
  currentConverterRegistry: ConverterRegistry
  decimals: Int

  """
  Does this token have an AMM pool with rBTC as the other reserve asset?
  """
  hasBtcPool: Boolean

  """
  Does this token have an AMM pool with the protocol stablecoin as the other reserve asset?
  """
  hasStablecoinPool: Boolean

  """
  The ID is the contract address of the token on RSK
  """
  id: ID!
  lastPriceBtc: BigDecimal!
  lastPriceUsd: BigDecimal!

  """
  The addresses of the LiquidityPools where this token is a reserve asset
  """
  liquidityPools(
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]
  name: String

  """
  previous BTC price used for candleSticks
  """
  prevPriceBtc: BigDecimal!

  """
  previous BTC price used for candleSticks
  """
  prevPriceUsd: BigDecimal!

  """
  The smart tokens that have this token as an underlying asset
  """
  smartTokens(
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]
  symbol: String

  """
  The total volume of this token that has been traded through the protocol
  """
  tokenVolume: BigDecimal!

  """
  The total volume of this token that has been traded through the protocol quoted in USD
  """
  usdVolume: BigDecimal!
  version: Int
}

"""
The entity stores the many-to-many relationship between underlying tokens and pool tokens
"""
type TokenPoolToken {
  """
  ID is token address + poolToken address
  """
  id: ID!
  liquidityPool: LiquidityPool!
  poolToken: PoolToken!
  token: Token!
}

input TokenPoolToken_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPool: String
  liquidityPool_contains: String
  liquidityPool_ends_with: String
  liquidityPool_gt: String
  liquidityPool_gte: String
  liquidityPool_in: [String!]
  liquidityPool_lt: String
  liquidityPool_lte: String
  liquidityPool_not: String
  liquidityPool_not_contains: String
  liquidityPool_not_ends_with: String
  liquidityPool_not_in: [String!]
  liquidityPool_not_starts_with: String
  liquidityPool_starts_with: String
  poolToken: String
  poolToken_contains: String
  poolToken_ends_with: String
  poolToken_gt: String
  poolToken_gte: String
  poolToken_in: [String!]
  poolToken_lt: String
  poolToken_lte: String
  poolToken_not: String
  poolToken_not_contains: String
  poolToken_not_ends_with: String
  poolToken_not_in: [String!]
  poolToken_not_starts_with: String
  poolToken_starts_with: String
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
}

enum TokenPoolToken_orderBy {
  id
  liquidityPool
  poolToken
  token
}

"""
This entity is to store a many-to-many relationship between tokens and smart tokens
"""
type TokenSmartToken {
  """
  ID is token address + smart token address
  """
  id: ID!
  smartToken: SmartToken!

  """
  token is the underlying asset represented by the smartToken
  """
  token: Token!
}

input TokenSmartToken_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  smartToken: String
  smartToken_contains: String
  smartToken_ends_with: String
  smartToken_gt: String
  smartToken_gte: String
  smartToken_in: [String!]
  smartToken_lt: String
  smartToken_lte: String
  smartToken_not: String
  smartToken_not_contains: String
  smartToken_not_ends_with: String
  smartToken_not_in: [String!]
  smartToken_not_starts_with: String
  smartToken_starts_with: String
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
}

enum TokenSmartToken_orderBy {
  id
  smartToken
  token
}

input Token_filter {
  btcVolume: BigDecimal
  btcVolume_gt: BigDecimal
  btcVolume_gte: BigDecimal
  btcVolume_in: [BigDecimal!]
  btcVolume_lt: BigDecimal
  btcVolume_lte: BigDecimal
  btcVolume_not: BigDecimal
  btcVolume_not_in: [BigDecimal!]
  currentConverterRegistry: String
  currentConverterRegistry_contains: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_lt: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_not: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_not_ends_with: String
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_starts_with: String
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  hasBtcPool: Boolean
  hasBtcPool_in: [Boolean!]
  hasBtcPool_not: Boolean
  hasBtcPool_not_in: [Boolean!]
  hasStablecoinPool: Boolean
  hasStablecoinPool_in: [Boolean!]
  hasStablecoinPool_not: Boolean
  hasStablecoinPool_not_in: [Boolean!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastPriceBtc: BigDecimal
  lastPriceBtc_gt: BigDecimal
  lastPriceBtc_gte: BigDecimal
  lastPriceBtc_in: [BigDecimal!]
  lastPriceBtc_lt: BigDecimal
  lastPriceBtc_lte: BigDecimal
  lastPriceBtc_not: BigDecimal
  lastPriceBtc_not_in: [BigDecimal!]
  lastPriceUsd: BigDecimal
  lastPriceUsd_gt: BigDecimal
  lastPriceUsd_gte: BigDecimal
  lastPriceUsd_in: [BigDecimal!]
  lastPriceUsd_lt: BigDecimal
  lastPriceUsd_lte: BigDecimal
  lastPriceUsd_not: BigDecimal
  lastPriceUsd_not_in: [BigDecimal!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  prevPriceBtc: BigDecimal
  prevPriceBtc_gt: BigDecimal
  prevPriceBtc_gte: BigDecimal
  prevPriceBtc_in: [BigDecimal!]
  prevPriceBtc_lt: BigDecimal
  prevPriceBtc_lte: BigDecimal
  prevPriceBtc_not: BigDecimal
  prevPriceBtc_not_in: [BigDecimal!]
  prevPriceUsd: BigDecimal
  prevPriceUsd_gt: BigDecimal
  prevPriceUsd_gte: BigDecimal
  prevPriceUsd_in: [BigDecimal!]
  prevPriceUsd_lt: BigDecimal
  prevPriceUsd_lte: BigDecimal
  prevPriceUsd_not: BigDecimal
  prevPriceUsd_not_in: [BigDecimal!]
  symbol: String
  symbol_contains: String
  symbol_ends_with: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_ends_with: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_starts_with: String
  tokenVolume: BigDecimal
  tokenVolume_gt: BigDecimal
  tokenVolume_gte: BigDecimal
  tokenVolume_in: [BigDecimal!]
  tokenVolume_lt: BigDecimal
  tokenVolume_lte: BigDecimal
  tokenVolume_not: BigDecimal
  tokenVolume_not_in: [BigDecimal!]
  usdVolume: BigDecimal
  usdVolume_gt: BigDecimal
  usdVolume_gte: BigDecimal
  usdVolume_in: [BigDecimal!]
  usdVolume_lt: BigDecimal
  usdVolume_lte: BigDecimal
  usdVolume_not: BigDecimal
  usdVolume_not_in: [BigDecimal!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum Token_orderBy {
  btcVolume
  currentConverterRegistry
  decimals
  hasBtcPool
  hasStablecoinPool
  id
  lastPriceBtc
  lastPriceUsd
  liquidityPools
  name
  prevPriceBtc
  prevPriceUsd
  smartTokens
  symbol
  tokenVolume
  usdVolume
  version
}

type TokensStaked {
  amount: BigInt!
  emittedBy: Bytes!
  id: ID!
  isUserStaked: Boolean!
  lockedUntil: BigInt!
  staker: Bytes!
  timestamp: BigInt!
  totalStaked: BigInt!
  transaction: Transaction!
  user: User
}

input TokensStaked_filter {
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isUserStaked: Boolean
  isUserStaked_in: [Boolean!]
  isUserStaked_not: Boolean
  isUserStaked_not_in: [Boolean!]
  lockedUntil: BigInt
  lockedUntil_gt: BigInt
  lockedUntil_gte: BigInt
  lockedUntil_in: [BigInt!]
  lockedUntil_lt: BigInt
  lockedUntil_lte: BigInt
  lockedUntil_not: BigInt
  lockedUntil_not_in: [BigInt!]
  staker: Bytes
  staker_contains: Bytes
  staker_in: [Bytes!]
  staker_not: Bytes
  staker_not_contains: Bytes
  staker_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  totalStaked: BigInt
  totalStaked_gt: BigInt
  totalStaked_gte: BigInt
  totalStaked_in: [BigInt!]
  totalStaked_lt: BigInt
  totalStaked_lte: BigInt
  totalStaked_not: BigInt
  totalStaked_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum TokensStaked_orderBy {
  amount
  emittedBy
  id
  isUserStaked
  lockedUntil
  staker
  timestamp
  totalStaked
  transaction
  user
}

type Trade {
  borrowedAmount: BigInt!
  collateralToken: Bytes!
  currentLeverage: BigInt!
  emittedBy: Bytes!
  entryLeverage: BigInt!
  entryPrice: BigInt!
  id: ID!
  interestRate: BigInt!
  lender: Bytes!
  loanId: Loan!
  loanToken: Bytes!
  positionSize: BigInt!
  settlementDate: BigInt!
  timestamp: BigInt!
  transaction: Transaction!
  user: User!
}

input Trade_filter {
  borrowedAmount: BigInt
  borrowedAmount_gt: BigInt
  borrowedAmount_gte: BigInt
  borrowedAmount_in: [BigInt!]
  borrowedAmount_lt: BigInt
  borrowedAmount_lte: BigInt
  borrowedAmount_not: BigInt
  borrowedAmount_not_in: [BigInt!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  currentLeverage: BigInt
  currentLeverage_gt: BigInt
  currentLeverage_gte: BigInt
  currentLeverage_in: [BigInt!]
  currentLeverage_lt: BigInt
  currentLeverage_lte: BigInt
  currentLeverage_not: BigInt
  currentLeverage_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  entryLeverage: BigInt
  entryLeverage_gt: BigInt
  entryLeverage_gte: BigInt
  entryLeverage_in: [BigInt!]
  entryLeverage_lt: BigInt
  entryLeverage_lte: BigInt
  entryLeverage_not: BigInt
  entryLeverage_not_in: [BigInt!]
  entryPrice: BigInt
  entryPrice_gt: BigInt
  entryPrice_gte: BigInt
  entryPrice_in: [BigInt!]
  entryPrice_lt: BigInt
  entryPrice_lte: BigInt
  entryPrice_not: BigInt
  entryPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  interestRate: BigInt
  interestRate_gt: BigInt
  interestRate_gte: BigInt
  interestRate_in: [BigInt!]
  interestRate_lt: BigInt
  interestRate_lte: BigInt
  interestRate_not: BigInt
  interestRate_not_in: [BigInt!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  positionSize: BigInt
  positionSize_gt: BigInt
  positionSize_gte: BigInt
  positionSize_in: [BigInt!]
  positionSize_lt: BigInt
  positionSize_lte: BigInt
  positionSize_not: BigInt
  positionSize_not_in: [BigInt!]
  settlementDate: BigInt
  settlementDate_gt: BigInt
  settlementDate_gte: BigInt
  settlementDate_in: [BigInt!]
  settlementDate_lt: BigInt
  settlementDate_lte: BigInt
  settlementDate_not: BigInt
  settlementDate_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum Trade_orderBy {
  borrowedAmount
  collateralToken
  currentLeverage
  emittedBy
  entryLeverage
  entryPrice
  id
  interestRate
  lender
  loanId
  loanToken
  positionSize
  settlementDate
  timestamp
  transaction
  user
}

"""
Transaction data, including hash and timestamp
"""
type Transaction {
  blockNumber: BigInt!

  """
  The account that initiated this transaction. This must be an Account and not a Contract.
  """
  from: Bytes!
  gasLimit: BigInt!
  gasPrice: BigInt!

  """
  ID is transaction hash
  """
  id: ID!

  """
  The index of this transaction within the block
  """
  index: BigInt!

  """
  The timestamp the transaction was confirmed
  """
  timestamp: BigInt!
  to: Bytes
  value: BigInt!
}

input Transaction_filter {
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  from: Bytes
  from_contains: Bytes
  from_in: [Bytes!]
  from_not: Bytes
  from_not_contains: Bytes
  from_not_in: [Bytes!]
  gasLimit: BigInt
  gasLimit_gt: BigInt
  gasLimit_gte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_lt: BigInt
  gasLimit_lte: BigInt
  gasLimit_not: BigInt
  gasLimit_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  index: BigInt
  index_gt: BigInt
  index_gte: BigInt
  index_in: [BigInt!]
  index_lt: BigInt
  index_lte: BigInt
  index_not: BigInt
  index_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  to: Bytes
  to_contains: Bytes
  to_in: [Bytes!]
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum Transaction_orderBy {
  blockNumber
  from
  gasLimit
  gasPrice
  id
  index
  timestamp
  to
  value
}

"""
This entity contains all user-specific data displayed on the dapp, including all user actions
"""
type User {
  """
  An array of Borrow events
  """
  borrows(
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Borrow_filter
  ): [Borrow!]

  """
  ID is user wallet address
  """
  id: ID!

  """
  The lending history of a User, separated into lending pools. Explore the UserLendingHistory entity for more granular events.
  """
  lendingHistory(
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserLendingHistory_filter
  ): [UserLendingHistory!]

  """
  An array of Liquidation events linked to this user
  """
  liquidations(
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Liquidate_filter
  ): [Liquidate!]

  """
  An array of all LiquidityAdded and LiquidityRemoved events
  """
  liquidityHistory(
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserLiquidityHistory_filter
  ): [UserLiquidityHistory!]

  """
  All loans taken out by this user, including for margin trading and for borrowing
  """
  loans(
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Loan_filter
  ): [Loan!]

  """
  The Rewards history of one user. This includes actions like EarnReward, RewardSovDeposited, and RewardSovStaked.
  Explore the UserRewardsEarnedHistory entity for more granular events
  """
  rewardsEarnedHistory(
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserRewardsEarnedHistory_filter
  ): [UserRewardsEarnedHistory!]

  """
  The SOV Staking history of a user. This includes withdrawing vested tokens. Explore the UserStakeHistory entity for more granular events.
  """
  stakeHistory(
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserStakeHistory_filter
  ): [UserStakeHistory!]

  """
  Swaps here refers to only user-triggered swaps. For example, a swap that is part of a margin trade would not be included.
  Swaps involving multiple amm pools are stored as a single swap, comprised of multiple Conversion events
  """
  swaps(
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Swap_filter
  ): [Swap!]

  """
  An array of margin trade Trade events
  """
  trades(
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Trade_filter
  ): [Trade!]

  """
  See UserTotals entity for full documentation
  """
  userTotals: UserTotal

  """
  Vesting contracts owned by User, labelled by type
  """
  vestingContracts(
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VestingContract_filter
  ): [VestingContract!]

  """
  Voting history of User
  """
  votes(
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VoteCast_filter
  ): [VoteCast!]
}

"""
This entity contains the lending and unlending history of one User
"""
type UserLendingHistory {
  """
  ID is userAddress + lendingPoolAddress (lendingPool in this case is the lending pool token)
  """
  id: ID!

  """
  Granular Lend/UnLend events. Derived from Mint/Burn events on the contracts
  """
  lendingHistory(
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LendingHistoryItem_filter
  ): [LendingHistoryItem!]
  lendingPool: LendingPool!

  """
  Total volume this User has lent to this pool over all time (in the underlying asset currency, ie rBTC for the rBTC lending pool)
  """
  totalLendVolume: BigInt!

  """
  Total volume this User has withdrawn from this pool over all time
  """
  totalUnlendVolume: BigInt!
  user: User!
}

input UserLendingHistory_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lendingPool: String
  lendingPool_contains: String
  lendingPool_ends_with: String
  lendingPool_gt: String
  lendingPool_gte: String
  lendingPool_in: [String!]
  lendingPool_lt: String
  lendingPool_lte: String
  lendingPool_not: String
  lendingPool_not_contains: String
  lendingPool_not_ends_with: String
  lendingPool_not_in: [String!]
  lendingPool_not_starts_with: String
  lendingPool_starts_with: String
  totalLendVolume: BigInt
  totalLendVolume_gt: BigInt
  totalLendVolume_gte: BigInt
  totalLendVolume_in: [BigInt!]
  totalLendVolume_lt: BigInt
  totalLendVolume_lte: BigInt
  totalLendVolume_not: BigInt
  totalLendVolume_not_in: [BigInt!]
  totalUnlendVolume: BigInt
  totalUnlendVolume_gt: BigInt
  totalUnlendVolume_gte: BigInt
  totalUnlendVolume_in: [BigInt!]
  totalUnlendVolume_lt: BigInt
  totalUnlendVolume_lte: BigInt
  totalUnlendVolume_not: BigInt
  totalUnlendVolume_not_in: [BigInt!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum UserLendingHistory_orderBy {
  id
  lendingHistory
  lendingPool
  totalLendVolume
  totalUnlendVolume
  user
}

"""
This entity stores one Users history of adding and removing liquidity from one AMM pool
"""
type UserLiquidityHistory {
  id: ID!
  liquidityHistory(
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityHistoryItem_filter
  ): [LiquidityHistoryItem!]
  poolToken: PoolToken!
  totalAsset0LiquidityAdded: BigInt!
  totalAsset0LiquidityRemoved: BigInt!
  totalAsset1LiquidityAdded: BigInt!
  totalAsset1LiquidityRemoved: BigInt!
  user: User!
}

input UserLiquidityHistory_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolToken: String
  poolToken_contains: String
  poolToken_ends_with: String
  poolToken_gt: String
  poolToken_gte: String
  poolToken_in: [String!]
  poolToken_lt: String
  poolToken_lte: String
  poolToken_not: String
  poolToken_not_contains: String
  poolToken_not_ends_with: String
  poolToken_not_in: [String!]
  poolToken_not_starts_with: String
  poolToken_starts_with: String
  totalAsset0LiquidityAdded: BigInt
  totalAsset0LiquidityAdded_gt: BigInt
  totalAsset0LiquidityAdded_gte: BigInt
  totalAsset0LiquidityAdded_in: [BigInt!]
  totalAsset0LiquidityAdded_lt: BigInt
  totalAsset0LiquidityAdded_lte: BigInt
  totalAsset0LiquidityAdded_not: BigInt
  totalAsset0LiquidityAdded_not_in: [BigInt!]
  totalAsset0LiquidityRemoved: BigInt
  totalAsset0LiquidityRemoved_gt: BigInt
  totalAsset0LiquidityRemoved_gte: BigInt
  totalAsset0LiquidityRemoved_in: [BigInt!]
  totalAsset0LiquidityRemoved_lt: BigInt
  totalAsset0LiquidityRemoved_lte: BigInt
  totalAsset0LiquidityRemoved_not: BigInt
  totalAsset0LiquidityRemoved_not_in: [BigInt!]
  totalAsset1LiquidityAdded: BigInt
  totalAsset1LiquidityAdded_gt: BigInt
  totalAsset1LiquidityAdded_gte: BigInt
  totalAsset1LiquidityAdded_in: [BigInt!]
  totalAsset1LiquidityAdded_lt: BigInt
  totalAsset1LiquidityAdded_lte: BigInt
  totalAsset1LiquidityAdded_not: BigInt
  totalAsset1LiquidityAdded_not_in: [BigInt!]
  totalAsset1LiquidityRemoved: BigInt
  totalAsset1LiquidityRemoved_gt: BigInt
  totalAsset1LiquidityRemoved_gte: BigInt
  totalAsset1LiquidityRemoved_in: [BigInt!]
  totalAsset1LiquidityRemoved_lt: BigInt
  totalAsset1LiquidityRemoved_lte: BigInt
  totalAsset1LiquidityRemoved_not: BigInt
  totalAsset1LiquidityRemoved_not_in: [BigInt!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum UserLiquidityHistory_orderBy {
  id
  liquidityHistory
  poolToken
  totalAsset0LiquidityAdded
  totalAsset0LiquidityRemoved
  totalAsset1LiquidityAdded
  totalAsset1LiquidityRemoved
  user
}

"""
This entity contains the history, fees and totals regarding one users' SOV rewards
"""
type UserRewardsEarnedHistory {
  """
  This is incremented by EarnReward and RewardClaimed events, and set to 0 by RewardWithdrawn events
  """
  availableRewardSov: BigInt!

  """
  This is incremented by EarnReward events, and set to 0 by TokensStaked events on the LockedSOV contract
  """
  availableTradingRewards: BigInt!
  id: ID!
  rewardsEarnedHistory(
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: RewardsEarnedHistoryItem_filter
  ): [RewardsEarnedHistoryItem!]

  """
  This is the total of all EarnReward and RewardClaimed events
  """
  totalFeesAndRewardsEarned: BigInt!
  user: User!
}

input UserRewardsEarnedHistory_filter {
  availableRewardSov: BigInt
  availableRewardSov_gt: BigInt
  availableRewardSov_gte: BigInt
  availableRewardSov_in: [BigInt!]
  availableRewardSov_lt: BigInt
  availableRewardSov_lte: BigInt
  availableRewardSov_not: BigInt
  availableRewardSov_not_in: [BigInt!]
  availableTradingRewards: BigInt
  availableTradingRewards_gt: BigInt
  availableTradingRewards_gte: BigInt
  availableTradingRewards_in: [BigInt!]
  availableTradingRewards_lt: BigInt
  availableTradingRewards_lte: BigInt
  availableTradingRewards_not: BigInt
  availableTradingRewards_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  totalFeesAndRewardsEarned: BigInt
  totalFeesAndRewardsEarned_gt: BigInt
  totalFeesAndRewardsEarned_gte: BigInt
  totalFeesAndRewardsEarned_in: [BigInt!]
  totalFeesAndRewardsEarned_lt: BigInt
  totalFeesAndRewardsEarned_lte: BigInt
  totalFeesAndRewardsEarned_not: BigInt
  totalFeesAndRewardsEarned_not_in: [BigInt!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum UserRewardsEarnedHistory_orderBy {
  availableRewardSov
  availableTradingRewards
  id
  rewardsEarnedHistory
  totalFeesAndRewardsEarned
  user
}

type UserStakeHistory {
  id: ID!
  stakeHistory(
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: StakeHistoryItem_filter
  ): [StakeHistoryItem!]
  totalRemaining: BigInt!
  totalStaked: BigInt!
  totalWithdrawn: BigInt!
  user: User!
}

input UserStakeHistory_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  totalRemaining: BigInt
  totalRemaining_gt: BigInt
  totalRemaining_gte: BigInt
  totalRemaining_in: [BigInt!]
  totalRemaining_lt: BigInt
  totalRemaining_lte: BigInt
  totalRemaining_not: BigInt
  totalRemaining_not_in: [BigInt!]
  totalStaked: BigInt
  totalStaked_gt: BigInt
  totalStaked_gte: BigInt
  totalStaked_in: [BigInt!]
  totalStaked_lt: BigInt
  totalStaked_lte: BigInt
  totalStaked_not: BigInt
  totalStaked_not_in: [BigInt!]
  totalWithdrawn: BigInt
  totalWithdrawn_gt: BigInt
  totalWithdrawn_gte: BigInt
  totalWithdrawn_in: [BigInt!]
  totalWithdrawn_lt: BigInt
  totalWithdrawn_lte: BigInt
  totalWithdrawn_not: BigInt
  totalWithdrawn_not_in: [BigInt!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum UserStakeHistory_orderBy {
  id
  stakeHistory
  totalRemaining
  totalStaked
  totalWithdrawn
  user
}

"""
This is the total volumes of different actions for one user. See ProtocolStats entity for full descriptions.
"""
type UserTotal {
  id: ID!
  totalAmmLpFeesUsd: BigDecimal!
  totalAmmStakerFeesUsd: BigDecimal!
  totalAmmVolumeUsd: BigDecimal!
  totalBorrowVolumeUsd: BigDecimal!
  totalBorrowingFeesUsd: BigDecimal!
  totalCloseWithDepositVolumeUsd: BigDecimal!
  totalCloseWithSwapVolumeUsd: BigDecimal!
  totalDepositCollateralVolumeUsd: BigDecimal!
  totalLendVolumeUsd: BigDecimal!
  totalLendingFeesUsd: BigDecimal!
  totalLiquidateVolumeUsd: BigDecimal!
  totalMarginTradeVolumeUsd: BigDecimal!
  totalTradingFeesUsd: BigDecimal!
  totalUnlendVolumeUsd: BigDecimal!
  user: User!
}

input UserTotal_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  totalAmmLpFeesUsd: BigDecimal
  totalAmmLpFeesUsd_gt: BigDecimal
  totalAmmLpFeesUsd_gte: BigDecimal
  totalAmmLpFeesUsd_in: [BigDecimal!]
  totalAmmLpFeesUsd_lt: BigDecimal
  totalAmmLpFeesUsd_lte: BigDecimal
  totalAmmLpFeesUsd_not: BigDecimal
  totalAmmLpFeesUsd_not_in: [BigDecimal!]
  totalAmmStakerFeesUsd: BigDecimal
  totalAmmStakerFeesUsd_gt: BigDecimal
  totalAmmStakerFeesUsd_gte: BigDecimal
  totalAmmStakerFeesUsd_in: [BigDecimal!]
  totalAmmStakerFeesUsd_lt: BigDecimal
  totalAmmStakerFeesUsd_lte: BigDecimal
  totalAmmStakerFeesUsd_not: BigDecimal
  totalAmmStakerFeesUsd_not_in: [BigDecimal!]
  totalAmmVolumeUsd: BigDecimal
  totalAmmVolumeUsd_gt: BigDecimal
  totalAmmVolumeUsd_gte: BigDecimal
  totalAmmVolumeUsd_in: [BigDecimal!]
  totalAmmVolumeUsd_lt: BigDecimal
  totalAmmVolumeUsd_lte: BigDecimal
  totalAmmVolumeUsd_not: BigDecimal
  totalAmmVolumeUsd_not_in: [BigDecimal!]
  totalBorrowVolumeUsd: BigDecimal
  totalBorrowVolumeUsd_gt: BigDecimal
  totalBorrowVolumeUsd_gte: BigDecimal
  totalBorrowVolumeUsd_in: [BigDecimal!]
  totalBorrowVolumeUsd_lt: BigDecimal
  totalBorrowVolumeUsd_lte: BigDecimal
  totalBorrowVolumeUsd_not: BigDecimal
  totalBorrowVolumeUsd_not_in: [BigDecimal!]
  totalBorrowingFeesUsd: BigDecimal
  totalBorrowingFeesUsd_gt: BigDecimal
  totalBorrowingFeesUsd_gte: BigDecimal
  totalBorrowingFeesUsd_in: [BigDecimal!]
  totalBorrowingFeesUsd_lt: BigDecimal
  totalBorrowingFeesUsd_lte: BigDecimal
  totalBorrowingFeesUsd_not: BigDecimal
  totalBorrowingFeesUsd_not_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd: BigDecimal
  totalCloseWithDepositVolumeUsd_gt: BigDecimal
  totalCloseWithDepositVolumeUsd_gte: BigDecimal
  totalCloseWithDepositVolumeUsd_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd_lt: BigDecimal
  totalCloseWithDepositVolumeUsd_lte: BigDecimal
  totalCloseWithDepositVolumeUsd_not: BigDecimal
  totalCloseWithDepositVolumeUsd_not_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd: BigDecimal
  totalCloseWithSwapVolumeUsd_gt: BigDecimal
  totalCloseWithSwapVolumeUsd_gte: BigDecimal
  totalCloseWithSwapVolumeUsd_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd_lt: BigDecimal
  totalCloseWithSwapVolumeUsd_lte: BigDecimal
  totalCloseWithSwapVolumeUsd_not: BigDecimal
  totalCloseWithSwapVolumeUsd_not_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd: BigDecimal
  totalDepositCollateralVolumeUsd_gt: BigDecimal
  totalDepositCollateralVolumeUsd_gte: BigDecimal
  totalDepositCollateralVolumeUsd_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd_lt: BigDecimal
  totalDepositCollateralVolumeUsd_lte: BigDecimal
  totalDepositCollateralVolumeUsd_not: BigDecimal
  totalDepositCollateralVolumeUsd_not_in: [BigDecimal!]
  totalLendVolumeUsd: BigDecimal
  totalLendVolumeUsd_gt: BigDecimal
  totalLendVolumeUsd_gte: BigDecimal
  totalLendVolumeUsd_in: [BigDecimal!]
  totalLendVolumeUsd_lt: BigDecimal
  totalLendVolumeUsd_lte: BigDecimal
  totalLendVolumeUsd_not: BigDecimal
  totalLendVolumeUsd_not_in: [BigDecimal!]
  totalLendingFeesUsd: BigDecimal
  totalLendingFeesUsd_gt: BigDecimal
  totalLendingFeesUsd_gte: BigDecimal
  totalLendingFeesUsd_in: [BigDecimal!]
  totalLendingFeesUsd_lt: BigDecimal
  totalLendingFeesUsd_lte: BigDecimal
  totalLendingFeesUsd_not: BigDecimal
  totalLendingFeesUsd_not_in: [BigDecimal!]
  totalLiquidateVolumeUsd: BigDecimal
  totalLiquidateVolumeUsd_gt: BigDecimal
  totalLiquidateVolumeUsd_gte: BigDecimal
  totalLiquidateVolumeUsd_in: [BigDecimal!]
  totalLiquidateVolumeUsd_lt: BigDecimal
  totalLiquidateVolumeUsd_lte: BigDecimal
  totalLiquidateVolumeUsd_not: BigDecimal
  totalLiquidateVolumeUsd_not_in: [BigDecimal!]
  totalMarginTradeVolumeUsd: BigDecimal
  totalMarginTradeVolumeUsd_gt: BigDecimal
  totalMarginTradeVolumeUsd_gte: BigDecimal
  totalMarginTradeVolumeUsd_in: [BigDecimal!]
  totalMarginTradeVolumeUsd_lt: BigDecimal
  totalMarginTradeVolumeUsd_lte: BigDecimal
  totalMarginTradeVolumeUsd_not: BigDecimal
  totalMarginTradeVolumeUsd_not_in: [BigDecimal!]
  totalTradingFeesUsd: BigDecimal
  totalTradingFeesUsd_gt: BigDecimal
  totalTradingFeesUsd_gte: BigDecimal
  totalTradingFeesUsd_in: [BigDecimal!]
  totalTradingFeesUsd_lt: BigDecimal
  totalTradingFeesUsd_lte: BigDecimal
  totalTradingFeesUsd_not: BigDecimal
  totalTradingFeesUsd_not_in: [BigDecimal!]
  totalUnlendVolumeUsd: BigDecimal
  totalUnlendVolumeUsd_gt: BigDecimal
  totalUnlendVolumeUsd_gte: BigDecimal
  totalUnlendVolumeUsd_in: [BigDecimal!]
  totalUnlendVolumeUsd_lt: BigDecimal
  totalUnlendVolumeUsd_lte: BigDecimal
  totalUnlendVolumeUsd_not: BigDecimal
  totalUnlendVolumeUsd_not_in: [BigDecimal!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum UserTotal_orderBy {
  id
  totalAmmLpFeesUsd
  totalAmmStakerFeesUsd
  totalAmmVolumeUsd
  totalBorrowVolumeUsd
  totalBorrowingFeesUsd
  totalCloseWithDepositVolumeUsd
  totalCloseWithSwapVolumeUsd
  totalDepositCollateralVolumeUsd
  totalLendVolumeUsd
  totalLendingFeesUsd
  totalLiquidateVolumeUsd
  totalMarginTradeVolumeUsd
  totalTradingFeesUsd
  totalUnlendVolumeUsd
  user
}

input User_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
}

enum User_orderBy {
  borrows
  id
  lendingHistory
  liquidations
  liquidityHistory
  loans
  rewardsEarnedHistory
  stakeHistory
  swaps
  trades
  userTotals
  vestingContracts
  votes
}

type VestingContract {
  cliff: BigInt
  createdAtTimestamp: BigInt!
  createdAtTransaction: Transaction!
  currentBalance: BigInt!
  duration: BigInt
  emittedBy: Bytes!
  id: ID!
  stakeHistory(
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VestingHistoryItem_filter
  ): [VestingHistoryItem!]
  startingBalance: BigInt!
  type: VestingContractType!
  user: User!
}

enum VestingContractType {
  Fish
  FishTeam
  Genesis
  Origins
  Rewards
  Team
}

input VestingContract_filter {
  cliff: BigInt
  cliff_gt: BigInt
  cliff_gte: BigInt
  cliff_in: [BigInt!]
  cliff_lt: BigInt
  cliff_lte: BigInt
  cliff_not: BigInt
  cliff_not_in: [BigInt!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_not_in: [BigInt!]
  createdAtTransaction: String
  createdAtTransaction_contains: String
  createdAtTransaction_ends_with: String
  createdAtTransaction_gt: String
  createdAtTransaction_gte: String
  createdAtTransaction_in: [String!]
  createdAtTransaction_lt: String
  createdAtTransaction_lte: String
  createdAtTransaction_not: String
  createdAtTransaction_not_contains: String
  createdAtTransaction_not_ends_with: String
  createdAtTransaction_not_in: [String!]
  createdAtTransaction_not_starts_with: String
  createdAtTransaction_starts_with: String
  currentBalance: BigInt
  currentBalance_gt: BigInt
  currentBalance_gte: BigInt
  currentBalance_in: [BigInt!]
  currentBalance_lt: BigInt
  currentBalance_lte: BigInt
  currentBalance_not: BigInt
  currentBalance_not_in: [BigInt!]
  duration: BigInt
  duration_gt: BigInt
  duration_gte: BigInt
  duration_in: [BigInt!]
  duration_lt: BigInt
  duration_lte: BigInt
  duration_not: BigInt
  duration_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  startingBalance: BigInt
  startingBalance_gt: BigInt
  startingBalance_gte: BigInt
  startingBalance_in: [BigInt!]
  startingBalance_lt: BigInt
  startingBalance_lte: BigInt
  startingBalance_not: BigInt
  startingBalance_not_in: [BigInt!]
  type: VestingContractType
  type_in: [VestingContractType!]
  type_not: VestingContractType
  type_not_in: [VestingContractType!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum VestingContract_orderBy {
  cliff
  createdAtTimestamp
  createdAtTransaction
  currentBalance
  duration
  emittedBy
  id
  stakeHistory
  startingBalance
  type
  user
}

type VestingHistoryItem {
  action: VestingHistoryItemAction!
  amount: BigInt!
  emittedBy: Bytes!
  id: ID!
  lockedUntil: BigInt!
  staker: VestingContract!
  timestamp: BigInt!
  totalStaked: BigInt!
  transaction: Transaction!
}

enum VestingHistoryItemAction {
  TeamTokensRevoked
  TokensStaked
  TokensWithdrawn
}

input VestingHistoryItem_filter {
  action: VestingHistoryItemAction
  action_in: [VestingHistoryItemAction!]
  action_not: VestingHistoryItemAction
  action_not_in: [VestingHistoryItemAction!]
  amount: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_in: [BigInt!]
  amount_lt: BigInt
  amount_lte: BigInt
  amount_not: BigInt
  amount_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedUntil: BigInt
  lockedUntil_gt: BigInt
  lockedUntil_gte: BigInt
  lockedUntil_in: [BigInt!]
  lockedUntil_lt: BigInt
  lockedUntil_lte: BigInt
  lockedUntil_not: BigInt
  lockedUntil_not_in: [BigInt!]
  staker: String
  staker_contains: String
  staker_ends_with: String
  staker_gt: String
  staker_gte: String
  staker_in: [String!]
  staker_lt: String
  staker_lte: String
  staker_not: String
  staker_not_contains: String
  staker_not_ends_with: String
  staker_not_in: [String!]
  staker_not_starts_with: String
  staker_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  totalStaked: BigInt
  totalStaked_gt: BigInt
  totalStaked_gte: BigInt
  totalStaked_in: [BigInt!]
  totalStaked_lt: BigInt
  totalStaked_lte: BigInt
  totalStaked_not: BigInt
  totalStaked_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum VestingHistoryItem_orderBy {
  action
  amount
  emittedBy
  id
  lockedUntil
  staker
  timestamp
  totalStaked
  transaction
}

type VoteCast {
  emittedBy: Bytes!
  id: ID!
  proposal: Proposal!
  proposalId: BigInt!
  support: Boolean!
  timestamp: BigInt!
  transaction: Transaction!
  voter: User!
  votes: BigInt!
}

input VoteCast_filter {
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  proposal: String
  proposalId: BigInt
  proposalId_gt: BigInt
  proposalId_gte: BigInt
  proposalId_in: [BigInt!]
  proposalId_lt: BigInt
  proposalId_lte: BigInt
  proposalId_not: BigInt
  proposalId_not_in: [BigInt!]
  proposal_contains: String
  proposal_ends_with: String
  proposal_gt: String
  proposal_gte: String
  proposal_in: [String!]
  proposal_lt: String
  proposal_lte: String
  proposal_not: String
  proposal_not_contains: String
  proposal_not_ends_with: String
  proposal_not_in: [String!]
  proposal_not_starts_with: String
  proposal_starts_with: String
  support: Boolean
  support_in: [Boolean!]
  support_not: Boolean
  support_not_in: [Boolean!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  voter: String
  voter_contains: String
  voter_ends_with: String
  voter_gt: String
  voter_gte: String
  voter_in: [String!]
  voter_lt: String
  voter_lte: String
  voter_not: String
  voter_not_contains: String
  voter_not_ends_with: String
  voter_not_in: [String!]
  voter_not_starts_with: String
  voter_starts_with: String
  votes: BigInt
  votes_gt: BigInt
  votes_gte: BigInt
  votes_in: [BigInt!]
  votes_lt: BigInt
  votes_lte: BigInt
  votes_not: BigInt
  votes_not_in: [BigInt!]
}

enum VoteCast_orderBy {
  emittedBy
  id
  proposal
  proposalId
  support
  timestamp
  transaction
  voter
  votes
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
