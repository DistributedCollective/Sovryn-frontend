directive @derivedFrom(field: String) on FIELD_DEFINITION

directive @entity on OBJECT

directive @subgraphId(id: String) on OBJECT

scalar BigDecimal

scalar BigInt

type BitcoinTransfer {
  amountBTC: BigDecimal!
  bitcoinTxHash: Bytes!
  btcAddress: String!
  createdAtBlockNumber: Int!
  createdAtTimestamp: Int!
  createdAtTx: Transaction!
  feeBTC: BigDecimal!
  id: ID!
  nonce: Int!
  status: BitcoinTransferStatus!
  totalAmountBTC: BigDecimal!
  updatedAtBlockNumber: Int!
  updatedAtTimestamp: Int!
  updatedAtTx: Transaction!
  user: User!
}

type BitcoinTransferBatchSending {
  bitcoinTxHash: Bytes!
  emittedBy: Bytes!
  id: ID!
  timestamp: Int!
  transaction: Transaction!
  transferBatchSize: Int!
}

input BitcoinTransferBatchSending_filter {
  bitcoinTxHash: Bytes
  bitcoinTxHash_contains: Bytes
  bitcoinTxHash_in: [Bytes!]
  bitcoinTxHash_not: Bytes
  bitcoinTxHash_not_contains: Bytes
  bitcoinTxHash_not_in: [Bytes!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  transferBatchSize: Int
  transferBatchSize_gt: Int
  transferBatchSize_gte: Int
  transferBatchSize_in: [Int!]
  transferBatchSize_lt: Int
  transferBatchSize_lte: Int
  transferBatchSize_not: Int
  transferBatchSize_not_in: [Int!]
}

enum BitcoinTransferBatchSending_orderBy {
  bitcoinTxHash
  emittedBy
  id
  timestamp
  transaction
  transferBatchSize
}

enum BitcoinTransferStatus {
  """
  the transfer was confirmedly mined in Bitcoin blockchain
  """
  MINED

  """
  the transfer was initiated
  """
  NEW

  """
  the transfer slot has not been initialized
  """
  NOT_APPLICABLE

  """
  the transfer was reclaimed by the user
  """
  RECLAIMED

  """
  the transfer was refunded
  """
  REFUNDED

  """
  the federators have approved this transfer as part of a transfer batch
  """
  SENDING
}

input BitcoinTransfer_filter {
  amountBTC: BigDecimal
  amountBTC_gt: BigDecimal
  amountBTC_gte: BigDecimal
  amountBTC_in: [BigDecimal!]
  amountBTC_lt: BigDecimal
  amountBTC_lte: BigDecimal
  amountBTC_not: BigDecimal
  amountBTC_not_in: [BigDecimal!]
  bitcoinTxHash: Bytes
  bitcoinTxHash_contains: Bytes
  bitcoinTxHash_in: [Bytes!]
  bitcoinTxHash_not: Bytes
  bitcoinTxHash_not_contains: Bytes
  bitcoinTxHash_not_in: [Bytes!]
  btcAddress: String
  btcAddress_contains: String
  btcAddress_ends_with: String
  btcAddress_gt: String
  btcAddress_gte: String
  btcAddress_in: [String!]
  btcAddress_lt: String
  btcAddress_lte: String
  btcAddress_not: String
  btcAddress_not_contains: String
  btcAddress_not_ends_with: String
  btcAddress_not_in: [String!]
  btcAddress_not_starts_with: String
  btcAddress_starts_with: String
  createdAtBlockNumber: Int
  createdAtBlockNumber_gt: Int
  createdAtBlockNumber_gte: Int
  createdAtBlockNumber_in: [Int!]
  createdAtBlockNumber_lt: Int
  createdAtBlockNumber_lte: Int
  createdAtBlockNumber_not: Int
  createdAtBlockNumber_not_in: [Int!]
  createdAtTimestamp: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_lt: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_not_in: [Int!]
  createdAtTx: String
  createdAtTx_contains: String
  createdAtTx_ends_with: String
  createdAtTx_gt: String
  createdAtTx_gte: String
  createdAtTx_in: [String!]
  createdAtTx_lt: String
  createdAtTx_lte: String
  createdAtTx_not: String
  createdAtTx_not_contains: String
  createdAtTx_not_ends_with: String
  createdAtTx_not_in: [String!]
  createdAtTx_not_starts_with: String
  createdAtTx_starts_with: String
  feeBTC: BigDecimal
  feeBTC_gt: BigDecimal
  feeBTC_gte: BigDecimal
  feeBTC_in: [BigDecimal!]
  feeBTC_lt: BigDecimal
  feeBTC_lte: BigDecimal
  feeBTC_not: BigDecimal
  feeBTC_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  nonce: Int
  nonce_gt: Int
  nonce_gte: Int
  nonce_in: [Int!]
  nonce_lt: Int
  nonce_lte: Int
  nonce_not: Int
  nonce_not_in: [Int!]
  status: BitcoinTransferStatus
  status_in: [BitcoinTransferStatus!]
  status_not: BitcoinTransferStatus
  status_not_in: [BitcoinTransferStatus!]
  totalAmountBTC: BigDecimal
  totalAmountBTC_gt: BigDecimal
  totalAmountBTC_gte: BigDecimal
  totalAmountBTC_in: [BigDecimal!]
  totalAmountBTC_lt: BigDecimal
  totalAmountBTC_lte: BigDecimal
  totalAmountBTC_not: BigDecimal
  totalAmountBTC_not_in: [BigDecimal!]
  updatedAtBlockNumber: Int
  updatedAtBlockNumber_gt: Int
  updatedAtBlockNumber_gte: Int
  updatedAtBlockNumber_in: [Int!]
  updatedAtBlockNumber_lt: Int
  updatedAtBlockNumber_lte: Int
  updatedAtBlockNumber_not: Int
  updatedAtBlockNumber_not_in: [Int!]
  updatedAtTimestamp: Int
  updatedAtTimestamp_gt: Int
  updatedAtTimestamp_gte: Int
  updatedAtTimestamp_in: [Int!]
  updatedAtTimestamp_lt: Int
  updatedAtTimestamp_lte: Int
  updatedAtTimestamp_not: Int
  updatedAtTimestamp_not_in: [Int!]
  updatedAtTx: String
  updatedAtTx_contains: String
  updatedAtTx_ends_with: String
  updatedAtTx_gt: String
  updatedAtTx_gte: String
  updatedAtTx_in: [String!]
  updatedAtTx_lt: String
  updatedAtTx_lte: String
  updatedAtTx_not: String
  updatedAtTx_not_contains: String
  updatedAtTx_not_ends_with: String
  updatedAtTx_not_in: [String!]
  updatedAtTx_not_starts_with: String
  updatedAtTx_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum BitcoinTransfer_orderBy {
  amountBTC
  bitcoinTxHash
  btcAddress
  createdAtBlockNumber
  createdAtTimestamp
  createdAtTx
  feeBTC
  id
  nonce
  status
  totalAmountBTC
  updatedAtBlockNumber
  updatedAtTimestamp
  updatedAtTx
  user
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows (takes out a loan)
"""
type Borrow {
  collateralToLoanRate: BigDecimal!
  collateralToken: Bytes!
  currentMargin: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  interestDuration: BigDecimal!
  interestRate: BigDecimal!
  lender: Bytes!
  loanId: Loan!
  loanToken: Bytes!
  newCollateral: BigDecimal!
  newPrincipal: BigDecimal!
  timestamp: Int!
  transaction: Transaction!
  user: User!
}

input Borrow_filter {
  collateralToLoanRate: BigDecimal
  collateralToLoanRate_gt: BigDecimal
  collateralToLoanRate_gte: BigDecimal
  collateralToLoanRate_in: [BigDecimal!]
  collateralToLoanRate_lt: BigDecimal
  collateralToLoanRate_lte: BigDecimal
  collateralToLoanRate_not: BigDecimal
  collateralToLoanRate_not_in: [BigDecimal!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  currentMargin: BigDecimal
  currentMargin_gt: BigDecimal
  currentMargin_gte: BigDecimal
  currentMargin_in: [BigDecimal!]
  currentMargin_lt: BigDecimal
  currentMargin_lte: BigDecimal
  currentMargin_not: BigDecimal
  currentMargin_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  interestDuration: BigDecimal
  interestDuration_gt: BigDecimal
  interestDuration_gte: BigDecimal
  interestDuration_in: [BigDecimal!]
  interestDuration_lt: BigDecimal
  interestDuration_lte: BigDecimal
  interestDuration_not: BigDecimal
  interestDuration_not_in: [BigDecimal!]
  interestRate: BigDecimal
  interestRate_gt: BigDecimal
  interestRate_gte: BigDecimal
  interestRate_in: [BigDecimal!]
  interestRate_lt: BigDecimal
  interestRate_lte: BigDecimal
  interestRate_not: BigDecimal
  interestRate_not_in: [BigDecimal!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  newCollateral: BigDecimal
  newCollateral_gt: BigDecimal
  newCollateral_gte: BigDecimal
  newCollateral_in: [BigDecimal!]
  newCollateral_lt: BigDecimal
  newCollateral_lte: BigDecimal
  newCollateral_not: BigDecimal
  newCollateral_not_in: [BigDecimal!]
  newPrincipal: BigDecimal
  newPrincipal_gt: BigDecimal
  newPrincipal_gte: BigDecimal
  newPrincipal_in: [BigDecimal!]
  newPrincipal_lt: BigDecimal
  newPrincipal_lte: BigDecimal
  newPrincipal_not: BigDecimal
  newPrincipal_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum Borrow_orderBy {
  collateralToLoanRate
  collateralToken
  currentMargin
  emittedBy
  id
  interestDuration
  interestRate
  lender
  loanId
  loanToken
  newCollateral
  newPrincipal
  timestamp
  transaction
  user
}

scalar Bytes

"""
Candlesticks are for presentational purposes on the dapp. This entity supports the candlestick trading data on the trading view charts.
Trading data is available for the following pairs:
1. All tokens to RBTC
2. All tokens to XUSD
There is not candlestick data for other trading pairs as this would cause the amount of data stored to increase exponentially
"""
type CandleStick {
  """
  Eg in the pair SOV-XUSD, the base token is SOV and the quote token is XUSD
  Prices shown are the price of the base token in the quote token (eg price of SOV in XUSD)
  """
  baseToken: Token
  close: BigDecimal!
  high: BigDecimal!

  """
  The ID is fromToken + toToken + timestamp + interval
  toToken will be either RBTC or XUSD
  interval is a CandleSticksInterval (see interval data type below)
  """
  id: ID!

  """
  Time period of this particular candlestick series
  """
  interval: CandleSticksInterval
  low: BigDecimal!
  open: BigDecimal

  """
  Unix timestamp for the candlestick start time
  """
  periodStartUnix: Int!
  quoteToken: Token

  """
  The volume of the base token that has been bought and sold in this time period
  """
  totalVolume: BigDecimal!
  txCount: Int!
}

input CandleStick_filter {
  baseToken: String
  baseToken_contains: String
  baseToken_ends_with: String
  baseToken_gt: String
  baseToken_gte: String
  baseToken_in: [String!]
  baseToken_lt: String
  baseToken_lte: String
  baseToken_not: String
  baseToken_not_contains: String
  baseToken_not_ends_with: String
  baseToken_not_in: [String!]
  baseToken_not_starts_with: String
  baseToken_starts_with: String
  close: BigDecimal
  close_gt: BigDecimal
  close_gte: BigDecimal
  close_in: [BigDecimal!]
  close_lt: BigDecimal
  close_lte: BigDecimal
  close_not: BigDecimal
  close_not_in: [BigDecimal!]
  high: BigDecimal
  high_gt: BigDecimal
  high_gte: BigDecimal
  high_in: [BigDecimal!]
  high_lt: BigDecimal
  high_lte: BigDecimal
  high_not: BigDecimal
  high_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  interval: CandleSticksInterval
  interval_in: [CandleSticksInterval!]
  interval_not: CandleSticksInterval
  interval_not_in: [CandleSticksInterval!]
  low: BigDecimal
  low_gt: BigDecimal
  low_gte: BigDecimal
  low_in: [BigDecimal!]
  low_lt: BigDecimal
  low_lte: BigDecimal
  low_not: BigDecimal
  low_not_in: [BigDecimal!]
  open: BigDecimal
  open_gt: BigDecimal
  open_gte: BigDecimal
  open_in: [BigDecimal!]
  open_lt: BigDecimal
  open_lte: BigDecimal
  open_not: BigDecimal
  open_not_in: [BigDecimal!]
  periodStartUnix: Int
  periodStartUnix_gt: Int
  periodStartUnix_gte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_lt: Int
  periodStartUnix_lte: Int
  periodStartUnix_not: Int
  periodStartUnix_not_in: [Int!]
  quoteToken: String
  quoteToken_contains: String
  quoteToken_ends_with: String
  quoteToken_gt: String
  quoteToken_gte: String
  quoteToken_in: [String!]
  quoteToken_lt: String
  quoteToken_lte: String
  quoteToken_not: String
  quoteToken_not_contains: String
  quoteToken_not_ends_with: String
  quoteToken_not_in: [String!]
  quoteToken_not_starts_with: String
  quoteToken_starts_with: String
  totalVolume: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_lt: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_not_in: [BigDecimal!]
  txCount: Int
  txCount_gt: Int
  txCount_gte: Int
  txCount_in: [Int!]
  txCount_lt: Int
  txCount_lte: Int
  txCount_not: Int
  txCount_not_in: [Int!]
}

enum CandleStick_orderBy {
  baseToken
  close
  high
  id
  interval
  low
  open
  periodStartUnix
  quoteToken
  totalVolume
  txCount
}

enum CandleSticksInterval {
  DayInterval
  FifteenMinutesInterval
  FourHourInterval
  HourInterval
  MinuteInterval
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Borrow event
"""
type CloseWithDeposit {
  closer: Bytes!
  collateralToLoanRate: BigDecimal!
  collateralToken: Bytes!
  collateralWithdrawAmount: BigDecimal!
  currentMargin: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  lender: Bytes!
  loanId: Loan!
  loanToken: Bytes!
  repayAmount: BigDecimal!
  timestamp: Int!
  transaction: Transaction!
  user: Bytes!
}

input CloseWithDeposit_filter {
  closer: Bytes
  closer_contains: Bytes
  closer_in: [Bytes!]
  closer_not: Bytes
  closer_not_contains: Bytes
  closer_not_in: [Bytes!]
  collateralToLoanRate: BigDecimal
  collateralToLoanRate_gt: BigDecimal
  collateralToLoanRate_gte: BigDecimal
  collateralToLoanRate_in: [BigDecimal!]
  collateralToLoanRate_lt: BigDecimal
  collateralToLoanRate_lte: BigDecimal
  collateralToLoanRate_not: BigDecimal
  collateralToLoanRate_not_in: [BigDecimal!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  collateralWithdrawAmount: BigDecimal
  collateralWithdrawAmount_gt: BigDecimal
  collateralWithdrawAmount_gte: BigDecimal
  collateralWithdrawAmount_in: [BigDecimal!]
  collateralWithdrawAmount_lt: BigDecimal
  collateralWithdrawAmount_lte: BigDecimal
  collateralWithdrawAmount_not: BigDecimal
  collateralWithdrawAmount_not_in: [BigDecimal!]
  currentMargin: BigDecimal
  currentMargin_gt: BigDecimal
  currentMargin_gte: BigDecimal
  currentMargin_in: [BigDecimal!]
  currentMargin_lt: BigDecimal
  currentMargin_lte: BigDecimal
  currentMargin_not: BigDecimal
  currentMargin_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  repayAmount: BigDecimal
  repayAmount_gt: BigDecimal
  repayAmount_gte: BigDecimal
  repayAmount_in: [BigDecimal!]
  repayAmount_lt: BigDecimal
  repayAmount_lte: BigDecimal
  repayAmount_not: BigDecimal
  repayAmount_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: Bytes
  user_contains: Bytes
  user_in: [Bytes!]
  user_not: Bytes
  user_not_contains: Bytes
  user_not_in: [Bytes!]
}

enum CloseWithDeposit_orderBy {
  closer
  collateralToLoanRate
  collateralToken
  collateralWithdrawAmount
  currentMargin
  emittedBy
  id
  lender
  loanId
  loanToken
  repayAmount
  timestamp
  transaction
  user
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Margin Trade
"""
type CloseWithSwap {
  closer: Bytes!
  collateralToken: Bytes!

  """
  Leverage on the smart contract does not count user-provided collateral.
  So, what would on the dapp be a 2x leverage trade would be a 1 here
  """
  currentLeverage: BigDecimal!
  emittedBy: Bytes!
  exitPrice: BigDecimal!
  id: ID!
  lender: Bytes!
  loanCloseAmount: BigDecimal!
  loanId: Loan!
  loanToken: Bytes!
  positionCloseSize: BigDecimal!
  timestamp: Int!
  transaction: Transaction!
  user: Bytes!
}

input CloseWithSwap_filter {
  closer: Bytes
  closer_contains: Bytes
  closer_in: [Bytes!]
  closer_not: Bytes
  closer_not_contains: Bytes
  closer_not_in: [Bytes!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  currentLeverage: BigDecimal
  currentLeverage_gt: BigDecimal
  currentLeverage_gte: BigDecimal
  currentLeverage_in: [BigDecimal!]
  currentLeverage_lt: BigDecimal
  currentLeverage_lte: BigDecimal
  currentLeverage_not: BigDecimal
  currentLeverage_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  exitPrice: BigDecimal
  exitPrice_gt: BigDecimal
  exitPrice_gte: BigDecimal
  exitPrice_in: [BigDecimal!]
  exitPrice_lt: BigDecimal
  exitPrice_lte: BigDecimal
  exitPrice_not: BigDecimal
  exitPrice_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanCloseAmount: BigDecimal
  loanCloseAmount_gt: BigDecimal
  loanCloseAmount_gte: BigDecimal
  loanCloseAmount_in: [BigDecimal!]
  loanCloseAmount_lt: BigDecimal
  loanCloseAmount_lte: BigDecimal
  loanCloseAmount_not: BigDecimal
  loanCloseAmount_not_in: [BigDecimal!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  positionCloseSize: BigDecimal
  positionCloseSize_gt: BigDecimal
  positionCloseSize_gte: BigDecimal
  positionCloseSize_in: [BigDecimal!]
  positionCloseSize_lt: BigDecimal
  positionCloseSize_lte: BigDecimal
  positionCloseSize_not: BigDecimal
  positionCloseSize_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: Bytes
  user_contains: Bytes
  user_in: [Bytes!]
  user_not: Bytes
  user_not_contains: Bytes
  user_not_in: [Bytes!]
}

enum CloseWithSwap_orderBy {
  closer
  collateralToken
  currentLeverage
  emittedBy
  exitPrice
  id
  lender
  loanCloseAmount
  loanId
  loanToken
  positionCloseSize
  timestamp
  transaction
  user
}

"""
Granular Conversion events, exactly as they appear on the contracts.
These events are the raw data that the Swap entity and candlestick entities are built from.
"""
type Conversion {
  _amount: BigDecimal!
  _conversionFee: BigDecimal!
  _fromToken: Token!
  _protocolFee: BigDecimal!
  _return: BigDecimal!
  _toToken: Token!
  _trader: Bytes!
  blockNumber: Int!
  emittedBy: LiquidityPool!
  id: ID!
  swapTransaction: Swap!
  timestamp: Int!
  transaction: Transaction!
}

input Conversion_filter {
  _amount: BigDecimal
  _amount_gt: BigDecimal
  _amount_gte: BigDecimal
  _amount_in: [BigDecimal!]
  _amount_lt: BigDecimal
  _amount_lte: BigDecimal
  _amount_not: BigDecimal
  _amount_not_in: [BigDecimal!]
  _conversionFee: BigDecimal
  _conversionFee_gt: BigDecimal
  _conversionFee_gte: BigDecimal
  _conversionFee_in: [BigDecimal!]
  _conversionFee_lt: BigDecimal
  _conversionFee_lte: BigDecimal
  _conversionFee_not: BigDecimal
  _conversionFee_not_in: [BigDecimal!]
  _fromToken: String
  _fromToken_contains: String
  _fromToken_ends_with: String
  _fromToken_gt: String
  _fromToken_gte: String
  _fromToken_in: [String!]
  _fromToken_lt: String
  _fromToken_lte: String
  _fromToken_not: String
  _fromToken_not_contains: String
  _fromToken_not_ends_with: String
  _fromToken_not_in: [String!]
  _fromToken_not_starts_with: String
  _fromToken_starts_with: String
  _protocolFee: BigDecimal
  _protocolFee_gt: BigDecimal
  _protocolFee_gte: BigDecimal
  _protocolFee_in: [BigDecimal!]
  _protocolFee_lt: BigDecimal
  _protocolFee_lte: BigDecimal
  _protocolFee_not: BigDecimal
  _protocolFee_not_in: [BigDecimal!]
  _return: BigDecimal
  _return_gt: BigDecimal
  _return_gte: BigDecimal
  _return_in: [BigDecimal!]
  _return_lt: BigDecimal
  _return_lte: BigDecimal
  _return_not: BigDecimal
  _return_not_in: [BigDecimal!]
  _toToken: String
  _toToken_contains: String
  _toToken_ends_with: String
  _toToken_gt: String
  _toToken_gte: String
  _toToken_in: [String!]
  _toToken_lt: String
  _toToken_lte: String
  _toToken_not: String
  _toToken_not_contains: String
  _toToken_not_ends_with: String
  _toToken_not_in: [String!]
  _toToken_not_starts_with: String
  _toToken_starts_with: String
  _trader: Bytes
  _trader_contains: Bytes
  _trader_in: [Bytes!]
  _trader_not: Bytes
  _trader_not_contains: Bytes
  _trader_not_in: [Bytes!]
  blockNumber: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_in: [Int!]
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_not: Int
  blockNumber_not_in: [Int!]
  emittedBy: String
  emittedBy_contains: String
  emittedBy_ends_with: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_ends_with: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  swapTransaction: String
  swapTransaction_contains: String
  swapTransaction_ends_with: String
  swapTransaction_gt: String
  swapTransaction_gte: String
  swapTransaction_in: [String!]
  swapTransaction_lt: String
  swapTransaction_lte: String
  swapTransaction_not: String
  swapTransaction_not_contains: String
  swapTransaction_not_ends_with: String
  swapTransaction_not_in: [String!]
  swapTransaction_not_starts_with: String
  swapTransaction_starts_with: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum Conversion_orderBy {
  _amount
  _conversionFee
  _fromToken
  _protocolFee
  _return
  _toToken
  _trader
  blockNumber
  emittedBy
  id
  swapTransaction
  timestamp
  transaction
}

"""
The ConverterRegistry registers each new AMM pool added to the Sovryn Protocol
"""
type ConverterRegistry {
  """
  All ERC20 tokens in this registry
  """
  connectorTokens(
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Token_filter
  ): [Token!]

  """
  All the converters (AMM pools) associated with this registry
  """
  converters(
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityPool_filter
  ): [LiquidityPool!]

  """
  ID is the address of the converter registry contract
  """
  id: ID!

  """
  The number of active converters (AMM pools) in this registry
  """
  numConverters: Int!

  """
  The contract/account that owns the registry
  """
  owner: Bytes!

  """
  All smart tokens in this registry
  """
  smartTokens(
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: SmartToken_filter
  ): [SmartToken!]
}

input ConverterRegistry_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  numConverters: Int
  numConverters_gt: Int
  numConverters_gte: Int
  numConverters_in: [Int!]
  numConverters_lt: Int
  numConverters_lte: Int
  numConverters_not: Int
  numConverters_not_in: [Int!]
  owner: Bytes
  owner_contains: Bytes
  owner_in: [Bytes!]
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
}

enum ConverterRegistry_orderBy {
  connectorTokens
  converters
  id
  numConverters
  owner
  smartTokens
}

type Deposit {
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  timestamp: Int!
  to: Bytes!
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user closes adds collateral to a Margin Trade or Borrow
"""
type DepositCollateral {
  depositAmount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  loanId: Loan!

  """
  Rate is sometimes null because this property was not included in older versions of the contract
  """
  rate: BigDecimal
  timestamp: Int!
  transaction: Transaction!
}

input DepositCollateral_filter {
  depositAmount: BigDecimal
  depositAmount_gt: BigDecimal
  depositAmount_gte: BigDecimal
  depositAmount_in: [BigDecimal!]
  depositAmount_lt: BigDecimal
  depositAmount_lte: BigDecimal
  depositAmount_not: BigDecimal
  depositAmount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum DepositCollateral_orderBy {
  depositAmount
  emittedBy
  id
  loanId
  rate
  timestamp
  transaction
}

input Deposit_filter {
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  to: Bytes
  to_contains: Bytes
  to_in: [Bytes!]
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum Deposit_orderBy {
  amount
  emittedBy
  id
  timestamp
  to
  transaction
}

type FastBTCBridgeStat {
  createdAtTx: Transaction!
  id: ID!
  totalAmountBTCInitialized: BigDecimal!
  totalAmountBTCMined: BigDecimal!
  totalAmountBTCRefunded: BigDecimal!
  totalAmountBTCSending: BigDecimal!
  totalFeesBTC: BigDecimal!
  updatedAtTx: Transaction!
  user: User
}

input FastBTCBridgeStat_filter {
  createdAtTx: String
  createdAtTx_contains: String
  createdAtTx_ends_with: String
  createdAtTx_gt: String
  createdAtTx_gte: String
  createdAtTx_in: [String!]
  createdAtTx_lt: String
  createdAtTx_lte: String
  createdAtTx_not: String
  createdAtTx_not_contains: String
  createdAtTx_not_ends_with: String
  createdAtTx_not_in: [String!]
  createdAtTx_not_starts_with: String
  createdAtTx_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  totalAmountBTCInitialized: BigDecimal
  totalAmountBTCInitialized_gt: BigDecimal
  totalAmountBTCInitialized_gte: BigDecimal
  totalAmountBTCInitialized_in: [BigDecimal!]
  totalAmountBTCInitialized_lt: BigDecimal
  totalAmountBTCInitialized_lte: BigDecimal
  totalAmountBTCInitialized_not: BigDecimal
  totalAmountBTCInitialized_not_in: [BigDecimal!]
  totalAmountBTCMined: BigDecimal
  totalAmountBTCMined_gt: BigDecimal
  totalAmountBTCMined_gte: BigDecimal
  totalAmountBTCMined_in: [BigDecimal!]
  totalAmountBTCMined_lt: BigDecimal
  totalAmountBTCMined_lte: BigDecimal
  totalAmountBTCMined_not: BigDecimal
  totalAmountBTCMined_not_in: [BigDecimal!]
  totalAmountBTCRefunded: BigDecimal
  totalAmountBTCRefunded_gt: BigDecimal
  totalAmountBTCRefunded_gte: BigDecimal
  totalAmountBTCRefunded_in: [BigDecimal!]
  totalAmountBTCRefunded_lt: BigDecimal
  totalAmountBTCRefunded_lte: BigDecimal
  totalAmountBTCRefunded_not: BigDecimal
  totalAmountBTCRefunded_not_in: [BigDecimal!]
  totalAmountBTCSending: BigDecimal
  totalAmountBTCSending_gt: BigDecimal
  totalAmountBTCSending_gte: BigDecimal
  totalAmountBTCSending_in: [BigDecimal!]
  totalAmountBTCSending_lt: BigDecimal
  totalAmountBTCSending_lte: BigDecimal
  totalAmountBTCSending_not: BigDecimal
  totalAmountBTCSending_not_in: [BigDecimal!]
  totalFeesBTC: BigDecimal
  totalFeesBTC_gt: BigDecimal
  totalFeesBTC_gte: BigDecimal
  totalFeesBTC_in: [BigDecimal!]
  totalFeesBTC_lt: BigDecimal
  totalFeesBTC_lte: BigDecimal
  totalFeesBTC_not: BigDecimal
  totalFeesBTC_not_in: [BigDecimal!]
  updatedAtTx: String
  updatedAtTx_contains: String
  updatedAtTx_ends_with: String
  updatedAtTx_gt: String
  updatedAtTx_gte: String
  updatedAtTx_in: [String!]
  updatedAtTx_lt: String
  updatedAtTx_lte: String
  updatedAtTx_not: String
  updatedAtTx_not_contains: String
  updatedAtTx_not_ends_with: String
  updatedAtTx_not_in: [String!]
  updatedAtTx_not_starts_with: String
  updatedAtTx_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum FastBTCBridgeStat_orderBy {
  createdAtTx
  id
  totalAmountBTCInitialized
  totalAmountBTCMined
  totalAmountBTCRefunded
  totalAmountBTCSending
  totalFeesBTC
  updatedAtTx
  user
}

type FeeSharingTokensTransferred {
  amount: BigDecimal!
  id: ID!
  sender: Bytes!
  token: Bytes!
}

input FeeSharingTokensTransferred_filter {
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  sender: Bytes
  sender_contains: Bytes
  sender_in: [Bytes!]
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
}

enum FeeSharingTokensTransferred_orderBy {
  amount
  id
  sender
  token
}

"""
LendingHistoryItem is one user's history of Lend/UnLend events across all the lending pools
"""
type LendingHistoryItem {
  """
  The amount of ERC20 token that was lent/unlent
  """
  amount: BigDecimal!

  """
  The underlying asset for this pool (eg USDT for the iUSDT pool)
  """
  asset: Token
  emittedBy: String!
  id: ID!
  lender: User!

  """
  The lending pool the user interacted with
  """
  lendingPool: LendingPool!

  """
  The amount of pool token that was minted or burned
  """
  loanTokenAmount: BigDecimal!
  timestamp: Int!
  transaction: Transaction!

  """
  Type is Lend/UnLend
  """
  type: LendingHistoryType!

  """
  Foreign key to the UserLendingHistory entity (see the docs on this entity for more information)
  """
  userLendingHistory: UserLendingHistory!
}

input LendingHistoryItem_filter {
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  asset: String
  asset_contains: String
  asset_ends_with: String
  asset_gt: String
  asset_gte: String
  asset_in: [String!]
  asset_lt: String
  asset_lte: String
  asset_not: String
  asset_not_contains: String
  asset_not_ends_with: String
  asset_not_in: [String!]
  asset_not_starts_with: String
  asset_starts_with: String
  emittedBy: String
  emittedBy_contains: String
  emittedBy_ends_with: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_ends_with: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: String
  lender_contains: String
  lender_ends_with: String
  lender_gt: String
  lender_gte: String
  lender_in: [String!]
  lender_lt: String
  lender_lte: String
  lender_not: String
  lender_not_contains: String
  lender_not_ends_with: String
  lender_not_in: [String!]
  lender_not_starts_with: String
  lender_starts_with: String
  lendingPool: String
  lendingPool_contains: String
  lendingPool_ends_with: String
  lendingPool_gt: String
  lendingPool_gte: String
  lendingPool_in: [String!]
  lendingPool_lt: String
  lendingPool_lte: String
  lendingPool_not: String
  lendingPool_not_contains: String
  lendingPool_not_ends_with: String
  lendingPool_not_in: [String!]
  lendingPool_not_starts_with: String
  lendingPool_starts_with: String
  loanTokenAmount: BigDecimal
  loanTokenAmount_gt: BigDecimal
  loanTokenAmount_gte: BigDecimal
  loanTokenAmount_in: [BigDecimal!]
  loanTokenAmount_lt: BigDecimal
  loanTokenAmount_lte: BigDecimal
  loanTokenAmount_not: BigDecimal
  loanTokenAmount_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  type: LendingHistoryType
  type_in: [LendingHistoryType!]
  type_not: LendingHistoryType
  type_not_in: [LendingHistoryType!]
  userLendingHistory: String
  userLendingHistory_contains: String
  userLendingHistory_ends_with: String
  userLendingHistory_gt: String
  userLendingHistory_gte: String
  userLendingHistory_in: [String!]
  userLendingHistory_lt: String
  userLendingHistory_lte: String
  userLendingHistory_not: String
  userLendingHistory_not_contains: String
  userLendingHistory_not_ends_with: String
  userLendingHistory_not_in: [String!]
  userLendingHistory_not_starts_with: String
  userLendingHistory_starts_with: String
}

enum LendingHistoryItem_orderBy {
  amount
  asset
  emittedBy
  id
  lender
  lendingPool
  loanTokenAmount
  timestamp
  transaction
  type
  userLendingHistory
}

enum LendingHistoryType {
  """
  Lend is equivalent to a Mint event
  """
  Lend

  """
  UnLend is equivalent to a Burn event
  """
  UnLend
}

"""
A Lending Pool (iToken), where Users can lend assets to earn interest, and Users can borrow assets to Margin Trade or just as a regular loan.
"""
type LendingPool {
  """
  Balance of the underlying asset (ERC20 token) represented by the total supply of pool tokens
  It is incremented on Mint events and decremented on Burn events.
  WORK-IN-PROGRESS: This is a work-in-progress as it does not properly account for interest payments currently
  """
  assetBalance: BigDecimal!

  """
  ID is the contract address of the iToken
  """
  id: ID!

  """
  The total supply of this pool token (not the underlying asset).
  It is incremented on Mint events and decremented on Burn events
  """
  poolTokenBalance: BigDecimal!

  """
  Total asset volume lent over all time
  """
  totalAssetLent: BigDecimal!

  """
  The actual asset being lent and borrowed in this pool
  """
  underlyingAsset: Token!
}

input LendingPool_filter {
  assetBalance: BigDecimal
  assetBalance_gt: BigDecimal
  assetBalance_gte: BigDecimal
  assetBalance_in: [BigDecimal!]
  assetBalance_lt: BigDecimal
  assetBalance_lte: BigDecimal
  assetBalance_not: BigDecimal
  assetBalance_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolTokenBalance: BigDecimal
  poolTokenBalance_gt: BigDecimal
  poolTokenBalance_gte: BigDecimal
  poolTokenBalance_in: [BigDecimal!]
  poolTokenBalance_lt: BigDecimal
  poolTokenBalance_lte: BigDecimal
  poolTokenBalance_not: BigDecimal
  poolTokenBalance_not_in: [BigDecimal!]
  totalAssetLent: BigDecimal
  totalAssetLent_gt: BigDecimal
  totalAssetLent_gte: BigDecimal
  totalAssetLent_in: [BigDecimal!]
  totalAssetLent_lt: BigDecimal
  totalAssetLent_lte: BigDecimal
  totalAssetLent_not: BigDecimal
  totalAssetLent_not_in: [BigDecimal!]
  underlyingAsset: String
  underlyingAsset_contains: String
  underlyingAsset_ends_with: String
  underlyingAsset_gt: String
  underlyingAsset_gte: String
  underlyingAsset_in: [String!]
  underlyingAsset_lt: String
  underlyingAsset_lte: String
  underlyingAsset_not: String
  underlyingAsset_not_contains: String
  underlyingAsset_not_ends_with: String
  underlyingAsset_not_in: [String!]
  underlyingAsset_not_starts_with: String
  underlyingAsset_starts_with: String
}

enum LendingPool_orderBy {
  assetBalance
  id
  poolTokenBalance
  totalAssetLent
  underlyingAsset
}

"""
Granular event data for the Loan entity. Emitted when a loan is fully or partially liquidated
"""
type Liquidate {
  collateralToLoanRate: BigDecimal!
  collateralToken: Bytes!
  collateralWithdrawAmount: BigDecimal!
  currentMargin: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  lender: Bytes!
  liquidator: Bytes!
  loanId: Loan!
  loanToken: Bytes!
  repayAmount: BigDecimal!
  timestamp: Int!
  transaction: Transaction!
  user: User!
}

input Liquidate_filter {
  collateralToLoanRate: BigDecimal
  collateralToLoanRate_gt: BigDecimal
  collateralToLoanRate_gte: BigDecimal
  collateralToLoanRate_in: [BigDecimal!]
  collateralToLoanRate_lt: BigDecimal
  collateralToLoanRate_lte: BigDecimal
  collateralToLoanRate_not: BigDecimal
  collateralToLoanRate_not_in: [BigDecimal!]
  collateralToken: Bytes
  collateralToken_contains: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not: Bytes
  collateralToken_not_contains: Bytes
  collateralToken_not_in: [Bytes!]
  collateralWithdrawAmount: BigDecimal
  collateralWithdrawAmount_gt: BigDecimal
  collateralWithdrawAmount_gte: BigDecimal
  collateralWithdrawAmount_in: [BigDecimal!]
  collateralWithdrawAmount_lt: BigDecimal
  collateralWithdrawAmount_lte: BigDecimal
  collateralWithdrawAmount_not: BigDecimal
  collateralWithdrawAmount_not_in: [BigDecimal!]
  currentMargin: BigDecimal
  currentMargin_gt: BigDecimal
  currentMargin_gte: BigDecimal
  currentMargin_in: [BigDecimal!]
  currentMargin_lt: BigDecimal
  currentMargin_lte: BigDecimal
  currentMargin_not: BigDecimal
  currentMargin_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  liquidator: Bytes
  liquidator_contains: Bytes
  liquidator_in: [Bytes!]
  liquidator_not: Bytes
  liquidator_not_contains: Bytes
  liquidator_not_in: [Bytes!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  loanToken: Bytes
  loanToken_contains: Bytes
  loanToken_in: [Bytes!]
  loanToken_not: Bytes
  loanToken_not_contains: Bytes
  loanToken_not_in: [Bytes!]
  repayAmount: BigDecimal
  repayAmount_gt: BigDecimal
  repayAmount_gte: BigDecimal
  repayAmount_in: [BigDecimal!]
  repayAmount_lt: BigDecimal
  repayAmount_lte: BigDecimal
  repayAmount_not: BigDecimal
  repayAmount_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum Liquidate_orderBy {
  collateralToLoanRate
  collateralToken
  collateralWithdrawAmount
  currentMargin
  emittedBy
  id
  lender
  liquidator
  loanId
  loanToken
  repayAmount
  timestamp
  transaction
  user
}

type LiquidityHistoryItem {
  """
  The amount that was added/removed
  """
  amount: BigDecimal!

  """
  The contract that emitted this event (primarily used for debugging)
  """
  emittedBy: String!

  """
  ID is transaction hash + log index
  """
  id: ID!

  """
  AMM pool that liquidity was provided to
  """
  liquidityPool: LiquidityPool!

  """
  New balance of the reserveToken (ERC20 token) on the AMM pool
  """
  newBalance: BigDecimal!

  """
  New total supply of pool tokens
  """
  newSupply: BigDecimal!

  """
  Provider is either the user, or a contract if the user interacted with a proxy contract
  """
  provider: String!

  """
  The underlying asset (ERC20 token) that was added/removed
  """
  reserveToken: Token!
  timestamp: Int!
  transaction: Transaction!

  """
  Type is either Added or Removed (if a user added or removed liquidity from the pool)
  """
  type: LiquidityHistoryType!
  user: User!

  """
  Foreign key to join this transaction to the parent UserLiquidityHistory entity
  """
  userLiquidityHistory: UserLiquidityHistory!
}

input LiquidityHistoryItem_filter {
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: String
  emittedBy_contains: String
  emittedBy_ends_with: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_ends_with: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPool: String
  liquidityPool_contains: String
  liquidityPool_ends_with: String
  liquidityPool_gt: String
  liquidityPool_gte: String
  liquidityPool_in: [String!]
  liquidityPool_lt: String
  liquidityPool_lte: String
  liquidityPool_not: String
  liquidityPool_not_contains: String
  liquidityPool_not_ends_with: String
  liquidityPool_not_in: [String!]
  liquidityPool_not_starts_with: String
  liquidityPool_starts_with: String
  newBalance: BigDecimal
  newBalance_gt: BigDecimal
  newBalance_gte: BigDecimal
  newBalance_in: [BigDecimal!]
  newBalance_lt: BigDecimal
  newBalance_lte: BigDecimal
  newBalance_not: BigDecimal
  newBalance_not_in: [BigDecimal!]
  newSupply: BigDecimal
  newSupply_gt: BigDecimal
  newSupply_gte: BigDecimal
  newSupply_in: [BigDecimal!]
  newSupply_lt: BigDecimal
  newSupply_lte: BigDecimal
  newSupply_not: BigDecimal
  newSupply_not_in: [BigDecimal!]
  provider: String
  provider_contains: String
  provider_ends_with: String
  provider_gt: String
  provider_gte: String
  provider_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_not: String
  provider_not_contains: String
  provider_not_ends_with: String
  provider_not_in: [String!]
  provider_not_starts_with: String
  provider_starts_with: String
  reserveToken: String
  reserveToken_contains: String
  reserveToken_ends_with: String
  reserveToken_gt: String
  reserveToken_gte: String
  reserveToken_in: [String!]
  reserveToken_lt: String
  reserveToken_lte: String
  reserveToken_not: String
  reserveToken_not_contains: String
  reserveToken_not_ends_with: String
  reserveToken_not_in: [String!]
  reserveToken_not_starts_with: String
  reserveToken_starts_with: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  type: LiquidityHistoryType
  type_in: [LiquidityHistoryType!]
  type_not: LiquidityHistoryType
  type_not_in: [LiquidityHistoryType!]
  user: String
  userLiquidityHistory: String
  userLiquidityHistory_contains: String
  userLiquidityHistory_ends_with: String
  userLiquidityHistory_gt: String
  userLiquidityHistory_gte: String
  userLiquidityHistory_in: [String!]
  userLiquidityHistory_lt: String
  userLiquidityHistory_lte: String
  userLiquidityHistory_not: String
  userLiquidityHistory_not_contains: String
  userLiquidityHistory_not_ends_with: String
  userLiquidityHistory_not_in: [String!]
  userLiquidityHistory_not_starts_with: String
  userLiquidityHistory_starts_with: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum LiquidityHistoryItem_orderBy {
  amount
  emittedBy
  id
  liquidityPool
  newBalance
  newSupply
  provider
  reserveToken
  timestamp
  transaction
  type
  user
  userLiquidityHistory
}

enum LiquidityHistoryType {
  Added
  Removed
}

type LiquidityMiningAllocationPoint {
  allocationPoint: BigInt!
  ammPoolToken: SmartToken
  id: ID!
  lendingPoolToken: LendingPool
  poolTokenAddedBlock: Int!
  poolTokenAddedTimestamp: Int!
  poolTokenUpdatedBlock: Int!
  poolTokenUpdatedTImestamp: Int!

  """
  Calculated as (totalRewardPerBlock * allocationPoint) / totalAllocationPoint
  """
  rewardPerBlock: BigDecimal!
}

input LiquidityMiningAllocationPoint_filter {
  allocationPoint: BigInt
  allocationPoint_gt: BigInt
  allocationPoint_gte: BigInt
  allocationPoint_in: [BigInt!]
  allocationPoint_lt: BigInt
  allocationPoint_lte: BigInt
  allocationPoint_not: BigInt
  allocationPoint_not_in: [BigInt!]
  ammPoolToken: String
  ammPoolToken_contains: String
  ammPoolToken_ends_with: String
  ammPoolToken_gt: String
  ammPoolToken_gte: String
  ammPoolToken_in: [String!]
  ammPoolToken_lt: String
  ammPoolToken_lte: String
  ammPoolToken_not: String
  ammPoolToken_not_contains: String
  ammPoolToken_not_ends_with: String
  ammPoolToken_not_in: [String!]
  ammPoolToken_not_starts_with: String
  ammPoolToken_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lendingPoolToken: String
  lendingPoolToken_contains: String
  lendingPoolToken_ends_with: String
  lendingPoolToken_gt: String
  lendingPoolToken_gte: String
  lendingPoolToken_in: [String!]
  lendingPoolToken_lt: String
  lendingPoolToken_lte: String
  lendingPoolToken_not: String
  lendingPoolToken_not_contains: String
  lendingPoolToken_not_ends_with: String
  lendingPoolToken_not_in: [String!]
  lendingPoolToken_not_starts_with: String
  lendingPoolToken_starts_with: String
  poolTokenAddedBlock: Int
  poolTokenAddedBlock_gt: Int
  poolTokenAddedBlock_gte: Int
  poolTokenAddedBlock_in: [Int!]
  poolTokenAddedBlock_lt: Int
  poolTokenAddedBlock_lte: Int
  poolTokenAddedBlock_not: Int
  poolTokenAddedBlock_not_in: [Int!]
  poolTokenAddedTimestamp: Int
  poolTokenAddedTimestamp_gt: Int
  poolTokenAddedTimestamp_gte: Int
  poolTokenAddedTimestamp_in: [Int!]
  poolTokenAddedTimestamp_lt: Int
  poolTokenAddedTimestamp_lte: Int
  poolTokenAddedTimestamp_not: Int
  poolTokenAddedTimestamp_not_in: [Int!]
  poolTokenUpdatedBlock: Int
  poolTokenUpdatedBlock_gt: Int
  poolTokenUpdatedBlock_gte: Int
  poolTokenUpdatedBlock_in: [Int!]
  poolTokenUpdatedBlock_lt: Int
  poolTokenUpdatedBlock_lte: Int
  poolTokenUpdatedBlock_not: Int
  poolTokenUpdatedBlock_not_in: [Int!]
  poolTokenUpdatedTImestamp: Int
  poolTokenUpdatedTImestamp_gt: Int
  poolTokenUpdatedTImestamp_gte: Int
  poolTokenUpdatedTImestamp_in: [Int!]
  poolTokenUpdatedTImestamp_lt: Int
  poolTokenUpdatedTImestamp_lte: Int
  poolTokenUpdatedTImestamp_not: Int
  poolTokenUpdatedTImestamp_not_in: [Int!]
  rewardPerBlock: BigDecimal
  rewardPerBlock_gt: BigDecimal
  rewardPerBlock_gte: BigDecimal
  rewardPerBlock_in: [BigDecimal!]
  rewardPerBlock_lt: BigDecimal
  rewardPerBlock_lte: BigDecimal
  rewardPerBlock_not: BigDecimal
  rewardPerBlock_not_in: [BigDecimal!]
}

enum LiquidityMiningAllocationPoint_orderBy {
  allocationPoint
  ammPoolToken
  id
  lendingPoolToken
  poolTokenAddedBlock
  poolTokenAddedTimestamp
  poolTokenUpdatedBlock
  poolTokenUpdatedTImestamp
  rewardPerBlock
}

"""
This entity will have only one instance (id: 0), and will hold global variables required for liquidity mining rewards calculations
"""
type LiquidityMiningGlobal {
  id: ID!
  totalAllocationPoint: BigInt!
  totalRewardPerBlock: BigInt!
}

input LiquidityMiningGlobal_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  totalAllocationPoint: BigInt
  totalAllocationPoint_gt: BigInt
  totalAllocationPoint_gte: BigInt
  totalAllocationPoint_in: [BigInt!]
  totalAllocationPoint_lt: BigInt
  totalAllocationPoint_lte: BigInt
  totalAllocationPoint_not: BigInt
  totalAllocationPoint_not_in: [BigInt!]
  totalRewardPerBlock: BigInt
  totalRewardPerBlock_gt: BigInt
  totalRewardPerBlock_gte: BigInt
  totalRewardPerBlock_in: [BigInt!]
  totalRewardPerBlock_lt: BigInt
  totalRewardPerBlock_lte: BigInt
  totalRewardPerBlock_not: BigInt
  totalRewardPerBlock_not_in: [BigInt!]
}

enum LiquidityMiningGlobal_orderBy {
  id
  totalAllocationPoint
  totalRewardPerBlock
}

"""
AMM Pool (sometimes referred to as a Converter)
"""
type LiquidityPool {
  """
  Activated with be true when this pool is activated, and will change to false is the pool is deactivated
  """
  activated: Boolean
  connectorTokens(
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]!

  """
  Divide by maxConversionFee to get percentage
  """
  conversionFee: BigInt
  createdAtBlockNumber: Int
  createdAtTimestamp: Int
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry

  """
  ID is the contract address of the Converter
  """
  id: ID!
  lastResetBlockNumber: Int
  lastResetTimestamp: Int
  maxConversionFee: BigInt
  owner: String
  poolTokens(
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolToken_filter
  ): [PoolToken!]
  smartToken: SmartToken

  """
  The reserve assets of this AMM Pool. The are stored here like this so that they can be accessed inside mappings when the LiquidityPool is loaded.
  """
  token0: Token

  """
  The balance for each token on this liquidity pool
  NB: For the V2 pools (USDT, DOC, BPRO), this balance is the staked balance, not the contract balance
  """
  token0Balance: BigDecimal!
  token1: Token
  token1Balance: BigDecimal!

  """
  Sovryn uses Bancor V1 and Bancor V2 pools
  """
  type: Int
  version: Int
}

"""
This entity stores the relationship between liquidity pools and underlying tokens
It also currently stores the total volumes bought and sold, but this should be moved to the LiquidityPool
"""
type LiquidityPoolToken {
  """
  ID is liquidityPool address + tokenAddress
  """
  id: ID!
  liquidityPool: LiquidityPool!

  """
  The pool token that represents this token-liquidityPool relationship
  """
  poolToken: PoolToken!
  token: Token!

  """
  Total volume of this token that has been bought or sold through this liquidity pool
  """
  totalVolume: BigDecimal!

  """
  Total volume of this token bought through this liquidity pool
  """
  volumeBought: BigDecimal!

  """
  Total volume of this token sold through this liquidity pool
  """
  volumeSold: BigDecimal!
}

input LiquidityPoolToken_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPool: String
  liquidityPool_contains: String
  liquidityPool_ends_with: String
  liquidityPool_gt: String
  liquidityPool_gte: String
  liquidityPool_in: [String!]
  liquidityPool_lt: String
  liquidityPool_lte: String
  liquidityPool_not: String
  liquidityPool_not_contains: String
  liquidityPool_not_ends_with: String
  liquidityPool_not_in: [String!]
  liquidityPool_not_starts_with: String
  liquidityPool_starts_with: String
  poolToken: String
  poolToken_contains: String
  poolToken_ends_with: String
  poolToken_gt: String
  poolToken_gte: String
  poolToken_in: [String!]
  poolToken_lt: String
  poolToken_lte: String
  poolToken_not: String
  poolToken_not_contains: String
  poolToken_not_ends_with: String
  poolToken_not_in: [String!]
  poolToken_not_starts_with: String
  poolToken_starts_with: String
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
  totalVolume: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_lt: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_not_in: [BigDecimal!]
  volumeBought: BigDecimal
  volumeBought_gt: BigDecimal
  volumeBought_gte: BigDecimal
  volumeBought_in: [BigDecimal!]
  volumeBought_lt: BigDecimal
  volumeBought_lte: BigDecimal
  volumeBought_not: BigDecimal
  volumeBought_not_in: [BigDecimal!]
  volumeSold: BigDecimal
  volumeSold_gt: BigDecimal
  volumeSold_gte: BigDecimal
  volumeSold_in: [BigDecimal!]
  volumeSold_lt: BigDecimal
  volumeSold_lte: BigDecimal
  volumeSold_not: BigDecimal
  volumeSold_not_in: [BigDecimal!]
}

enum LiquidityPoolToken_orderBy {
  id
  liquidityPool
  poolToken
  token
  totalVolume
  volumeBought
  volumeSold
}

input LiquidityPool_filter {
  activated: Boolean
  activated_in: [Boolean!]
  activated_not: Boolean
  activated_not_in: [Boolean!]
  conversionFee: BigInt
  conversionFee_gt: BigInt
  conversionFee_gte: BigInt
  conversionFee_in: [BigInt!]
  conversionFee_lt: BigInt
  conversionFee_lte: BigInt
  conversionFee_not: BigInt
  conversionFee_not_in: [BigInt!]
  createdAtBlockNumber: Int
  createdAtBlockNumber_gt: Int
  createdAtBlockNumber_gte: Int
  createdAtBlockNumber_in: [Int!]
  createdAtBlockNumber_lt: Int
  createdAtBlockNumber_lte: Int
  createdAtBlockNumber_not: Int
  createdAtBlockNumber_not_in: [Int!]
  createdAtTimestamp: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_lt: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_not_in: [Int!]
  createdAtTransaction: String
  createdAtTransaction_contains: String
  createdAtTransaction_ends_with: String
  createdAtTransaction_gt: String
  createdAtTransaction_gte: String
  createdAtTransaction_in: [String!]
  createdAtTransaction_lt: String
  createdAtTransaction_lte: String
  createdAtTransaction_not: String
  createdAtTransaction_not_contains: String
  createdAtTransaction_not_ends_with: String
  createdAtTransaction_not_in: [String!]
  createdAtTransaction_not_starts_with: String
  createdAtTransaction_starts_with: String
  currentConverterRegistry: String
  currentConverterRegistry_contains: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_lt: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_not: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_not_ends_with: String
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastResetBlockNumber: Int
  lastResetBlockNumber_gt: Int
  lastResetBlockNumber_gte: Int
  lastResetBlockNumber_in: [Int!]
  lastResetBlockNumber_lt: Int
  lastResetBlockNumber_lte: Int
  lastResetBlockNumber_not: Int
  lastResetBlockNumber_not_in: [Int!]
  lastResetTimestamp: Int
  lastResetTimestamp_gt: Int
  lastResetTimestamp_gte: Int
  lastResetTimestamp_in: [Int!]
  lastResetTimestamp_lt: Int
  lastResetTimestamp_lte: Int
  lastResetTimestamp_not: Int
  lastResetTimestamp_not_in: [Int!]
  maxConversionFee: BigInt
  maxConversionFee_gt: BigInt
  maxConversionFee_gte: BigInt
  maxConversionFee_in: [BigInt!]
  maxConversionFee_lt: BigInt
  maxConversionFee_lte: BigInt
  maxConversionFee_not: BigInt
  maxConversionFee_not_in: [BigInt!]
  owner: String
  owner_contains: String
  owner_ends_with: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_ends_with: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_starts_with: String
  smartToken: String
  smartToken_contains: String
  smartToken_ends_with: String
  smartToken_gt: String
  smartToken_gte: String
  smartToken_in: [String!]
  smartToken_lt: String
  smartToken_lte: String
  smartToken_not: String
  smartToken_not_contains: String
  smartToken_not_ends_with: String
  smartToken_not_in: [String!]
  smartToken_not_starts_with: String
  smartToken_starts_with: String
  token0: String
  token0Balance: BigDecimal
  token0Balance_gt: BigDecimal
  token0Balance_gte: BigDecimal
  token0Balance_in: [BigDecimal!]
  token0Balance_lt: BigDecimal
  token0Balance_lte: BigDecimal
  token0Balance_not: BigDecimal
  token0Balance_not_in: [BigDecimal!]
  token0_contains: String
  token0_ends_with: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_ends_with: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_starts_with: String
  token1: String
  token1Balance: BigDecimal
  token1Balance_gt: BigDecimal
  token1Balance_gte: BigDecimal
  token1Balance_in: [BigDecimal!]
  token1Balance_lt: BigDecimal
  token1Balance_lte: BigDecimal
  token1Balance_not: BigDecimal
  token1Balance_not_in: [BigDecimal!]
  token1_contains: String
  token1_ends_with: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_ends_with: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_starts_with: String
  type: Int
  type_gt: Int
  type_gte: Int
  type_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_not: Int
  type_not_in: [Int!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum LiquidityPool_orderBy {
  activated
  connectorTokens
  conversionFee
  createdAtBlockNumber
  createdAtTimestamp
  createdAtTransaction
  currentConverterRegistry
  id
  lastResetBlockNumber
  lastResetTimestamp
  maxConversionFee
  owner
  poolTokens
  smartToken
  token0
  token0Balance
  token1
  token1Balance
  type
  version
}

"""
A Loan can be initialized by either a Margin Trade event or a Borrow event
"""
type Loan {
  """
  Average price per token from all loan open events
  Updated on Trade and Borrow events
  This is mainly used as internal storage to calculate PnL
  """
  averageBuyPrice: BigDecimal!

  """
  Average price per token from all loan close events
  Updated on CloseWithSwap, CloseWithDeposit and Liquidate events
  This is mainly used as internal storage to calculate PnL
  """
  averageSellPrice: BigDecimal!

  """
  Borrow transactions associated with this loan
  """
  borrow(
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Borrow_filter
  ): [Borrow!]

  """
  The amount borrowed in loan tokens
  """
  borrowedAmount: BigDecimal!

  """
  CloseWithDeposit events associated with this loan. Emitted when a user partially or fully closes a borrow loan.
  """
  closeWithDeposits(
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: CloseWithDeposit_filter
  ): [CloseWithDeposit!]

  """
  CloseWithSwap events associated with this loan. Emitted when a user partially or fully closes a margin trade.
  """
  closeWithSwaps(
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: CloseWithSwap_filter
  ): [CloseWithSwap!]

  """
  The token provided as collateral
  """
  collateralToken: Token!

  """
  DepositCollateral events associated with this loan, where a user has topped up collateral
  """
  depositCollateral(
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: DepositCollateral_filter
  ): [DepositCollateral!]

  """
  Unix timestamp at end of loan (null if loan is still open)
  """
  endTimestamp: Int
  id: ID!

  """
  If a Liquidate, CloseWithSwap, Rollover or CloseWithDeposit event occurs with 0 margin or 0 leverage, this property changes to false
  """
  isOpen: Boolean!

  """
  Any liquidations that have happened on this loan
  """
  liquidates(
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Liquidate_filter
  ): [Liquidate!]

  """
  The token the loan was taken out in
  """
  loanToken: Token!

  """
  The largest amount borrowed in the lifetime of this loan
  """
  maxBorrowedAmount: BigDecimal!

  """
  The maximum this position size was - mainly for debugging purposes
  """
  maximumPositionSize: BigDecimal!

  """
  Next date that the loan will be rolled over, interest and trading fee paid, and rollover reward paid
  It is possible for the next rollover to be in the past if the loan has not yet been rolled over by the Sovryn node
  """
  nextRollover: Int

  """
  Total of collateral (user collateral in a Borrow, and user collateral + borrowed amount in a Trade) in collateral tokens
  """
  positionSize: BigDecimal!

  """
  Realized profit and loss. This is updated on every loan closing event - partially or fully closing a loan, or a liquidation.
  Currently, this does not take into account fees paid
  The realized PnL is quoted in the collateral currency
  """
  realizedPnL: BigDecimal!

  """
  Percentage profit or loss relative to collateral
  """
  realizedPnLPercent: BigDecimal!

  """
  Rollover events associated with this loan.
  Rollovers are loan maintenance transactions where the next interest payment and fee is paid
  """
  rollovers(
    first: Int = 100
    orderBy: Rollover_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Rollover_filter
  ): [Rollover!]

  """
  The amount borrowed when the loan was opened
  """
  startBorrowedAmount: BigDecimal!

  """
  Initial size of the position
  """
  startPositionSize: BigDecimal!

  """
  The start rate of the loan in loan tokens (eg if it is a long USD/BTC margin trade, this is the BTC price in USD)
  """
  startRate: BigDecimal!

  """
  Unix timestamp at start of loan
  """
  startTimestamp: Int!

  """
  Sum of position volume from Trade, Borrow and DepositCollateral events in this loan, in collateral token
  """
  totalBought: BigDecimal!

  """
  Sum of position change volume from CloseWithSwap, CloseWithDeposit and Liquidate events in this loan, in collateral token
  """
  totalSold: BigDecimal!

  """
  Trade (margin trade) transactions associated with this loan
  """
  trade(
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Trade_filter
  ): [Trade!]

  """
  LoanType is either Trade (for Margin Trades) or Borrow (for Borrows)
  """
  type: LoanType!

  """
  The user who took out the loan
  """
  user: User!
}

enum LoanType {
  """
  Borrow is a loan originating from a user simply borrowing funds
  """
  Borrow

  """
  Trade is a loan originating from a margin trade
  """
  Trade
}

input Loan_filter {
  averageBuyPrice: BigDecimal
  averageBuyPrice_gt: BigDecimal
  averageBuyPrice_gte: BigDecimal
  averageBuyPrice_in: [BigDecimal!]
  averageBuyPrice_lt: BigDecimal
  averageBuyPrice_lte: BigDecimal
  averageBuyPrice_not: BigDecimal
  averageBuyPrice_not_in: [BigDecimal!]
  averageSellPrice: BigDecimal
  averageSellPrice_gt: BigDecimal
  averageSellPrice_gte: BigDecimal
  averageSellPrice_in: [BigDecimal!]
  averageSellPrice_lt: BigDecimal
  averageSellPrice_lte: BigDecimal
  averageSellPrice_not: BigDecimal
  averageSellPrice_not_in: [BigDecimal!]
  borrowedAmount: BigDecimal
  borrowedAmount_gt: BigDecimal
  borrowedAmount_gte: BigDecimal
  borrowedAmount_in: [BigDecimal!]
  borrowedAmount_lt: BigDecimal
  borrowedAmount_lte: BigDecimal
  borrowedAmount_not: BigDecimal
  borrowedAmount_not_in: [BigDecimal!]
  collateralToken: String
  collateralToken_contains: String
  collateralToken_ends_with: String
  collateralToken_gt: String
  collateralToken_gte: String
  collateralToken_in: [String!]
  collateralToken_lt: String
  collateralToken_lte: String
  collateralToken_not: String
  collateralToken_not_contains: String
  collateralToken_not_ends_with: String
  collateralToken_not_in: [String!]
  collateralToken_not_starts_with: String
  collateralToken_starts_with: String
  endTimestamp: Int
  endTimestamp_gt: Int
  endTimestamp_gte: Int
  endTimestamp_in: [Int!]
  endTimestamp_lt: Int
  endTimestamp_lte: Int
  endTimestamp_not: Int
  endTimestamp_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isOpen: Boolean
  isOpen_in: [Boolean!]
  isOpen_not: Boolean
  isOpen_not_in: [Boolean!]
  loanToken: String
  loanToken_contains: String
  loanToken_ends_with: String
  loanToken_gt: String
  loanToken_gte: String
  loanToken_in: [String!]
  loanToken_lt: String
  loanToken_lte: String
  loanToken_not: String
  loanToken_not_contains: String
  loanToken_not_ends_with: String
  loanToken_not_in: [String!]
  loanToken_not_starts_with: String
  loanToken_starts_with: String
  maxBorrowedAmount: BigDecimal
  maxBorrowedAmount_gt: BigDecimal
  maxBorrowedAmount_gte: BigDecimal
  maxBorrowedAmount_in: [BigDecimal!]
  maxBorrowedAmount_lt: BigDecimal
  maxBorrowedAmount_lte: BigDecimal
  maxBorrowedAmount_not: BigDecimal
  maxBorrowedAmount_not_in: [BigDecimal!]
  maximumPositionSize: BigDecimal
  maximumPositionSize_gt: BigDecimal
  maximumPositionSize_gte: BigDecimal
  maximumPositionSize_in: [BigDecimal!]
  maximumPositionSize_lt: BigDecimal
  maximumPositionSize_lte: BigDecimal
  maximumPositionSize_not: BigDecimal
  maximumPositionSize_not_in: [BigDecimal!]
  nextRollover: Int
  nextRollover_gt: Int
  nextRollover_gte: Int
  nextRollover_in: [Int!]
  nextRollover_lt: Int
  nextRollover_lte: Int
  nextRollover_not: Int
  nextRollover_not_in: [Int!]
  positionSize: BigDecimal
  positionSize_gt: BigDecimal
  positionSize_gte: BigDecimal
  positionSize_in: [BigDecimal!]
  positionSize_lt: BigDecimal
  positionSize_lte: BigDecimal
  positionSize_not: BigDecimal
  positionSize_not_in: [BigDecimal!]
  realizedPnL: BigDecimal
  realizedPnLPercent: BigDecimal
  realizedPnLPercent_gt: BigDecimal
  realizedPnLPercent_gte: BigDecimal
  realizedPnLPercent_in: [BigDecimal!]
  realizedPnLPercent_lt: BigDecimal
  realizedPnLPercent_lte: BigDecimal
  realizedPnLPercent_not: BigDecimal
  realizedPnLPercent_not_in: [BigDecimal!]
  realizedPnL_gt: BigDecimal
  realizedPnL_gte: BigDecimal
  realizedPnL_in: [BigDecimal!]
  realizedPnL_lt: BigDecimal
  realizedPnL_lte: BigDecimal
  realizedPnL_not: BigDecimal
  realizedPnL_not_in: [BigDecimal!]
  startBorrowedAmount: BigDecimal
  startBorrowedAmount_gt: BigDecimal
  startBorrowedAmount_gte: BigDecimal
  startBorrowedAmount_in: [BigDecimal!]
  startBorrowedAmount_lt: BigDecimal
  startBorrowedAmount_lte: BigDecimal
  startBorrowedAmount_not: BigDecimal
  startBorrowedAmount_not_in: [BigDecimal!]
  startPositionSize: BigDecimal
  startPositionSize_gt: BigDecimal
  startPositionSize_gte: BigDecimal
  startPositionSize_in: [BigDecimal!]
  startPositionSize_lt: BigDecimal
  startPositionSize_lte: BigDecimal
  startPositionSize_not: BigDecimal
  startPositionSize_not_in: [BigDecimal!]
  startRate: BigDecimal
  startRate_gt: BigDecimal
  startRate_gte: BigDecimal
  startRate_in: [BigDecimal!]
  startRate_lt: BigDecimal
  startRate_lte: BigDecimal
  startRate_not: BigDecimal
  startRate_not_in: [BigDecimal!]
  startTimestamp: Int
  startTimestamp_gt: Int
  startTimestamp_gte: Int
  startTimestamp_in: [Int!]
  startTimestamp_lt: Int
  startTimestamp_lte: Int
  startTimestamp_not: Int
  startTimestamp_not_in: [Int!]
  totalBought: BigDecimal
  totalBought_gt: BigDecimal
  totalBought_gte: BigDecimal
  totalBought_in: [BigDecimal!]
  totalBought_lt: BigDecimal
  totalBought_lte: BigDecimal
  totalBought_not: BigDecimal
  totalBought_not_in: [BigDecimal!]
  totalSold: BigDecimal
  totalSold_gt: BigDecimal
  totalSold_gte: BigDecimal
  totalSold_in: [BigDecimal!]
  totalSold_lt: BigDecimal
  totalSold_lte: BigDecimal
  totalSold_not: BigDecimal
  totalSold_not_in: [BigDecimal!]
  type: LoanType
  type_in: [LoanType!]
  type_not: LoanType
  type_not_in: [LoanType!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum Loan_orderBy {
  averageBuyPrice
  averageSellPrice
  borrow
  borrowedAmount
  closeWithDeposits
  closeWithSwaps
  collateralToken
  depositCollateral
  endTimestamp
  id
  isOpen
  liquidates
  loanToken
  maxBorrowedAmount
  maximumPositionSize
  nextRollover
  positionSize
  realizedPnL
  realizedPnLPercent
  rollovers
  startBorrowedAmount
  startPositionSize
  startRate
  startTimestamp
  totalBought
  totalSold
  trade
  type
  user
}

type MarginOrderCanceled {
  emittedBy: Bytes!
  hash: Bytes!
  id: ID!
  timestamp: Int!
  trader: Bytes!
  transaction: Transaction!
}

input MarginOrderCanceled_filter {
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  trader: Bytes
  trader_contains: Bytes
  trader_in: [Bytes!]
  trader_not: Bytes
  trader_not_contains: Bytes
  trader_not_in: [Bytes!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum MarginOrderCanceled_orderBy {
  emittedBy
  hash
  id
  timestamp
  trader
  transaction
}

type MarginOrderFilled {
  collateral: BigDecimal!
  collateralTokenAddress: Bytes!
  collateralTokenSent: BigDecimal!
  emittedBy: Bytes!
  filledPrice: BigDecimal!
  hash: Bytes!
  id: ID!
  leverageAmount: BigDecimal!
  loanTokenAddress: Bytes!
  loanTokenSent: BigDecimal!
  principal: BigDecimal!
  timestamp: Int!
  trader: User!
  transaction: Transaction!
}

input MarginOrderFilled_filter {
  collateral: BigDecimal
  collateralTokenAddress: Bytes
  collateralTokenAddress_contains: Bytes
  collateralTokenAddress_in: [Bytes!]
  collateralTokenAddress_not: Bytes
  collateralTokenAddress_not_contains: Bytes
  collateralTokenAddress_not_in: [Bytes!]
  collateralTokenSent: BigDecimal
  collateralTokenSent_gt: BigDecimal
  collateralTokenSent_gte: BigDecimal
  collateralTokenSent_in: [BigDecimal!]
  collateralTokenSent_lt: BigDecimal
  collateralTokenSent_lte: BigDecimal
  collateralTokenSent_not: BigDecimal
  collateralTokenSent_not_in: [BigDecimal!]
  collateral_gt: BigDecimal
  collateral_gte: BigDecimal
  collateral_in: [BigDecimal!]
  collateral_lt: BigDecimal
  collateral_lte: BigDecimal
  collateral_not: BigDecimal
  collateral_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  filledPrice: BigDecimal
  filledPrice_gt: BigDecimal
  filledPrice_gte: BigDecimal
  filledPrice_in: [BigDecimal!]
  filledPrice_lt: BigDecimal
  filledPrice_lte: BigDecimal
  filledPrice_not: BigDecimal
  filledPrice_not_in: [BigDecimal!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  leverageAmount: BigDecimal
  leverageAmount_gt: BigDecimal
  leverageAmount_gte: BigDecimal
  leverageAmount_in: [BigDecimal!]
  leverageAmount_lt: BigDecimal
  leverageAmount_lte: BigDecimal
  leverageAmount_not: BigDecimal
  leverageAmount_not_in: [BigDecimal!]
  loanTokenAddress: Bytes
  loanTokenAddress_contains: Bytes
  loanTokenAddress_in: [Bytes!]
  loanTokenAddress_not: Bytes
  loanTokenAddress_not_contains: Bytes
  loanTokenAddress_not_in: [Bytes!]
  loanTokenSent: BigDecimal
  loanTokenSent_gt: BigDecimal
  loanTokenSent_gte: BigDecimal
  loanTokenSent_in: [BigDecimal!]
  loanTokenSent_lt: BigDecimal
  loanTokenSent_lte: BigDecimal
  loanTokenSent_not: BigDecimal
  loanTokenSent_not_in: [BigDecimal!]
  principal: BigDecimal
  principal_gt: BigDecimal
  principal_gte: BigDecimal
  principal_in: [BigDecimal!]
  principal_lt: BigDecimal
  principal_lte: BigDecimal
  principal_not: BigDecimal
  principal_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  trader: String
  trader_contains: String
  trader_ends_with: String
  trader_gt: String
  trader_gte: String
  trader_in: [String!]
  trader_lt: String
  trader_lte: String
  trader_not: String
  trader_not_contains: String
  trader_not_ends_with: String
  trader_not_in: [String!]
  trader_not_starts_with: String
  trader_starts_with: String
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum MarginOrderFilled_orderBy {
  collateral
  collateralTokenAddress
  collateralTokenSent
  emittedBy
  filledPrice
  hash
  id
  leverageAmount
  loanTokenAddress
  loanTokenSent
  principal
  timestamp
  trader
  transaction
}

enum Network {
  Mainnet
  Testnet
}

type OrderCanceled {
  emittedBy: Bytes!
  hash: Bytes!
  id: ID!
  maker: Bytes!
  timestamp: Int!
  transaction: Transaction!
}

input OrderCanceled_filter {
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  maker: Bytes
  maker_contains: Bytes
  maker_in: [Bytes!]
  maker_not: Bytes
  maker_not_contains: Bytes
  maker_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum OrderCanceled_orderBy {
  emittedBy
  hash
  id
  maker
  timestamp
  transaction
}

type OrderCreated {
  emittedBy: Bytes!
  hash: Bytes!
  id: ID!
  limitPrice: BigInt!
  network: Network!

  """
  The amountIn is a BigInt (usually 1e18), not a human-readable decimal.
  This is because both orderbooks are on testnet, and so this subgraph cannot access the correct number of token decimals for mainnet tokens
  """
  order_amountIn: BigInt!

  """
  The amountIn is a BigInt (usually 1e18), not a human-readable decimal. (See above for explanation)
  """
  order_amountOutMin: BigInt!

  """
  Timestamp when the order was created
  """
  order_created: BigInt!

  """
  Timestamp when the order must be filled by
  """
  order_deadline: BigInt!
  order_fromToken: Bytes!
  order_maker: User!
  order_recipient: Bytes!
  order_toToken: Bytes!
  timestamp: Int!
  transaction: Transaction!
}

input OrderCreated_filter {
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  limitPrice: BigInt
  limitPrice_gt: BigInt
  limitPrice_gte: BigInt
  limitPrice_in: [BigInt!]
  limitPrice_lt: BigInt
  limitPrice_lte: BigInt
  limitPrice_not: BigInt
  limitPrice_not_in: [BigInt!]
  network: Network
  network_in: [Network!]
  network_not: Network
  network_not_in: [Network!]
  order_amountIn: BigInt
  order_amountIn_gt: BigInt
  order_amountIn_gte: BigInt
  order_amountIn_in: [BigInt!]
  order_amountIn_lt: BigInt
  order_amountIn_lte: BigInt
  order_amountIn_not: BigInt
  order_amountIn_not_in: [BigInt!]
  order_amountOutMin: BigInt
  order_amountOutMin_gt: BigInt
  order_amountOutMin_gte: BigInt
  order_amountOutMin_in: [BigInt!]
  order_amountOutMin_lt: BigInt
  order_amountOutMin_lte: BigInt
  order_amountOutMin_not: BigInt
  order_amountOutMin_not_in: [BigInt!]
  order_created: BigInt
  order_created_gt: BigInt
  order_created_gte: BigInt
  order_created_in: [BigInt!]
  order_created_lt: BigInt
  order_created_lte: BigInt
  order_created_not: BigInt
  order_created_not_in: [BigInt!]
  order_deadline: BigInt
  order_deadline_gt: BigInt
  order_deadline_gte: BigInt
  order_deadline_in: [BigInt!]
  order_deadline_lt: BigInt
  order_deadline_lte: BigInt
  order_deadline_not: BigInt
  order_deadline_not_in: [BigInt!]
  order_fromToken: Bytes
  order_fromToken_contains: Bytes
  order_fromToken_in: [Bytes!]
  order_fromToken_not: Bytes
  order_fromToken_not_contains: Bytes
  order_fromToken_not_in: [Bytes!]
  order_maker: String
  order_maker_contains: String
  order_maker_ends_with: String
  order_maker_gt: String
  order_maker_gte: String
  order_maker_in: [String!]
  order_maker_lt: String
  order_maker_lte: String
  order_maker_not: String
  order_maker_not_contains: String
  order_maker_not_ends_with: String
  order_maker_not_in: [String!]
  order_maker_not_starts_with: String
  order_maker_starts_with: String
  order_recipient: Bytes
  order_recipient_contains: Bytes
  order_recipient_in: [Bytes!]
  order_recipient_not: Bytes
  order_recipient_not_contains: Bytes
  order_recipient_not_in: [Bytes!]
  order_toToken: Bytes
  order_toToken_contains: Bytes
  order_toToken_in: [Bytes!]
  order_toToken_not: Bytes
  order_toToken_not_contains: Bytes
  order_toToken_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum OrderCreated_orderBy {
  emittedBy
  hash
  id
  limitPrice
  network
  order_amountIn
  order_amountOutMin
  order_created
  order_deadline
  order_fromToken
  order_maker
  order_recipient
  order_toToken
  timestamp
  transaction
}

enum OrderDirection {
  asc
  desc
}

type OrderFilled {
  amountIn: BigDecimal!
  amountOut: BigDecimal!
  emittedBy: Bytes!
  filledPrice: BigDecimal!
  hash: Bytes!
  id: ID!
  maker: User!
  path: [String!]!
  timestamp: Int!
  transaction: Transaction!
}

input OrderFilled_filter {
  amountIn: BigDecimal
  amountIn_gt: BigDecimal
  amountIn_gte: BigDecimal
  amountIn_in: [BigDecimal!]
  amountIn_lt: BigDecimal
  amountIn_lte: BigDecimal
  amountIn_not: BigDecimal
  amountIn_not_in: [BigDecimal!]
  amountOut: BigDecimal
  amountOut_gt: BigDecimal
  amountOut_gte: BigDecimal
  amountOut_in: [BigDecimal!]
  amountOut_lt: BigDecimal
  amountOut_lte: BigDecimal
  amountOut_not: BigDecimal
  amountOut_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  filledPrice: BigDecimal
  filledPrice_gt: BigDecimal
  filledPrice_gte: BigDecimal
  filledPrice_in: [BigDecimal!]
  filledPrice_lt: BigDecimal
  filledPrice_lte: BigDecimal
  filledPrice_not: BigDecimal
  filledPrice_not_in: [BigDecimal!]
  hash: Bytes
  hash_contains: Bytes
  hash_in: [Bytes!]
  hash_not: Bytes
  hash_not_contains: Bytes
  hash_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  maker: String
  maker_contains: String
  maker_ends_with: String
  maker_gt: String
  maker_gte: String
  maker_in: [String!]
  maker_lt: String
  maker_lte: String
  maker_not: String
  maker_not_contains: String
  maker_not_ends_with: String
  maker_not_in: [String!]
  maker_not_starts_with: String
  maker_starts_with: String
  path: [String!]
  path_contains: [String!]
  path_not: [String!]
  path_not_contains: [String!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum OrderFilled_orderBy {
  amountIn
  amountOut
  emittedBy
  filledPrice
  hash
  id
  maker
  path
  timestamp
  transaction
}

type OwnerUpdate {
  emittedBy: String!
  id: ID!
  newOwner: String!
  prevOwner: String!
  timestamp: BigInt!
}

input OwnerUpdate_filter {
  emittedBy: String
  emittedBy_contains: String
  emittedBy_ends_with: String
  emittedBy_gt: String
  emittedBy_gte: String
  emittedBy_in: [String!]
  emittedBy_lt: String
  emittedBy_lte: String
  emittedBy_not: String
  emittedBy_not_contains: String
  emittedBy_not_ends_with: String
  emittedBy_not_in: [String!]
  emittedBy_not_starts_with: String
  emittedBy_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  newOwner: String
  newOwner_contains: String
  newOwner_ends_with: String
  newOwner_gt: String
  newOwner_gte: String
  newOwner_in: [String!]
  newOwner_lt: String
  newOwner_lte: String
  newOwner_not: String
  newOwner_not_contains: String
  newOwner_not_ends_with: String
  newOwner_not_in: [String!]
  newOwner_not_starts_with: String
  newOwner_starts_with: String
  prevOwner: String
  prevOwner_contains: String
  prevOwner_ends_with: String
  prevOwner_gt: String
  prevOwner_gte: String
  prevOwner_in: [String!]
  prevOwner_lt: String
  prevOwner_lte: String
  prevOwner_not: String
  prevOwner_not_contains: String
  prevOwner_not_ends_with: String
  prevOwner_not_in: [String!]
  prevOwner_not_starts_with: String
  prevOwner_starts_with: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum OwnerUpdate_orderBy {
  emittedBy
  id
  newOwner
  prevOwner
  timestamp
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows and when a loan is rolled over
"""
type PayBorrowingFee {
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  loanId: Loan!
  payer: Bytes!
  timestamp: Int!
  token: Bytes!
  transaction: Transaction!
}

input PayBorrowingFee_filter {
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  payer: Bytes
  payer_contains: Bytes
  payer_in: [Bytes!]
  payer_not: Bytes
  payer_not_contains: Bytes
  payer_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum PayBorrowingFee_orderBy {
  amount
  emittedBy
  id
  loanId
  payer
  timestamp
  token
  transaction
}

"""
Granular event data for the Loan entity. Emitted when a user Lends or Unlends and when a loan is rolled over
"""
type PayLendingFee {
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  payer: Bytes!
  timestamp: Int!
  token: Bytes!
  transaction: Transaction!
}

input PayLendingFee_filter {
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  payer: Bytes
  payer_contains: Bytes
  payer_in: [Bytes!]
  payer_not: Bytes
  payer_not_contains: Bytes
  payer_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum PayLendingFee_orderBy {
  amount
  emittedBy
  id
  payer
  timestamp
  token
  transaction
}

"""
Granular event data for the Loan entity. Emitted when a user Margin Trades and when a loan is rolled over
"""
type PayTradingFee {
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  loanId: Loan!
  payer: Bytes!
  timestamp: Int!
  token: Bytes!
  transaction: Transaction!
}

input PayTradingFee_filter {
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  payer: Bytes
  payer_contains: Bytes
  payer_in: [Bytes!]
  payer_not: Bytes
  payer_not_contains: Bytes
  payer_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum PayTradingFee_orderBy {
  amount
  emittedBy
  id
  loanId
  payer
  timestamp
  token
  transaction
}

"""
For the V1 pools, the pool token and smart token are the same. However, for V2 pools, there is one pool token per asset and only one smart token for the pool.
"""
type PoolToken {
  decimals: Int
  id: ID!
  liquidityPool: LiquidityPool!
  name: String
  symbol: String

  """
  For V1 pools, there will be 2 underlying assets, however for V1 pools there will be just one
  """
  underlyingAssets(
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Token_filter
  ): [Token!]!
}

input PoolToken_filter {
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPool: String
  liquidityPool_contains: String
  liquidityPool_ends_with: String
  liquidityPool_gt: String
  liquidityPool_gte: String
  liquidityPool_in: [String!]
  liquidityPool_lt: String
  liquidityPool_lte: String
  liquidityPool_not: String
  liquidityPool_not_contains: String
  liquidityPool_not_ends_with: String
  liquidityPool_not_in: [String!]
  liquidityPool_not_starts_with: String
  liquidityPool_starts_with: String
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  symbol: String
  symbol_contains: String
  symbol_ends_with: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_ends_with: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_starts_with: String
  underlyingAssets: [String!]
  underlyingAssets_contains: [String!]
  underlyingAssets_not: [String!]
  underlyingAssets_not_contains: [String!]
}

enum PoolToken_orderBy {
  decimals
  id
  liquidityPool
  name
  symbol
  underlyingAssets
}

"""
A Proposal is created each time a SIP (Sovryn Improvement Proposal) is proposed
The Proposal is created, voted on, and then executed if it passes
To see if a Proposal has been executed, see if the executed property is null or if it has a transaction
"""
type Proposal {
  """
  If the proposal was canceled, the transaction that canceled it (otherwise null)
  """
  canceled: Transaction

  """
  Number of unique wallets that voted against this proposal
  """
  countVotersAgainst: Int!

  """
  Number of unique wallets that voted for this proposal
  """
  countVotersFor: Int!

  """
  Transaction that created the proposal
  """
  created: Transaction!

  """
  Brief description of what this SIP is for, sometimes with a link to the github repo and README for this proposal
  """
  description: String!

  """
  The contract that emitted this event
  """
  emittedBy: Bytes!

  """
  Block when voting ends
  """
  endBlock: Int!

  """
  If the proposal was executed, the transaction that executed it (otherwise null)
  """
  executed: Transaction

  """
  ID is the address of the governor contract that was used to create the proposal, + the id of the proposal
  """
  id: ID!
  proposalId: Int!

  """
  Address of the user who created this proposal
  """
  proposer: Bytes!

  """
  If the proposal was queued, the transaction that queued it (otherwise null)
  """
  queued: Transaction

  """
  Function signatures in the targeted contract that would be affected by this proposal passing
  """
  signatures: [String!]!

  """
  Block when voting starts
  """
  startBlock: Int!

  """
  Contract or contract that this proposal targets
  """
  targets: [String!]!

  """
  Timestamp when this proposal was created. This is also available in the created transaction, but is included here so it is possible to order by timestamp
  """
  timestamp: Int!
  values: [BigInt!]!

  """
  Individual vote transactions
  """
  votes(
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VoteCast_filter
  ): [VoteCast!]

  """
  Number of votes against the proposal (weighted vote, not number of voters)
  """
  votesAgainst: BigInt!

  """
  Number of votes for the proposal (weighted vote, not number of voters)
  """
  votesFor: BigInt!
}

input Proposal_filter {
  canceled: String
  canceled_contains: String
  canceled_ends_with: String
  canceled_gt: String
  canceled_gte: String
  canceled_in: [String!]
  canceled_lt: String
  canceled_lte: String
  canceled_not: String
  canceled_not_contains: String
  canceled_not_ends_with: String
  canceled_not_in: [String!]
  canceled_not_starts_with: String
  canceled_starts_with: String
  countVotersAgainst: Int
  countVotersAgainst_gt: Int
  countVotersAgainst_gte: Int
  countVotersAgainst_in: [Int!]
  countVotersAgainst_lt: Int
  countVotersAgainst_lte: Int
  countVotersAgainst_not: Int
  countVotersAgainst_not_in: [Int!]
  countVotersFor: Int
  countVotersFor_gt: Int
  countVotersFor_gte: Int
  countVotersFor_in: [Int!]
  countVotersFor_lt: Int
  countVotersFor_lte: Int
  countVotersFor_not: Int
  countVotersFor_not_in: [Int!]
  created: String
  created_contains: String
  created_ends_with: String
  created_gt: String
  created_gte: String
  created_in: [String!]
  created_lt: String
  created_lte: String
  created_not: String
  created_not_contains: String
  created_not_ends_with: String
  created_not_in: [String!]
  created_not_starts_with: String
  created_starts_with: String
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  endBlock: Int
  endBlock_gt: Int
  endBlock_gte: Int
  endBlock_in: [Int!]
  endBlock_lt: Int
  endBlock_lte: Int
  endBlock_not: Int
  endBlock_not_in: [Int!]
  executed: String
  executed_contains: String
  executed_ends_with: String
  executed_gt: String
  executed_gte: String
  executed_in: [String!]
  executed_lt: String
  executed_lte: String
  executed_not: String
  executed_not_contains: String
  executed_not_ends_with: String
  executed_not_in: [String!]
  executed_not_starts_with: String
  executed_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  proposalId: Int
  proposalId_gt: Int
  proposalId_gte: Int
  proposalId_in: [Int!]
  proposalId_lt: Int
  proposalId_lte: Int
  proposalId_not: Int
  proposalId_not_in: [Int!]
  proposer: Bytes
  proposer_contains: Bytes
  proposer_in: [Bytes!]
  proposer_not: Bytes
  proposer_not_contains: Bytes
  proposer_not_in: [Bytes!]
  queued: String
  queued_contains: String
  queued_ends_with: String
  queued_gt: String
  queued_gte: String
  queued_in: [String!]
  queued_lt: String
  queued_lte: String
  queued_not: String
  queued_not_contains: String
  queued_not_ends_with: String
  queued_not_in: [String!]
  queued_not_starts_with: String
  queued_starts_with: String
  signatures: [String!]
  signatures_contains: [String!]
  signatures_not: [String!]
  signatures_not_contains: [String!]
  startBlock: Int
  startBlock_gt: Int
  startBlock_gte: Int
  startBlock_in: [Int!]
  startBlock_lt: Int
  startBlock_lte: Int
  startBlock_not: Int
  startBlock_not_in: [Int!]
  targets: [String!]
  targets_contains: [String!]
  targets_not: [String!]
  targets_not_contains: [String!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  values: [BigInt!]
  values_contains: [BigInt!]
  values_not: [BigInt!]
  values_not_contains: [BigInt!]
  votesAgainst: BigInt
  votesAgainst_gt: BigInt
  votesAgainst_gte: BigInt
  votesAgainst_in: [BigInt!]
  votesAgainst_lt: BigInt
  votesAgainst_lte: BigInt
  votesAgainst_not: BigInt
  votesAgainst_not_in: [BigInt!]
  votesFor: BigInt
  votesFor_gt: BigInt
  votesFor_gte: BigInt
  votesFor_in: [BigInt!]
  votesFor_lt: BigInt
  votesFor_lte: BigInt
  votesFor_not: BigInt
  votesFor_not_in: [BigInt!]
}

enum Proposal_orderBy {
  canceled
  countVotersAgainst
  countVotersFor
  created
  description
  emittedBy
  endBlock
  executed
  id
  proposalId
  proposer
  queued
  signatures
  startBlock
  targets
  timestamp
  values
  votes
  votesAgainst
  votesFor
}

"""
This entity will have only one instance and will be used to store protocol-wide data like list of tokens and number or users.
The ID of this one entity is "0"
"""
type ProtocolStats {
  """
  Current price of BTC in usdStablecoin
  """
  btcUsdPrice: BigDecimal!

  """
  This is SOV staked by vesting contracts. It in incremented when the contracts stake the tokens, and decremented when users claim their unlocked tokens
  """
  currentStakedByVestingSov: BigDecimal!

  """
  This is SOV staked by users (not vesting contracts). It is incremented when users stake tokens, and decremented when users withdraw tokens from the staking contract
  """
  currentVoluntarilyStakedSov: BigDecimal!

  """
  Only one entity should be created, with ID "0"
  """
  id: ID!

  """
  An array of all tokens in the protocol
  """
  tokens(
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Token_filter
  ): [Token!]!

  """
  Total volume of fees earned by liquidity providers to AMM pools (in usd)
  """
  totalAmmLpFeesUsd: BigDecimal!

  """
  Total volume of fees earned by SOV stakers from AMM conversion events (in usd). These fees began after the fee-sharing SIP was executed.
  """
  totalAmmStakerFeesUsd: BigDecimal!

  """
  Total volume that has passed through every AMM pool of the Sovryn protocol (in usd)
  """
  totalAmmVolumeUsd: BigDecimal!

  """
  Total of collateral property in Trade event (in usd). This may be changed to borrowed amount volume, but collateral keeps it consistent with margin trading
  """
  totalBorrowVolumeUsd: BigDecimal!

  """
  Total fees from Borrowing earned by SOV stakers (in usd)
  """
  totalBorrowingFeesUsd: BigDecimal!

  """
  Total volume of Borrows closed (in usd)
  """
  totalCloseWithDepositVolumeUsd: BigDecimal!

  """
  Total position volume closed for Margin Trades (in usd)
  """
  totalCloseWithSwapVolumeUsd: BigDecimal!

  """
  Total additional collateral deposited for Margin Trades and Borrows (in usd)
  """
  totalDepositCollateralVolumeUsd: BigDecimal!

  """
  Total volume supplied to Lending Pools over all time (in usd)
  """
  totalLendVolumeUsd: BigDecimal!

  """
  Total fees from Lending and Unlending earned by SOV stakers (in usd)
  """
  totalLendingFeesUsd: BigDecimal!

  """
  Total Margin Trade and Borrow position size that has been liquidated (in usd)
  """
  totalLiquidateVolumeUsd: BigDecimal!

  """
  Total of positionSize property in Trade event (in usd). This includes user collateral and borrowed amount
  """
  totalMarginTradeVolumeUsd: BigDecimal!

  """
  Total fees from Margin Trading earned by SOV stakers (in usd)
  """
  totalTradingFeesUsd: BigDecimal!

  """
  Total volume withdrawn from Lending Pool over all time (in usd)
  """
  totalUnlendVolumeUsd: BigDecimal!

  """
  Total number of users of the protocol. This number is incremented each time a user initiates a transaction with the Protocol.
  Incremented when a user interacts with any contracts tracked by this subgraph.
  Does not include the Zero, Mynt and Perperpetual Swaps users (unless they have also used the core protocol)
  """
  totalUsers: Int!

  """
  The token currently used as a proxy for USD/BTC prices
  """
  usdStablecoin: Token!
}

input ProtocolStats_filter {
  btcUsdPrice: BigDecimal
  btcUsdPrice_gt: BigDecimal
  btcUsdPrice_gte: BigDecimal
  btcUsdPrice_in: [BigDecimal!]
  btcUsdPrice_lt: BigDecimal
  btcUsdPrice_lte: BigDecimal
  btcUsdPrice_not: BigDecimal
  btcUsdPrice_not_in: [BigDecimal!]
  currentStakedByVestingSov: BigDecimal
  currentStakedByVestingSov_gt: BigDecimal
  currentStakedByVestingSov_gte: BigDecimal
  currentStakedByVestingSov_in: [BigDecimal!]
  currentStakedByVestingSov_lt: BigDecimal
  currentStakedByVestingSov_lte: BigDecimal
  currentStakedByVestingSov_not: BigDecimal
  currentStakedByVestingSov_not_in: [BigDecimal!]
  currentVoluntarilyStakedSov: BigDecimal
  currentVoluntarilyStakedSov_gt: BigDecimal
  currentVoluntarilyStakedSov_gte: BigDecimal
  currentVoluntarilyStakedSov_in: [BigDecimal!]
  currentVoluntarilyStakedSov_lt: BigDecimal
  currentVoluntarilyStakedSov_lte: BigDecimal
  currentVoluntarilyStakedSov_not: BigDecimal
  currentVoluntarilyStakedSov_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  tokens: [String!]
  tokens_contains: [String!]
  tokens_not: [String!]
  tokens_not_contains: [String!]
  totalAmmLpFeesUsd: BigDecimal
  totalAmmLpFeesUsd_gt: BigDecimal
  totalAmmLpFeesUsd_gte: BigDecimal
  totalAmmLpFeesUsd_in: [BigDecimal!]
  totalAmmLpFeesUsd_lt: BigDecimal
  totalAmmLpFeesUsd_lte: BigDecimal
  totalAmmLpFeesUsd_not: BigDecimal
  totalAmmLpFeesUsd_not_in: [BigDecimal!]
  totalAmmStakerFeesUsd: BigDecimal
  totalAmmStakerFeesUsd_gt: BigDecimal
  totalAmmStakerFeesUsd_gte: BigDecimal
  totalAmmStakerFeesUsd_in: [BigDecimal!]
  totalAmmStakerFeesUsd_lt: BigDecimal
  totalAmmStakerFeesUsd_lte: BigDecimal
  totalAmmStakerFeesUsd_not: BigDecimal
  totalAmmStakerFeesUsd_not_in: [BigDecimal!]
  totalAmmVolumeUsd: BigDecimal
  totalAmmVolumeUsd_gt: BigDecimal
  totalAmmVolumeUsd_gte: BigDecimal
  totalAmmVolumeUsd_in: [BigDecimal!]
  totalAmmVolumeUsd_lt: BigDecimal
  totalAmmVolumeUsd_lte: BigDecimal
  totalAmmVolumeUsd_not: BigDecimal
  totalAmmVolumeUsd_not_in: [BigDecimal!]
  totalBorrowVolumeUsd: BigDecimal
  totalBorrowVolumeUsd_gt: BigDecimal
  totalBorrowVolumeUsd_gte: BigDecimal
  totalBorrowVolumeUsd_in: [BigDecimal!]
  totalBorrowVolumeUsd_lt: BigDecimal
  totalBorrowVolumeUsd_lte: BigDecimal
  totalBorrowVolumeUsd_not: BigDecimal
  totalBorrowVolumeUsd_not_in: [BigDecimal!]
  totalBorrowingFeesUsd: BigDecimal
  totalBorrowingFeesUsd_gt: BigDecimal
  totalBorrowingFeesUsd_gte: BigDecimal
  totalBorrowingFeesUsd_in: [BigDecimal!]
  totalBorrowingFeesUsd_lt: BigDecimal
  totalBorrowingFeesUsd_lte: BigDecimal
  totalBorrowingFeesUsd_not: BigDecimal
  totalBorrowingFeesUsd_not_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd: BigDecimal
  totalCloseWithDepositVolumeUsd_gt: BigDecimal
  totalCloseWithDepositVolumeUsd_gte: BigDecimal
  totalCloseWithDepositVolumeUsd_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd_lt: BigDecimal
  totalCloseWithDepositVolumeUsd_lte: BigDecimal
  totalCloseWithDepositVolumeUsd_not: BigDecimal
  totalCloseWithDepositVolumeUsd_not_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd: BigDecimal
  totalCloseWithSwapVolumeUsd_gt: BigDecimal
  totalCloseWithSwapVolumeUsd_gte: BigDecimal
  totalCloseWithSwapVolumeUsd_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd_lt: BigDecimal
  totalCloseWithSwapVolumeUsd_lte: BigDecimal
  totalCloseWithSwapVolumeUsd_not: BigDecimal
  totalCloseWithSwapVolumeUsd_not_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd: BigDecimal
  totalDepositCollateralVolumeUsd_gt: BigDecimal
  totalDepositCollateralVolumeUsd_gte: BigDecimal
  totalDepositCollateralVolumeUsd_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd_lt: BigDecimal
  totalDepositCollateralVolumeUsd_lte: BigDecimal
  totalDepositCollateralVolumeUsd_not: BigDecimal
  totalDepositCollateralVolumeUsd_not_in: [BigDecimal!]
  totalLendVolumeUsd: BigDecimal
  totalLendVolumeUsd_gt: BigDecimal
  totalLendVolumeUsd_gte: BigDecimal
  totalLendVolumeUsd_in: [BigDecimal!]
  totalLendVolumeUsd_lt: BigDecimal
  totalLendVolumeUsd_lte: BigDecimal
  totalLendVolumeUsd_not: BigDecimal
  totalLendVolumeUsd_not_in: [BigDecimal!]
  totalLendingFeesUsd: BigDecimal
  totalLendingFeesUsd_gt: BigDecimal
  totalLendingFeesUsd_gte: BigDecimal
  totalLendingFeesUsd_in: [BigDecimal!]
  totalLendingFeesUsd_lt: BigDecimal
  totalLendingFeesUsd_lte: BigDecimal
  totalLendingFeesUsd_not: BigDecimal
  totalLendingFeesUsd_not_in: [BigDecimal!]
  totalLiquidateVolumeUsd: BigDecimal
  totalLiquidateVolumeUsd_gt: BigDecimal
  totalLiquidateVolumeUsd_gte: BigDecimal
  totalLiquidateVolumeUsd_in: [BigDecimal!]
  totalLiquidateVolumeUsd_lt: BigDecimal
  totalLiquidateVolumeUsd_lte: BigDecimal
  totalLiquidateVolumeUsd_not: BigDecimal
  totalLiquidateVolumeUsd_not_in: [BigDecimal!]
  totalMarginTradeVolumeUsd: BigDecimal
  totalMarginTradeVolumeUsd_gt: BigDecimal
  totalMarginTradeVolumeUsd_gte: BigDecimal
  totalMarginTradeVolumeUsd_in: [BigDecimal!]
  totalMarginTradeVolumeUsd_lt: BigDecimal
  totalMarginTradeVolumeUsd_lte: BigDecimal
  totalMarginTradeVolumeUsd_not: BigDecimal
  totalMarginTradeVolumeUsd_not_in: [BigDecimal!]
  totalTradingFeesUsd: BigDecimal
  totalTradingFeesUsd_gt: BigDecimal
  totalTradingFeesUsd_gte: BigDecimal
  totalTradingFeesUsd_in: [BigDecimal!]
  totalTradingFeesUsd_lt: BigDecimal
  totalTradingFeesUsd_lte: BigDecimal
  totalTradingFeesUsd_not: BigDecimal
  totalTradingFeesUsd_not_in: [BigDecimal!]
  totalUnlendVolumeUsd: BigDecimal
  totalUnlendVolumeUsd_gt: BigDecimal
  totalUnlendVolumeUsd_gte: BigDecimal
  totalUnlendVolumeUsd_in: [BigDecimal!]
  totalUnlendVolumeUsd_lt: BigDecimal
  totalUnlendVolumeUsd_lte: BigDecimal
  totalUnlendVolumeUsd_not: BigDecimal
  totalUnlendVolumeUsd_not_in: [BigDecimal!]
  totalUsers: Int
  totalUsers_gt: Int
  totalUsers_gte: Int
  totalUsers_in: [Int!]
  totalUsers_lt: Int
  totalUsers_lte: Int
  totalUsers_not: Int
  totalUsers_not_in: [Int!]
  usdStablecoin: String
  usdStablecoin_contains: String
  usdStablecoin_ends_with: String
  usdStablecoin_gt: String
  usdStablecoin_gte: String
  usdStablecoin_in: [String!]
  usdStablecoin_lt: String
  usdStablecoin_lte: String
  usdStablecoin_not: String
  usdStablecoin_not_contains: String
  usdStablecoin_not_ends_with: String
  usdStablecoin_not_in: [String!]
  usdStablecoin_not_starts_with: String
  usdStablecoin_starts_with: String
}

enum ProtocolStats_orderBy {
  btcUsdPrice
  currentStakedByVestingSov
  currentVoluntarilyStakedSov
  id
  tokens
  totalAmmLpFeesUsd
  totalAmmStakerFeesUsd
  totalAmmVolumeUsd
  totalBorrowVolumeUsd
  totalBorrowingFeesUsd
  totalCloseWithDepositVolumeUsd
  totalCloseWithSwapVolumeUsd
  totalDepositCollateralVolumeUsd
  totalLendVolumeUsd
  totalLendingFeesUsd
  totalLiquidateVolumeUsd
  totalMarginTradeVolumeUsd
  totalTradingFeesUsd
  totalUnlendVolumeUsd
  totalUsers
  usdStablecoin
}

type Query {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  bitcoinTransfer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransfer
  bitcoinTransferBatchSending(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransferBatchSending
  bitcoinTransferBatchSendings(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BitcoinTransferBatchSending_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BitcoinTransferBatchSending_filter
  ): [BitcoinTransferBatchSending!]!
  bitcoinTransfers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BitcoinTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BitcoinTransfer_filter
  ): [BitcoinTransfer!]!
  borrow(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Borrow
  borrows(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Borrow_filter
  ): [Borrow!]!
  candleStick(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStick
  candleSticks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStick_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStick_filter
  ): [CandleStick!]!
  closeWithDeposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithDeposit
  closeWithDeposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithDeposit_filter
  ): [CloseWithDeposit!]!
  closeWithSwap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithSwap
  closeWithSwaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithSwap_filter
  ): [CloseWithSwap!]!
  conversion(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Conversion_filter
  ): [Conversion!]!
  converterRegistries(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ConverterRegistry_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ConverterRegistry_filter
  ): [ConverterRegistry!]!
  converterRegistry(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConverterRegistry
  deposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  depositCollateral(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositCollateral
  depositCollaterals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DepositCollateral_filter
  ): [DepositCollateral!]!
  deposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Deposit_filter
  ): [Deposit!]!
  fastBTCBridgeStat(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FastBTCBridgeStat
  fastBTCBridgeStats(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FastBTCBridgeStat_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FastBTCBridgeStat_filter
  ): [FastBTCBridgeStat!]!
  feeSharingTokensTransferred(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeSharingTokensTransferred
  feeSharingTokensTransferreds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeSharingTokensTransferred_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeSharingTokensTransferred_filter
  ): [FeeSharingTokensTransferred!]!
  lendingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingHistoryItem
  lendingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingHistoryItem_filter
  ): [LendingHistoryItem!]!
  lendingPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingPool
  lendingPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingPool_filter
  ): [LendingPool!]!
  liquidate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidate
  liquidates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Liquidate_filter
  ): [Liquidate!]!
  liquidityHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityHistoryItem
  liquidityHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityHistoryItem_filter
  ): [LiquidityHistoryItem!]!
  liquidityMiningAllocationPoint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningAllocationPoint
  liquidityMiningAllocationPoints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityMiningAllocationPoint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityMiningAllocationPoint_filter
  ): [LiquidityMiningAllocationPoint!]!
  liquidityMiningGlobal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningGlobal
  liquidityMiningGlobals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityMiningGlobal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityMiningGlobal_filter
  ): [LiquidityMiningGlobal!]!
  liquidityPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPoolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolToken
  liquidityPoolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]!
  liquidityPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPool_filter
  ): [LiquidityPool!]!
  loan(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loans(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Loan_filter
  ): [Loan!]!
  marginOrderCanceled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderCanceled
  marginOrderCanceleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MarginOrderCanceled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MarginOrderCanceled_filter
  ): [MarginOrderCanceled!]!
  marginOrderFilled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderFilled
  marginOrderFilleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MarginOrderFilled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MarginOrderFilled_filter
  ): [MarginOrderFilled!]!
  orderCanceled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCanceled
  orderCanceleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderCanceled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderCanceled_filter
  ): [OrderCanceled!]!
  orderCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCreated
  orderCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderCreated_filter
  ): [OrderCreated!]!
  orderFilled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderFilled
  orderFilleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderFilled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderFilled_filter
  ): [OrderFilled!]!
  ownerUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnerUpdate
  ownerUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OwnerUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OwnerUpdate_filter
  ): [OwnerUpdate!]!
  payBorrowingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayBorrowingFee
  payBorrowingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayBorrowingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayBorrowingFee_filter
  ): [PayBorrowingFee!]!
  payLendingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayLendingFee
  payLendingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayLendingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayLendingFee_filter
  ): [PayLendingFee!]!
  payTradingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayTradingFee
  payTradingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayTradingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayTradingFee_filter
  ): [PayTradingFee!]!
  poolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolToken_filter
  ): [PoolToken!]!
  proposal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Proposal_filter
  ): [Proposal!]!
  protocolStats(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ProtocolStats_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ProtocolStats_filter
  ): [ProtocolStats!]!
  rewardsEarnedHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardsEarnedHistoryItem
  rewardsEarnedHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardsEarnedHistoryItem_filter
  ): [RewardsEarnedHistoryItem!]!
  rollover(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Rollover
  rollovers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Rollover_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Rollover_filter
  ): [Rollover!]!
  smartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartToken
  smartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SmartToken_filter
  ): [SmartToken!]!
  stakeHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistoryItem
  stakeHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StakeHistoryItem_filter
  ): [StakeHistoryItem!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenSmartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSmartToken
  tokenSmartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  tokensStaked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensStaked
  tokensStakeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokensStaked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokensStaked_filter
  ): [TokensStaked!]!
  trade(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Trade_filter
  ): [Trade!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userLendingHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLendingHistory_filter
  ): [UserLendingHistory!]!
  userLendingHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLendingHistory
  userLiquidityHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLiquidityHistory_filter
  ): [UserLiquidityHistory!]!
  userLiquidityHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLiquidityHistory
  userRewardsEarnedHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserRewardsEarnedHistory_filter
  ): [UserRewardsEarnedHistory!]!
  userRewardsEarnedHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserRewardsEarnedHistory
  userStakeHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserStakeHistory_filter
  ): [UserStakeHistory!]!
  userStakeHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserStakeHistory
  userTotal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserTotal
  userTotals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserTotal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserTotal_filter
  ): [UserTotal!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  vestingContract(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingContract
  vestingContracts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingContract_filter
  ): [VestingContract!]!
  vestingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingHistoryItem
  vestingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingHistoryItem_filter
  ): [VestingHistoryItem!]!
  voteCast(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteCast
  voteCasts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VoteCast_filter
  ): [VoteCast!]!
  withdrawal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawal
  withdrawals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Withdrawal_filter
  ): [Withdrawal!]!
}

enum RewardsEarnedAction {
  """
  SOV reward earned when a user margin trades or one of their trades is rolled over.
  The reward is a percentage of the trading fee, paid in SOV.
  """
  EarnReward

  """
  When a user claims a liquidity mining reward
  """
  RewardClaimed

  """
  When SOV is staked by a Rewards vesting contract (eg after it has been claimed by the user)
  """
  RewardSovStaked

  """
  When a SOV Staker withdraws their liquid SOV reward for staking
  """
  StakingRewardWithdrawn

  """
  When an SOV Staker withdraws their share of the fees earned by the Protocol
  """
  UserFeeWithdrawn
}

type RewardsEarnedHistoryItem {
  action: RewardsEarnedAction!
  amount: BigDecimal!
  id: ID!
  timestamp: Int!
  token: Token
  transaction: Transaction!
  user: UserRewardsEarnedHistory!
}

input RewardsEarnedHistoryItem_filter {
  action: RewardsEarnedAction
  action_in: [RewardsEarnedAction!]
  action_not: RewardsEarnedAction
  action_not_in: [RewardsEarnedAction!]
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum RewardsEarnedHistoryItem_orderBy {
  action
  amount
  id
  timestamp
  token
  transaction
  user
}

"""
Granular event data for the Loan entity. Emitted when a Loan is rolled over.
This is when the next installment of interest is paid from the collateral, and the trading fee is paid
This transaction is initiated by the Sovryn node, which earns a reward for doing this
"""
type Rollover {
  collateral: BigDecimal!
  emittedBy: Bytes!
  endTimestamp: Int!
  id: ID!
  lender: Bytes!
  loanId: Loan!
  principal: BigDecimal!

  """
  The reward received by the User for performing this function
  """
  reward: BigDecimal!

  """
  The User running the Sovryn node that made this transaction
  """
  rewardReceiver: User!
  timestamp: Int!
  transaction: Transaction!
  user: User!
}

input Rollover_filter {
  collateral: BigDecimal
  collateral_gt: BigDecimal
  collateral_gte: BigDecimal
  collateral_in: [BigDecimal!]
  collateral_lt: BigDecimal
  collateral_lte: BigDecimal
  collateral_not: BigDecimal
  collateral_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  endTimestamp: Int
  endTimestamp_gt: Int
  endTimestamp_gte: Int
  endTimestamp_in: [Int!]
  endTimestamp_lt: Int
  endTimestamp_lte: Int
  endTimestamp_not: Int
  endTimestamp_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  principal: BigDecimal
  principal_gt: BigDecimal
  principal_gte: BigDecimal
  principal_in: [BigDecimal!]
  principal_lt: BigDecimal
  principal_lte: BigDecimal
  principal_not: BigDecimal
  principal_not_in: [BigDecimal!]
  reward: BigDecimal
  rewardReceiver: String
  rewardReceiver_contains: String
  rewardReceiver_ends_with: String
  rewardReceiver_gt: String
  rewardReceiver_gte: String
  rewardReceiver_in: [String!]
  rewardReceiver_lt: String
  rewardReceiver_lte: String
  rewardReceiver_not: String
  rewardReceiver_not_contains: String
  rewardReceiver_not_ends_with: String
  rewardReceiver_not_in: [String!]
  rewardReceiver_not_starts_with: String
  rewardReceiver_starts_with: String
  reward_gt: BigDecimal
  reward_gte: BigDecimal
  reward_in: [BigDecimal!]
  reward_lt: BigDecimal
  reward_lte: BigDecimal
  reward_not: BigDecimal
  reward_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum Rollover_orderBy {
  collateral
  emittedBy
  endTimestamp
  id
  lender
  loanId
  principal
  reward
  rewardReceiver
  timestamp
  transaction
  user
}

"""
The smart token represents a single reserve asset on a single pool.
For V1 pools, there is 1 smart token representing both reserve assets. For V2 pools, there are 2 smart tokens, one for each reserve asset.
"""
type SmartToken {
  addedToRegistryBlockNumber: Int
  addedToRegistryTransactionHash: Bytes

  """
  connectorTokens are the entity that holds the many-to-many relationship between the underlying token asset and the smart token
  """
  connectorTokens(
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]

  """
  The converter registry this smart token belongs to. Can be null if token is removed from th registry
  """
  currentConverterRegistry: ConverterRegistry

  """
  Number of decimal places for this token
  """
  decimals: Int

  """
  ID is smart token contract address
  """
  id: ID!

  """
  The AMM pool this smart token "belongs" to
  """
  liquidityPool: LiquidityPool!

  """
  Name of the smart token (set on the contract)
  """
  name: String

  """
  The contract/account that owns the SmartToken contract. This will typically be the converter registry
  """
  owner: String!

  """
  smartTokenType can be Relay or Liquid
  """
  smartTokenType: String

  """
  Symbol for the smart token asset (set on the contract)
  """
  symbol: String
}

input SmartToken_filter {
  addedToRegistryBlockNumber: Int
  addedToRegistryBlockNumber_gt: Int
  addedToRegistryBlockNumber_gte: Int
  addedToRegistryBlockNumber_in: [Int!]
  addedToRegistryBlockNumber_lt: Int
  addedToRegistryBlockNumber_lte: Int
  addedToRegistryBlockNumber_not: Int
  addedToRegistryBlockNumber_not_in: [Int!]
  addedToRegistryTransactionHash: Bytes
  addedToRegistryTransactionHash_contains: Bytes
  addedToRegistryTransactionHash_in: [Bytes!]
  addedToRegistryTransactionHash_not: Bytes
  addedToRegistryTransactionHash_not_contains: Bytes
  addedToRegistryTransactionHash_not_in: [Bytes!]
  currentConverterRegistry: String
  currentConverterRegistry_contains: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_lt: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_not: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_not_ends_with: String
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_starts_with: String
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  owner: String
  owner_contains: String
  owner_ends_with: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_ends_with: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_starts_with: String
  smartTokenType: String
  smartTokenType_contains: String
  smartTokenType_ends_with: String
  smartTokenType_gt: String
  smartTokenType_gte: String
  smartTokenType_in: [String!]
  smartTokenType_lt: String
  smartTokenType_lte: String
  smartTokenType_not: String
  smartTokenType_not_contains: String
  smartTokenType_not_ends_with: String
  smartTokenType_not_in: [String!]
  smartTokenType_not_starts_with: String
  smartTokenType_starts_with: String
  symbol: String
  symbol_contains: String
  symbol_ends_with: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_ends_with: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_starts_with: String
}

enum SmartToken_orderBy {
  addedToRegistryBlockNumber
  addedToRegistryTransactionHash
  connectorTokens
  currentConverterRegistry
  decimals
  id
  liquidityPool
  name
  owner
  smartTokenType
  symbol
}

enum StakeHistoryAction {
  Delegate
  ExtendStake
  FeeWithdrawn
  IncreaseStake
  Stake
  Unstake
  WithdrawStaked
}

type StakeHistoryItem {
  action: StakeHistoryAction!
  amount: BigDecimal
  id: ID!
  lockedUntil: Int
  timestamp: Int!
  transaction: Transaction!
  user: UserStakeHistory!
}

input StakeHistoryItem_filter {
  action: StakeHistoryAction
  action_in: [StakeHistoryAction!]
  action_not: StakeHistoryAction
  action_not_in: [StakeHistoryAction!]
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedUntil: Int
  lockedUntil_gt: Int
  lockedUntil_gte: Int
  lockedUntil_in: [Int!]
  lockedUntil_lt: Int
  lockedUntil_lte: Int
  lockedUntil_not: Int
  lockedUntil_not_in: [Int!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum StakeHistoryItem_orderBy {
  action
  amount
  id
  lockedUntil
  timestamp
  transaction
  user
}

type Subscription {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  bitcoinTransfer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransfer
  bitcoinTransferBatchSending(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BitcoinTransferBatchSending
  bitcoinTransferBatchSendings(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BitcoinTransferBatchSending_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BitcoinTransferBatchSending_filter
  ): [BitcoinTransferBatchSending!]!
  bitcoinTransfers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BitcoinTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BitcoinTransfer_filter
  ): [BitcoinTransfer!]!
  borrow(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Borrow
  borrows(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Borrow_filter
  ): [Borrow!]!
  candleStick(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStick
  candleSticks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CandleStick_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CandleStick_filter
  ): [CandleStick!]!
  closeWithDeposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithDeposit
  closeWithDeposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithDeposit_filter
  ): [CloseWithDeposit!]!
  closeWithSwap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithSwap
  closeWithSwaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CloseWithSwap_filter
  ): [CloseWithSwap!]!
  conversion(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Conversion_filter
  ): [Conversion!]!
  converterRegistries(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ConverterRegistry_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ConverterRegistry_filter
  ): [ConverterRegistry!]!
  converterRegistry(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConverterRegistry
  deposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposit
  depositCollateral(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositCollateral
  depositCollaterals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DepositCollateral_filter
  ): [DepositCollateral!]!
  deposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Deposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Deposit_filter
  ): [Deposit!]!
  fastBTCBridgeStat(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FastBTCBridgeStat
  fastBTCBridgeStats(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FastBTCBridgeStat_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FastBTCBridgeStat_filter
  ): [FastBTCBridgeStat!]!
  feeSharingTokensTransferred(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeSharingTokensTransferred
  feeSharingTokensTransferreds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeSharingTokensTransferred_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeSharingTokensTransferred_filter
  ): [FeeSharingTokensTransferred!]!
  lendingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingHistoryItem
  lendingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingHistoryItem_filter
  ): [LendingHistoryItem!]!
  lendingPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingPool
  lendingPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LendingPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LendingPool_filter
  ): [LendingPool!]!
  liquidate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidate
  liquidates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Liquidate_filter
  ): [Liquidate!]!
  liquidityHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityHistoryItem
  liquidityHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityHistoryItem_filter
  ): [LiquidityHistoryItem!]!
  liquidityMiningAllocationPoint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningAllocationPoint
  liquidityMiningAllocationPoints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityMiningAllocationPoint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityMiningAllocationPoint_filter
  ): [LiquidityMiningAllocationPoint!]!
  liquidityMiningGlobal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityMiningGlobal
  liquidityMiningGlobals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityMiningGlobal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityMiningGlobal_filter
  ): [LiquidityMiningGlobal!]!
  liquidityPool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPoolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolToken
  liquidityPoolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]!
  liquidityPools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPool_filter
  ): [LiquidityPool!]!
  loan(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loans(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Loan_filter
  ): [Loan!]!
  marginOrderCanceled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderCanceled
  marginOrderCanceleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MarginOrderCanceled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MarginOrderCanceled_filter
  ): [MarginOrderCanceled!]!
  marginOrderFilled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarginOrderFilled
  marginOrderFilleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MarginOrderFilled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MarginOrderFilled_filter
  ): [MarginOrderFilled!]!
  orderCanceled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCanceled
  orderCanceleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderCanceled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderCanceled_filter
  ): [OrderCanceled!]!
  orderCreated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderCreated
  orderCreateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderCreated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderCreated_filter
  ): [OrderCreated!]!
  orderFilled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderFilled
  orderFilleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderFilled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderFilled_filter
  ): [OrderFilled!]!
  ownerUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnerUpdate
  ownerUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OwnerUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OwnerUpdate_filter
  ): [OwnerUpdate!]!
  payBorrowingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayBorrowingFee
  payBorrowingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayBorrowingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayBorrowingFee_filter
  ): [PayBorrowingFee!]!
  payLendingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayLendingFee
  payLendingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayLendingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayLendingFee_filter
  ): [PayLendingFee!]!
  payTradingFee(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayTradingFee
  payTradingFees(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PayTradingFee_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PayTradingFee_filter
  ): [PayTradingFee!]!
  poolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolToken_filter
  ): [PoolToken!]!
  proposal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Proposal_filter
  ): [Proposal!]!
  protocolStats(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ProtocolStats_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ProtocolStats_filter
  ): [ProtocolStats!]!
  rewardsEarnedHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardsEarnedHistoryItem
  rewardsEarnedHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardsEarnedHistoryItem_filter
  ): [RewardsEarnedHistoryItem!]!
  rollover(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Rollover
  rollovers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Rollover_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Rollover_filter
  ): [Rollover!]!
  smartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartToken
  smartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SmartToken_filter
  ): [SmartToken!]!
  stakeHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistoryItem
  stakeHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: StakeHistoryItem_filter
  ): [StakeHistoryItem!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenSmartToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSmartToken
  tokenSmartTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  tokensStaked(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensStaked
  tokensStakeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokensStaked_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokensStaked_filter
  ): [TokensStaked!]!
  trade(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Trade_filter
  ): [Trade!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userLendingHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLendingHistory_filter
  ): [UserLendingHistory!]!
  userLendingHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLendingHistory
  userLiquidityHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserLiquidityHistory_filter
  ): [UserLiquidityHistory!]!
  userLiquidityHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLiquidityHistory
  userRewardsEarnedHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserRewardsEarnedHistory_filter
  ): [UserRewardsEarnedHistory!]!
  userRewardsEarnedHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserRewardsEarnedHistory
  userStakeHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserStakeHistory_filter
  ): [UserStakeHistory!]!
  userStakeHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserStakeHistory
  userTotal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserTotal
  userTotals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserTotal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserTotal_filter
  ): [UserTotal!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  vestingContract(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingContract
  vestingContracts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingContract_filter
  ): [VestingContract!]!
  vestingHistoryItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingHistoryItem
  vestingHistoryItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VestingHistoryItem_filter
  ): [VestingHistoryItem!]!
  voteCast(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteCast
  voteCasts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VoteCast_filter
  ): [VoteCast!]!
  withdrawal(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawal
  withdrawals(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Withdrawal_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Withdrawal_filter
  ): [Withdrawal!]!
}

"""
The Swap entity is an aggregated entity of the individual Conversion events in a transaction.
For example, if a User swaps XUSD to SOV, there will be 2 Conversion events through 2 AMMs (XUSD-BTC and BTC-SOV) in one transaction. These two Conversions are aggregated here.
"""
type Swap {
  """
  The AMM Conversion events involved in this swap
  """
  conversions(
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Conversion_filter
  ): [Conversion!]
  fromAmount: BigDecimal!

  """
  Token the user sold
  """
  fromToken: Token!

  """
  Transaction hash of this swap
  """
  id: ID!
  isBorrow: Boolean!

  """
  Was this swap a limit order?
  """
  isLimit: Boolean!

  """
  Was this swap part of a margin trade?
  """
  isMarginTrade: Boolean!

  """
  The number of AMM Conversions involved in this swap (this is primarily for debugging purposes)
  """
  numConversions: Int!

  """
  Rate is calculated as toAmount / fromAmount
  """
  rate: BigDecimal!
  timestamp: Int!
  toAmount: BigDecimal!

  """
  Token the user bought
  """
  toToken: Token!
  transaction: Transaction!

  """
  If this swap was initiated by a contract (for example as part of a Margin Trade), User will be null.
  Otherwise, this is the user that initiated the transaction.
  """
  user: User
}

input Swap_filter {
  fromAmount: BigDecimal
  fromAmount_gt: BigDecimal
  fromAmount_gte: BigDecimal
  fromAmount_in: [BigDecimal!]
  fromAmount_lt: BigDecimal
  fromAmount_lte: BigDecimal
  fromAmount_not: BigDecimal
  fromAmount_not_in: [BigDecimal!]
  fromToken: String
  fromToken_contains: String
  fromToken_ends_with: String
  fromToken_gt: String
  fromToken_gte: String
  fromToken_in: [String!]
  fromToken_lt: String
  fromToken_lte: String
  fromToken_not: String
  fromToken_not_contains: String
  fromToken_not_ends_with: String
  fromToken_not_in: [String!]
  fromToken_not_starts_with: String
  fromToken_starts_with: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isBorrow: Boolean
  isBorrow_in: [Boolean!]
  isBorrow_not: Boolean
  isBorrow_not_in: [Boolean!]
  isLimit: Boolean
  isLimit_in: [Boolean!]
  isLimit_not: Boolean
  isLimit_not_in: [Boolean!]
  isMarginTrade: Boolean
  isMarginTrade_in: [Boolean!]
  isMarginTrade_not: Boolean
  isMarginTrade_not_in: [Boolean!]
  numConversions: Int
  numConversions_gt: Int
  numConversions_gte: Int
  numConversions_in: [Int!]
  numConversions_lt: Int
  numConversions_lte: Int
  numConversions_not: Int
  numConversions_not_in: [Int!]
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  toAmount: BigDecimal
  toAmount_gt: BigDecimal
  toAmount_gte: BigDecimal
  toAmount_in: [BigDecimal!]
  toAmount_lt: BigDecimal
  toAmount_lte: BigDecimal
  toAmount_not: BigDecimal
  toAmount_not_in: [BigDecimal!]
  toToken: String
  toToken_contains: String
  toToken_ends_with: String
  toToken_gt: String
  toToken_gte: String
  toToken_in: [String!]
  toToken_lt: String
  toToken_lte: String
  toToken_not: String
  toToken_not_contains: String
  toToken_not_ends_with: String
  toToken_not_in: [String!]
  toToken_not_starts_with: String
  toToken_starts_with: String
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum Swap_orderBy {
  conversions
  fromAmount
  fromToken
  id
  isBorrow
  isLimit
  isMarginTrade
  numConversions
  rate
  timestamp
  toAmount
  toToken
  transaction
  user
}

"""
This entity represents an ERC20 token traded on the Sovryn Protocol
"""
type Token {
  """
  The total volume of this token that has been traded through the protocol quoted in BTC
  """
  btcVolume: BigDecimal!
  currentConverterRegistry: ConverterRegistry

  """
  Number of decimal places used in the smart contract for this token
  """
  decimals: Int

  """
  The ID is the contract address of the token on RSK
  """
  id: ID!

  """
  lastPriceBtc is the last traded price of this token in BTC
  """
  lastPriceBtc: BigDecimal!

  """
  lastPriceUsd is the last traded price of this token in USD
  """
  lastPriceUsd: BigDecimal!

  """
  The addresses of the LiquidityPools where this token is a reserve asset
  """
  liquidityPools(
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]
  name: String

  """
  Internal use only - previous BTC price used for candleSticks
  """
  prevPriceBtc: BigDecimal!

  """
  Internal use only - previous BTC price used for candleSticks
  """
  prevPriceUsd: BigDecimal!

  """
  The smart tokens that have this token as an underlying asset
  """
  smartTokens(
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]
  symbol: String

  """
  The total volume of this token that has been traded through the protocol
  """
  tokenVolume: BigDecimal!

  """
  The total volume of this token that has been traded through the protocol quoted in USD
  """
  usdVolume: BigDecimal!
  version: Int
}

"""
This entity is to store a many-to-many relationship between tokens and smart tokens
"""
type TokenSmartToken {
  """
  ID is token address + smart token address
  """
  id: ID!
  smartToken: SmartToken!

  """
  token is the underlying asset represented by the smartToken
  """
  token: Token!
}

input TokenSmartToken_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  smartToken: String
  smartToken_contains: String
  smartToken_ends_with: String
  smartToken_gt: String
  smartToken_gte: String
  smartToken_in: [String!]
  smartToken_lt: String
  smartToken_lte: String
  smartToken_not: String
  smartToken_not_contains: String
  smartToken_not_ends_with: String
  smartToken_not_in: [String!]
  smartToken_not_starts_with: String
  smartToken_starts_with: String
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
}

enum TokenSmartToken_orderBy {
  id
  smartToken
  token
}

input Token_filter {
  btcVolume: BigDecimal
  btcVolume_gt: BigDecimal
  btcVolume_gte: BigDecimal
  btcVolume_in: [BigDecimal!]
  btcVolume_lt: BigDecimal
  btcVolume_lte: BigDecimal
  btcVolume_not: BigDecimal
  btcVolume_not_in: [BigDecimal!]
  currentConverterRegistry: String
  currentConverterRegistry_contains: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_lt: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_not: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_not_ends_with: String
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_starts_with: String
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastPriceBtc: BigDecimal
  lastPriceBtc_gt: BigDecimal
  lastPriceBtc_gte: BigDecimal
  lastPriceBtc_in: [BigDecimal!]
  lastPriceBtc_lt: BigDecimal
  lastPriceBtc_lte: BigDecimal
  lastPriceBtc_not: BigDecimal
  lastPriceBtc_not_in: [BigDecimal!]
  lastPriceUsd: BigDecimal
  lastPriceUsd_gt: BigDecimal
  lastPriceUsd_gte: BigDecimal
  lastPriceUsd_in: [BigDecimal!]
  lastPriceUsd_lt: BigDecimal
  lastPriceUsd_lte: BigDecimal
  lastPriceUsd_not: BigDecimal
  lastPriceUsd_not_in: [BigDecimal!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  prevPriceBtc: BigDecimal
  prevPriceBtc_gt: BigDecimal
  prevPriceBtc_gte: BigDecimal
  prevPriceBtc_in: [BigDecimal!]
  prevPriceBtc_lt: BigDecimal
  prevPriceBtc_lte: BigDecimal
  prevPriceBtc_not: BigDecimal
  prevPriceBtc_not_in: [BigDecimal!]
  prevPriceUsd: BigDecimal
  prevPriceUsd_gt: BigDecimal
  prevPriceUsd_gte: BigDecimal
  prevPriceUsd_in: [BigDecimal!]
  prevPriceUsd_lt: BigDecimal
  prevPriceUsd_lte: BigDecimal
  prevPriceUsd_not: BigDecimal
  prevPriceUsd_not_in: [BigDecimal!]
  symbol: String
  symbol_contains: String
  symbol_ends_with: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_ends_with: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_starts_with: String
  tokenVolume: BigDecimal
  tokenVolume_gt: BigDecimal
  tokenVolume_gte: BigDecimal
  tokenVolume_in: [BigDecimal!]
  tokenVolume_lt: BigDecimal
  tokenVolume_lte: BigDecimal
  tokenVolume_not: BigDecimal
  tokenVolume_not_in: [BigDecimal!]
  usdVolume: BigDecimal
  usdVolume_gt: BigDecimal
  usdVolume_gte: BigDecimal
  usdVolume_in: [BigDecimal!]
  usdVolume_lt: BigDecimal
  usdVolume_lte: BigDecimal
  usdVolume_not: BigDecimal
  usdVolume_not_in: [BigDecimal!]
  version: Int
  version_gt: Int
  version_gte: Int
  version_in: [Int!]
  version_lt: Int
  version_lte: Int
  version_not: Int
  version_not_in: [Int!]
}

enum Token_orderBy {
  btcVolume
  currentConverterRegistry
  decimals
  id
  lastPriceBtc
  lastPriceUsd
  liquidityPools
  name
  prevPriceBtc
  prevPriceUsd
  smartTokens
  symbol
  tokenVolume
  usdVolume
  version
}

type TokensStaked {
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  isUserStaked: Boolean!
  lockedUntil: Int!
  staker: Bytes!
  timestamp: Int!
  totalStaked: BigDecimal!
  transaction: Transaction!
  user: User
}

input TokensStaked_filter {
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isUserStaked: Boolean
  isUserStaked_in: [Boolean!]
  isUserStaked_not: Boolean
  isUserStaked_not_in: [Boolean!]
  lockedUntil: Int
  lockedUntil_gt: Int
  lockedUntil_gte: Int
  lockedUntil_in: [Int!]
  lockedUntil_lt: Int
  lockedUntil_lte: Int
  lockedUntil_not: Int
  lockedUntil_not_in: [Int!]
  staker: Bytes
  staker_contains: Bytes
  staker_in: [Bytes!]
  staker_not: Bytes
  staker_not_contains: Bytes
  staker_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalStaked: BigDecimal
  totalStaked_gt: BigDecimal
  totalStaked_gte: BigDecimal
  totalStaked_in: [BigDecimal!]
  totalStaked_lt: BigDecimal
  totalStaked_lte: BigDecimal
  totalStaked_not: BigDecimal
  totalStaked_not_in: [BigDecimal!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum TokensStaked_orderBy {
  amount
  emittedBy
  id
  isUserStaked
  lockedUntil
  staker
  timestamp
  totalStaked
  transaction
  user
}

"""
Granular event data for the Loan entity. Emitted when a user opens a Margin Trade
"""
type Trade {
  borrowedAmount: BigDecimal!
  collateralToken: Token!
  currentLeverage: BigDecimal!
  emittedBy: Bytes!
  entryLeverage: BigDecimal!
  entryPrice: BigDecimal!
  id: ID!
  interestRate: BigDecimal!
  lender: Bytes!
  loanId: Loan!
  loanToken: Token!
  positionSize: BigDecimal!
  settlementDate: Int!
  timestamp: Int!
  transaction: Transaction!
  user: User!
}

input Trade_filter {
  borrowedAmount: BigDecimal
  borrowedAmount_gt: BigDecimal
  borrowedAmount_gte: BigDecimal
  borrowedAmount_in: [BigDecimal!]
  borrowedAmount_lt: BigDecimal
  borrowedAmount_lte: BigDecimal
  borrowedAmount_not: BigDecimal
  borrowedAmount_not_in: [BigDecimal!]
  collateralToken: String
  collateralToken_contains: String
  collateralToken_ends_with: String
  collateralToken_gt: String
  collateralToken_gte: String
  collateralToken_in: [String!]
  collateralToken_lt: String
  collateralToken_lte: String
  collateralToken_not: String
  collateralToken_not_contains: String
  collateralToken_not_ends_with: String
  collateralToken_not_in: [String!]
  collateralToken_not_starts_with: String
  collateralToken_starts_with: String
  currentLeverage: BigDecimal
  currentLeverage_gt: BigDecimal
  currentLeverage_gte: BigDecimal
  currentLeverage_in: [BigDecimal!]
  currentLeverage_lt: BigDecimal
  currentLeverage_lte: BigDecimal
  currentLeverage_not: BigDecimal
  currentLeverage_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  entryLeverage: BigDecimal
  entryLeverage_gt: BigDecimal
  entryLeverage_gte: BigDecimal
  entryLeverage_in: [BigDecimal!]
  entryLeverage_lt: BigDecimal
  entryLeverage_lte: BigDecimal
  entryLeverage_not: BigDecimal
  entryLeverage_not_in: [BigDecimal!]
  entryPrice: BigDecimal
  entryPrice_gt: BigDecimal
  entryPrice_gte: BigDecimal
  entryPrice_in: [BigDecimal!]
  entryPrice_lt: BigDecimal
  entryPrice_lte: BigDecimal
  entryPrice_not: BigDecimal
  entryPrice_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  interestRate: BigDecimal
  interestRate_gt: BigDecimal
  interestRate_gte: BigDecimal
  interestRate_in: [BigDecimal!]
  interestRate_lt: BigDecimal
  interestRate_lte: BigDecimal
  interestRate_not: BigDecimal
  interestRate_not_in: [BigDecimal!]
  lender: Bytes
  lender_contains: Bytes
  lender_in: [Bytes!]
  lender_not: Bytes
  lender_not_contains: Bytes
  lender_not_in: [Bytes!]
  loanId: String
  loanId_contains: String
  loanId_ends_with: String
  loanId_gt: String
  loanId_gte: String
  loanId_in: [String!]
  loanId_lt: String
  loanId_lte: String
  loanId_not: String
  loanId_not_contains: String
  loanId_not_ends_with: String
  loanId_not_in: [String!]
  loanId_not_starts_with: String
  loanId_starts_with: String
  loanToken: String
  loanToken_contains: String
  loanToken_ends_with: String
  loanToken_gt: String
  loanToken_gte: String
  loanToken_in: [String!]
  loanToken_lt: String
  loanToken_lte: String
  loanToken_not: String
  loanToken_not_contains: String
  loanToken_not_ends_with: String
  loanToken_not_in: [String!]
  loanToken_not_starts_with: String
  loanToken_starts_with: String
  positionSize: BigDecimal
  positionSize_gt: BigDecimal
  positionSize_gte: BigDecimal
  positionSize_in: [BigDecimal!]
  positionSize_lt: BigDecimal
  positionSize_lte: BigDecimal
  positionSize_not: BigDecimal
  positionSize_not_in: [BigDecimal!]
  settlementDate: Int
  settlementDate_gt: Int
  settlementDate_gte: Int
  settlementDate_in: [Int!]
  settlementDate_lt: Int
  settlementDate_lte: Int
  settlementDate_not: Int
  settlementDate_not_in: [Int!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum Trade_orderBy {
  borrowedAmount
  collateralToken
  currentLeverage
  emittedBy
  entryLeverage
  entryPrice
  id
  interestRate
  lender
  loanId
  loanToken
  positionSize
  settlementDate
  timestamp
  transaction
  user
}

"""
Transaction data, including hash and timestamp
"""
type Transaction {
  blockNumber: Int!

  """
  The account that initiated this transaction. This must be an Account and not a Contract.
  """
  from: User!
  gasLimit: BigInt!
  gasPrice: BigInt!

  """
  ID is transaction hash
  """
  id: ID!

  """
  The index of this transaction within the block
  """
  index: Int!

  """
  The timestamp the transaction was confirmed
  """
  timestamp: Int!

  """
  The contract the user interacted with
  """
  to: Bytes
  value: BigInt!
}

input Transaction_filter {
  blockNumber: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_in: [Int!]
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_not: Int
  blockNumber_not_in: [Int!]
  from: String
  from_contains: String
  from_ends_with: String
  from_gt: String
  from_gte: String
  from_in: [String!]
  from_lt: String
  from_lte: String
  from_not: String
  from_not_contains: String
  from_not_ends_with: String
  from_not_in: [String!]
  from_not_starts_with: String
  from_starts_with: String
  gasLimit: BigInt
  gasLimit_gt: BigInt
  gasLimit_gte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_lt: BigInt
  gasLimit_lte: BigInt
  gasLimit_not: BigInt
  gasLimit_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  to: Bytes
  to_contains: Bytes
  to_in: [Bytes!]
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum Transaction_orderBy {
  blockNumber
  from
  gasLimit
  gasPrice
  id
  index
  timestamp
  to
  value
}

"""
This entity contains all user-specific data displayed on the dapp, including all user actions
"""
type User {
  """
  FastBTCBridge transfers from BTC to RSK
  """
  bitcoinTransfers(
    first: Int = 100
    orderBy: BitcoinTransfer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: BitcoinTransfer_filter
  ): [BitcoinTransfer!]

  """
  An array of Borrow events
  """
  borrows(
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Borrow_filter
  ): [Borrow!]

  """
  Timestamp of User's first interaction with the protocol (first transaction)
  """
  createdAtTimestamp: Int!
  fastBTCBridgeStats(
    first: Int = 100
    orderBy: FastBTCBridgeStat_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: FastBTCBridgeStat_filter
  ): [FastBTCBridgeStat!]

  """
  ID is user wallet address
  """
  id: ID!

  """
  The lending history of a User, separated into lending pools. Explore the UserLendingHistory entity for more granular events.
  """
  lendingHistory(
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserLendingHistory_filter
  ): [UserLendingHistory!]

  """
  An array of Liquidation events linked to this user
  """
  liquidations(
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Liquidate_filter
  ): [Liquidate!]

  """
  An array of all LiquidityAdded and LiquidityRemoved events
  """
  liquidityHistory(
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserLiquidityHistory_filter
  ): [UserLiquidityHistory!]

  """
  All loans taken out by this user, including for margin trading and for borrowing
  """
  loans(
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Loan_filter
  ): [Loan!]

  """
  The Rewards history of one user. This includes actions like EarnReward, RewardSovDeposited, and RewardSovStaked.
  Explore the UserRewardsEarnedHistory entity for more granular events
  """
  rewardsEarnedHistory(
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserRewardsEarnedHistory_filter
  ): [UserRewardsEarnedHistory!]

  """
  The SOV Staking history of a user. This includes withdrawing vested tokens. Explore the UserStakeHistory entity for more granular events.
  """
  stakeHistory(
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserStakeHistory_filter
  ): [UserStakeHistory!]

  """
  Swaps here refers to only user-triggered swaps. For example, a swap that is part of a margin trade would not be included.
  Swaps involving multiple amm pools are stored as a single swap, comprised of multiple Conversion events
  """
  swaps(
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Swap_filter
  ): [Swap!]

  """
  An array of margin trade Trade events
  """
  trades(
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Trade_filter
  ): [Trade!]

  """
  Transactions initiated by this user
  """
  transactions(
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Transaction_filter
  ): [Transaction!]

  """
  See UserTotals entity for full documentation
  """
  userTotals: UserTotal

  """
  Vesting contracts owned by User, labelled by type
  """
  vestingContracts(
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VestingContract_filter
  ): [VestingContract!]

  """
  Voting history of User
  """
  votes(
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VoteCast_filter
  ): [VoteCast!]
}

"""
This entity contains the lending and unlending history of one User
"""
type UserLendingHistory {
  """
  ID is userAddress + lendingPoolAddress (lendingPool in this case is the lending pool token)
  """
  id: ID!

  """
  Granular Lend/UnLend events. Derived from Mint/Burn events on the contracts
  """
  lendingHistory(
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LendingHistoryItem_filter
  ): [LendingHistoryItem!]
  lendingPool: LendingPool!

  """
  Total volume this User has lent to this pool over all time (in the underlying asset currency, ie rBTC for the rBTC lending pool)
  """
  totalLendVolume: BigDecimal!

  """
  Total volume this User has withdrawn from this pool over all time
  """
  totalUnlendVolume: BigDecimal!
  user: User!
}

input UserLendingHistory_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lendingPool: String
  lendingPool_contains: String
  lendingPool_ends_with: String
  lendingPool_gt: String
  lendingPool_gte: String
  lendingPool_in: [String!]
  lendingPool_lt: String
  lendingPool_lte: String
  lendingPool_not: String
  lendingPool_not_contains: String
  lendingPool_not_ends_with: String
  lendingPool_not_in: [String!]
  lendingPool_not_starts_with: String
  lendingPool_starts_with: String
  totalLendVolume: BigDecimal
  totalLendVolume_gt: BigDecimal
  totalLendVolume_gte: BigDecimal
  totalLendVolume_in: [BigDecimal!]
  totalLendVolume_lt: BigDecimal
  totalLendVolume_lte: BigDecimal
  totalLendVolume_not: BigDecimal
  totalLendVolume_not_in: [BigDecimal!]
  totalUnlendVolume: BigDecimal
  totalUnlendVolume_gt: BigDecimal
  totalUnlendVolume_gte: BigDecimal
  totalUnlendVolume_in: [BigDecimal!]
  totalUnlendVolume_lt: BigDecimal
  totalUnlendVolume_lte: BigDecimal
  totalUnlendVolume_not: BigDecimal
  totalUnlendVolume_not_in: [BigDecimal!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum UserLendingHistory_orderBy {
  id
  lendingHistory
  lendingPool
  totalLendVolume
  totalUnlendVolume
  user
}

"""
This entity stores one User's history of adding and removing liquidity from one AMM pool
"""
type UserLiquidityHistory {
  """
  The ID is userAddress + '-' + smartToken
  Liquidity Pool address is not used here because when a liquidity pool is updated the address changes, but the smart token address remains the same.
  """
  id: ID!

  """
  Granular transaction history for transactions adding or removing liquidity from an AMM pool
  """
  liquidityHistory(
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityHistoryItem_filter
  ): [LiquidityHistoryItem!]

  """
  This is the pool token (sometimes called smart token), not the liquidity pool address
  """
  poolToken: PoolToken!

  """
  Asset0 is defined on the LiquidityPool.
  These totals are amounts added and removed over all time. These values are used to calculate a user's PnL from liquidity provision.
  """
  totalAsset0LiquidityAdded: BigDecimal!
  totalAsset0LiquidityRemoved: BigDecimal!

  """
  Asset1 is defined on the LiquidityPool
  These totals are amounts added and removed over all time. These values are used to calculate a user's PnL from liquidity provision.
  """
  totalAsset1LiquidityAdded: BigDecimal!
  totalAsset1LiquidityRemoved: BigDecimal!
  user: User!
}

input UserLiquidityHistory_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  poolToken: String
  poolToken_contains: String
  poolToken_ends_with: String
  poolToken_gt: String
  poolToken_gte: String
  poolToken_in: [String!]
  poolToken_lt: String
  poolToken_lte: String
  poolToken_not: String
  poolToken_not_contains: String
  poolToken_not_ends_with: String
  poolToken_not_in: [String!]
  poolToken_not_starts_with: String
  poolToken_starts_with: String
  totalAsset0LiquidityAdded: BigDecimal
  totalAsset0LiquidityAdded_gt: BigDecimal
  totalAsset0LiquidityAdded_gte: BigDecimal
  totalAsset0LiquidityAdded_in: [BigDecimal!]
  totalAsset0LiquidityAdded_lt: BigDecimal
  totalAsset0LiquidityAdded_lte: BigDecimal
  totalAsset0LiquidityAdded_not: BigDecimal
  totalAsset0LiquidityAdded_not_in: [BigDecimal!]
  totalAsset0LiquidityRemoved: BigDecimal
  totalAsset0LiquidityRemoved_gt: BigDecimal
  totalAsset0LiquidityRemoved_gte: BigDecimal
  totalAsset0LiquidityRemoved_in: [BigDecimal!]
  totalAsset0LiquidityRemoved_lt: BigDecimal
  totalAsset0LiquidityRemoved_lte: BigDecimal
  totalAsset0LiquidityRemoved_not: BigDecimal
  totalAsset0LiquidityRemoved_not_in: [BigDecimal!]
  totalAsset1LiquidityAdded: BigDecimal
  totalAsset1LiquidityAdded_gt: BigDecimal
  totalAsset1LiquidityAdded_gte: BigDecimal
  totalAsset1LiquidityAdded_in: [BigDecimal!]
  totalAsset1LiquidityAdded_lt: BigDecimal
  totalAsset1LiquidityAdded_lte: BigDecimal
  totalAsset1LiquidityAdded_not: BigDecimal
  totalAsset1LiquidityAdded_not_in: [BigDecimal!]
  totalAsset1LiquidityRemoved: BigDecimal
  totalAsset1LiquidityRemoved_gt: BigDecimal
  totalAsset1LiquidityRemoved_gte: BigDecimal
  totalAsset1LiquidityRemoved_in: [BigDecimal!]
  totalAsset1LiquidityRemoved_lt: BigDecimal
  totalAsset1LiquidityRemoved_lte: BigDecimal
  totalAsset1LiquidityRemoved_not: BigDecimal
  totalAsset1LiquidityRemoved_not_in: [BigDecimal!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum UserLiquidityHistory_orderBy {
  id
  liquidityHistory
  poolToken
  totalAsset0LiquidityAdded
  totalAsset0LiquidityRemoved
  totalAsset1LiquidityAdded
  totalAsset1LiquidityRemoved
  user
}

"""
This entity contains the history, fees and totals regarding one users' SOV rewards
"""
type UserRewardsEarnedHistory {
  """
  SOV rewards earned from margin trading, but not yet claimed and vested
  Incremented by EarnReward events, and set to 0 by TokensStaked events on the LockedSOV contract
  """
  availableTradingRewards: BigDecimal!
  id: ID!

  """
  Granular events for transaction where a reward is earned
  """
  rewardsEarnedHistory(
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: RewardsEarnedHistoryItem_filter
  ): [RewardsEarnedHistoryItem!]

  """
  This is the total of all EarnReward and RewardClaimed events
  """
  totalFeesAndRewardsEarned: BigDecimal!

  """
  Sum of all SOV rewards earned from margin trading.
  Incremented by EarnReward events
  """
  totalTradingRewards: BigDecimal!
  user: User!
}

input UserRewardsEarnedHistory_filter {
  availableTradingRewards: BigDecimal
  availableTradingRewards_gt: BigDecimal
  availableTradingRewards_gte: BigDecimal
  availableTradingRewards_in: [BigDecimal!]
  availableTradingRewards_lt: BigDecimal
  availableTradingRewards_lte: BigDecimal
  availableTradingRewards_not: BigDecimal
  availableTradingRewards_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  totalFeesAndRewardsEarned: BigDecimal
  totalFeesAndRewardsEarned_gt: BigDecimal
  totalFeesAndRewardsEarned_gte: BigDecimal
  totalFeesAndRewardsEarned_in: [BigDecimal!]
  totalFeesAndRewardsEarned_lt: BigDecimal
  totalFeesAndRewardsEarned_lte: BigDecimal
  totalFeesAndRewardsEarned_not: BigDecimal
  totalFeesAndRewardsEarned_not_in: [BigDecimal!]
  totalTradingRewards: BigDecimal
  totalTradingRewards_gt: BigDecimal
  totalTradingRewards_gte: BigDecimal
  totalTradingRewards_in: [BigDecimal!]
  totalTradingRewards_lt: BigDecimal
  totalTradingRewards_lte: BigDecimal
  totalTradingRewards_not: BigDecimal
  totalTradingRewards_not_in: [BigDecimal!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum UserRewardsEarnedHistory_orderBy {
  availableTradingRewards
  id
  rewardsEarnedHistory
  totalFeesAndRewardsEarned
  totalTradingRewards
  user
}

type UserStakeHistory {
  id: ID!
  stakeHistory(
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: StakeHistoryItem_filter
  ): [StakeHistoryItem!]
  totalRemaining: BigDecimal!
  totalStaked: BigDecimal!
  totalWithdrawn: BigDecimal!
  user: User!
}

input UserStakeHistory_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  totalRemaining: BigDecimal
  totalRemaining_gt: BigDecimal
  totalRemaining_gte: BigDecimal
  totalRemaining_in: [BigDecimal!]
  totalRemaining_lt: BigDecimal
  totalRemaining_lte: BigDecimal
  totalRemaining_not: BigDecimal
  totalRemaining_not_in: [BigDecimal!]
  totalStaked: BigDecimal
  totalStaked_gt: BigDecimal
  totalStaked_gte: BigDecimal
  totalStaked_in: [BigDecimal!]
  totalStaked_lt: BigDecimal
  totalStaked_lte: BigDecimal
  totalStaked_not: BigDecimal
  totalStaked_not_in: [BigDecimal!]
  totalWithdrawn: BigDecimal
  totalWithdrawn_gt: BigDecimal
  totalWithdrawn_gte: BigDecimal
  totalWithdrawn_in: [BigDecimal!]
  totalWithdrawn_lt: BigDecimal
  totalWithdrawn_lte: BigDecimal
  totalWithdrawn_not: BigDecimal
  totalWithdrawn_not_in: [BigDecimal!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum UserStakeHistory_orderBy {
  id
  stakeHistory
  totalRemaining
  totalStaked
  totalWithdrawn
  user
}

"""
This is the total volumes of different actions for one user. See ProtocolStats entity for full descriptions.
"""
type UserTotal {
  id: ID!
  totalAmmLpFeesUsd: BigDecimal!
  totalAmmStakerFeesUsd: BigDecimal!
  totalAmmVolumeUsd: BigDecimal!
  totalBorrowVolumeUsd: BigDecimal!
  totalBorrowingFeesUsd: BigDecimal!
  totalCloseWithDepositVolumeUsd: BigDecimal!
  totalCloseWithSwapVolumeUsd: BigDecimal!
  totalDepositCollateralVolumeUsd: BigDecimal!
  totalLendVolumeUsd: BigDecimal!
  totalLendingFeesUsd: BigDecimal!
  totalLiquidateVolumeUsd: BigDecimal!
  totalMarginTradeVolumeUsd: BigDecimal!
  totalTradingFeesUsd: BigDecimal!
  totalUnlendVolumeUsd: BigDecimal!
  user: User!
}

input UserTotal_filter {
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  totalAmmLpFeesUsd: BigDecimal
  totalAmmLpFeesUsd_gt: BigDecimal
  totalAmmLpFeesUsd_gte: BigDecimal
  totalAmmLpFeesUsd_in: [BigDecimal!]
  totalAmmLpFeesUsd_lt: BigDecimal
  totalAmmLpFeesUsd_lte: BigDecimal
  totalAmmLpFeesUsd_not: BigDecimal
  totalAmmLpFeesUsd_not_in: [BigDecimal!]
  totalAmmStakerFeesUsd: BigDecimal
  totalAmmStakerFeesUsd_gt: BigDecimal
  totalAmmStakerFeesUsd_gte: BigDecimal
  totalAmmStakerFeesUsd_in: [BigDecimal!]
  totalAmmStakerFeesUsd_lt: BigDecimal
  totalAmmStakerFeesUsd_lte: BigDecimal
  totalAmmStakerFeesUsd_not: BigDecimal
  totalAmmStakerFeesUsd_not_in: [BigDecimal!]
  totalAmmVolumeUsd: BigDecimal
  totalAmmVolumeUsd_gt: BigDecimal
  totalAmmVolumeUsd_gte: BigDecimal
  totalAmmVolumeUsd_in: [BigDecimal!]
  totalAmmVolumeUsd_lt: BigDecimal
  totalAmmVolumeUsd_lte: BigDecimal
  totalAmmVolumeUsd_not: BigDecimal
  totalAmmVolumeUsd_not_in: [BigDecimal!]
  totalBorrowVolumeUsd: BigDecimal
  totalBorrowVolumeUsd_gt: BigDecimal
  totalBorrowVolumeUsd_gte: BigDecimal
  totalBorrowVolumeUsd_in: [BigDecimal!]
  totalBorrowVolumeUsd_lt: BigDecimal
  totalBorrowVolumeUsd_lte: BigDecimal
  totalBorrowVolumeUsd_not: BigDecimal
  totalBorrowVolumeUsd_not_in: [BigDecimal!]
  totalBorrowingFeesUsd: BigDecimal
  totalBorrowingFeesUsd_gt: BigDecimal
  totalBorrowingFeesUsd_gte: BigDecimal
  totalBorrowingFeesUsd_in: [BigDecimal!]
  totalBorrowingFeesUsd_lt: BigDecimal
  totalBorrowingFeesUsd_lte: BigDecimal
  totalBorrowingFeesUsd_not: BigDecimal
  totalBorrowingFeesUsd_not_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd: BigDecimal
  totalCloseWithDepositVolumeUsd_gt: BigDecimal
  totalCloseWithDepositVolumeUsd_gte: BigDecimal
  totalCloseWithDepositVolumeUsd_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd_lt: BigDecimal
  totalCloseWithDepositVolumeUsd_lte: BigDecimal
  totalCloseWithDepositVolumeUsd_not: BigDecimal
  totalCloseWithDepositVolumeUsd_not_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd: BigDecimal
  totalCloseWithSwapVolumeUsd_gt: BigDecimal
  totalCloseWithSwapVolumeUsd_gte: BigDecimal
  totalCloseWithSwapVolumeUsd_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd_lt: BigDecimal
  totalCloseWithSwapVolumeUsd_lte: BigDecimal
  totalCloseWithSwapVolumeUsd_not: BigDecimal
  totalCloseWithSwapVolumeUsd_not_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd: BigDecimal
  totalDepositCollateralVolumeUsd_gt: BigDecimal
  totalDepositCollateralVolumeUsd_gte: BigDecimal
  totalDepositCollateralVolumeUsd_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd_lt: BigDecimal
  totalDepositCollateralVolumeUsd_lte: BigDecimal
  totalDepositCollateralVolumeUsd_not: BigDecimal
  totalDepositCollateralVolumeUsd_not_in: [BigDecimal!]
  totalLendVolumeUsd: BigDecimal
  totalLendVolumeUsd_gt: BigDecimal
  totalLendVolumeUsd_gte: BigDecimal
  totalLendVolumeUsd_in: [BigDecimal!]
  totalLendVolumeUsd_lt: BigDecimal
  totalLendVolumeUsd_lte: BigDecimal
  totalLendVolumeUsd_not: BigDecimal
  totalLendVolumeUsd_not_in: [BigDecimal!]
  totalLendingFeesUsd: BigDecimal
  totalLendingFeesUsd_gt: BigDecimal
  totalLendingFeesUsd_gte: BigDecimal
  totalLendingFeesUsd_in: [BigDecimal!]
  totalLendingFeesUsd_lt: BigDecimal
  totalLendingFeesUsd_lte: BigDecimal
  totalLendingFeesUsd_not: BigDecimal
  totalLendingFeesUsd_not_in: [BigDecimal!]
  totalLiquidateVolumeUsd: BigDecimal
  totalLiquidateVolumeUsd_gt: BigDecimal
  totalLiquidateVolumeUsd_gte: BigDecimal
  totalLiquidateVolumeUsd_in: [BigDecimal!]
  totalLiquidateVolumeUsd_lt: BigDecimal
  totalLiquidateVolumeUsd_lte: BigDecimal
  totalLiquidateVolumeUsd_not: BigDecimal
  totalLiquidateVolumeUsd_not_in: [BigDecimal!]
  totalMarginTradeVolumeUsd: BigDecimal
  totalMarginTradeVolumeUsd_gt: BigDecimal
  totalMarginTradeVolumeUsd_gte: BigDecimal
  totalMarginTradeVolumeUsd_in: [BigDecimal!]
  totalMarginTradeVolumeUsd_lt: BigDecimal
  totalMarginTradeVolumeUsd_lte: BigDecimal
  totalMarginTradeVolumeUsd_not: BigDecimal
  totalMarginTradeVolumeUsd_not_in: [BigDecimal!]
  totalTradingFeesUsd: BigDecimal
  totalTradingFeesUsd_gt: BigDecimal
  totalTradingFeesUsd_gte: BigDecimal
  totalTradingFeesUsd_in: [BigDecimal!]
  totalTradingFeesUsd_lt: BigDecimal
  totalTradingFeesUsd_lte: BigDecimal
  totalTradingFeesUsd_not: BigDecimal
  totalTradingFeesUsd_not_in: [BigDecimal!]
  totalUnlendVolumeUsd: BigDecimal
  totalUnlendVolumeUsd_gt: BigDecimal
  totalUnlendVolumeUsd_gte: BigDecimal
  totalUnlendVolumeUsd_in: [BigDecimal!]
  totalUnlendVolumeUsd_lt: BigDecimal
  totalUnlendVolumeUsd_lte: BigDecimal
  totalUnlendVolumeUsd_not: BigDecimal
  totalUnlendVolumeUsd_not_in: [BigDecimal!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum UserTotal_orderBy {
  id
  totalAmmLpFeesUsd
  totalAmmStakerFeesUsd
  totalAmmVolumeUsd
  totalBorrowVolumeUsd
  totalBorrowingFeesUsd
  totalCloseWithDepositVolumeUsd
  totalCloseWithSwapVolumeUsd
  totalDepositCollateralVolumeUsd
  totalLendVolumeUsd
  totalLendingFeesUsd
  totalLiquidateVolumeUsd
  totalMarginTradeVolumeUsd
  totalTradingFeesUsd
  totalUnlendVolumeUsd
  user
}

input User_filter {
  createdAtTimestamp: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_lt: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
}

enum User_orderBy {
  bitcoinTransfers
  borrows
  createdAtTimestamp
  fastBTCBridgeStats
  id
  lendingHistory
  liquidations
  liquidityHistory
  loans
  rewardsEarnedHistory
  stakeHistory
  swaps
  trades
  transactions
  userTotals
  vestingContracts
  votes
}

type VestingContract {
  cliff: Int
  createdAtTimestamp: Int!
  createdAtTransaction: Transaction!
  currentBalance: BigDecimal!
  duration: Int
  emittedBy: Bytes!
  id: ID!
  stakeHistory(
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VestingHistoryItem_filter
  ): [VestingHistoryItem!]
  startingBalance: BigDecimal!
  type: VestingContractType!
  user: User!
}

enum VestingContractType {
  Fish
  FishTeam
  FourYearVesting
  Genesis
  Origins
  Rewards
  Strategic
  Team
}

input VestingContract_filter {
  cliff: Int
  cliff_gt: Int
  cliff_gte: Int
  cliff_in: [Int!]
  cliff_lt: Int
  cliff_lte: Int
  cliff_not: Int
  cliff_not_in: [Int!]
  createdAtTimestamp: Int
  createdAtTimestamp_gt: Int
  createdAtTimestamp_gte: Int
  createdAtTimestamp_in: [Int!]
  createdAtTimestamp_lt: Int
  createdAtTimestamp_lte: Int
  createdAtTimestamp_not: Int
  createdAtTimestamp_not_in: [Int!]
  createdAtTransaction: String
  createdAtTransaction_contains: String
  createdAtTransaction_ends_with: String
  createdAtTransaction_gt: String
  createdAtTransaction_gte: String
  createdAtTransaction_in: [String!]
  createdAtTransaction_lt: String
  createdAtTransaction_lte: String
  createdAtTransaction_not: String
  createdAtTransaction_not_contains: String
  createdAtTransaction_not_ends_with: String
  createdAtTransaction_not_in: [String!]
  createdAtTransaction_not_starts_with: String
  createdAtTransaction_starts_with: String
  currentBalance: BigDecimal
  currentBalance_gt: BigDecimal
  currentBalance_gte: BigDecimal
  currentBalance_in: [BigDecimal!]
  currentBalance_lt: BigDecimal
  currentBalance_lte: BigDecimal
  currentBalance_not: BigDecimal
  currentBalance_not_in: [BigDecimal!]
  duration: Int
  duration_gt: Int
  duration_gte: Int
  duration_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_not: Int
  duration_not_in: [Int!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  startingBalance: BigDecimal
  startingBalance_gt: BigDecimal
  startingBalance_gte: BigDecimal
  startingBalance_in: [BigDecimal!]
  startingBalance_lt: BigDecimal
  startingBalance_lte: BigDecimal
  startingBalance_not: BigDecimal
  startingBalance_not_in: [BigDecimal!]
  type: VestingContractType
  type_in: [VestingContractType!]
  type_not: VestingContractType
  type_not_in: [VestingContractType!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

enum VestingContract_orderBy {
  cliff
  createdAtTimestamp
  createdAtTransaction
  currentBalance
  duration
  emittedBy
  id
  stakeHistory
  startingBalance
  type
  user
}

type VestingHistoryItem {
  action: VestingHistoryItemAction!
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  lockedUntil: Int!
  staker: VestingContract!
  timestamp: Int!
  totalStaked: BigDecimal!
  transaction: Transaction!
}

enum VestingHistoryItemAction {
  TeamTokensRevoked
  TokensStaked
  TokensWithdrawn
}

input VestingHistoryItem_filter {
  action: VestingHistoryItemAction
  action_in: [VestingHistoryItemAction!]
  action_not: VestingHistoryItemAction
  action_not_in: [VestingHistoryItemAction!]
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedUntil: Int
  lockedUntil_gt: Int
  lockedUntil_gte: Int
  lockedUntil_in: [Int!]
  lockedUntil_lt: Int
  lockedUntil_lte: Int
  lockedUntil_not: Int
  lockedUntil_not_in: [Int!]
  staker: String
  staker_contains: String
  staker_ends_with: String
  staker_gt: String
  staker_gte: String
  staker_in: [String!]
  staker_lt: String
  staker_lte: String
  staker_not: String
  staker_not_contains: String
  staker_not_ends_with: String
  staker_not_in: [String!]
  staker_not_starts_with: String
  staker_starts_with: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalStaked: BigDecimal
  totalStaked_gt: BigDecimal
  totalStaked_gte: BigDecimal
  totalStaked_in: [BigDecimal!]
  totalStaked_lt: BigDecimal
  totalStaked_lte: BigDecimal
  totalStaked_not: BigDecimal
  totalStaked_not_in: [BigDecimal!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum VestingHistoryItem_orderBy {
  action
  amount
  emittedBy
  id
  lockedUntil
  staker
  timestamp
  totalStaked
  transaction
}

"""
This is the event emitted when a user votes for or against a proposed SIP
"""
type VoteCast {
  emittedBy: Bytes!

  """
  ID is transaction hash + log index
  """
  id: ID!

  """
  The ID of the Proposal entity that this vote is for/against
  """
  proposal: Proposal!

  """
  The ID of the proposal
  """
  proposalId: Int!

  """
  True if the vote is for the proposal, False if it is against
  """
  support: Boolean!
  timestamp: Int!
  transaction: Transaction!
  voter: User!

  """
  The number of votes the user cast (the voting power of that user)
  """
  votes: BigInt!
}

input VoteCast_filter {
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  proposal: String
  proposalId: Int
  proposalId_gt: Int
  proposalId_gte: Int
  proposalId_in: [Int!]
  proposalId_lt: Int
  proposalId_lte: Int
  proposalId_not: Int
  proposalId_not_in: [Int!]
  proposal_contains: String
  proposal_ends_with: String
  proposal_gt: String
  proposal_gte: String
  proposal_in: [String!]
  proposal_lt: String
  proposal_lte: String
  proposal_not: String
  proposal_not_contains: String
  proposal_not_ends_with: String
  proposal_not_in: [String!]
  proposal_not_starts_with: String
  proposal_starts_with: String
  support: Boolean
  support_in: [Boolean!]
  support_not: Boolean
  support_not_in: [Boolean!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
  voter: String
  voter_contains: String
  voter_ends_with: String
  voter_gt: String
  voter_gte: String
  voter_in: [String!]
  voter_lt: String
  voter_lte: String
  voter_not: String
  voter_not_contains: String
  voter_not_ends_with: String
  voter_not_in: [String!]
  voter_not_starts_with: String
  voter_starts_with: String
  votes: BigInt
  votes_gt: BigInt
  votes_gte: BigInt
  votes_in: [BigInt!]
  votes_lt: BigInt
  votes_lte: BigInt
  votes_not: BigInt
  votes_not_in: [BigInt!]
}

enum VoteCast_orderBy {
  emittedBy
  id
  proposal
  proposalId
  support
  timestamp
  transaction
  voter
  votes
}

type Withdrawal {
  amount: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  receiver: Bytes!
  timestamp: Int!
  transaction: Transaction!
}

input Withdrawal_filter {
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  receiver: Bytes
  receiver_contains: Bytes
  receiver_in: [Bytes!]
  receiver_not: Bytes
  receiver_not_contains: Bytes
  receiver_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_contains: String
  transaction_ends_with: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_ends_with: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_starts_with: String
}

enum Withdrawal_orderBy {
  amount
  emittedBy
  id
  receiver
  timestamp
  transaction
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
